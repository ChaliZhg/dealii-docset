<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-20 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-20 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Formulationweakformanddiscreteproblem">Formulation, weak form, and discrete problem</a>
        <li><a href="#Assemblingthelinearsystem">Assembling the linear system</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#SolvingusingtheSchurcomplement">Solving using the Schur complement</a>
        <li><a href="#ApreconditionerfortheSchurcomplement">A preconditioner for the Schur complement</a>
        <li><a href="#AremarkonsimilarfunctionalityindealII">A remark on similar functionality in deal.II</a>
      </ul>
        <li><a href="#Definitionofthetestcase">Definition of the test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMixedLaplaceProblemcodeclasstemplate">The <code>MixedLaplaceProblem</code> class template</a>
        <li><a href="#Righthandsideboundaryvaluesandexactsolution">Right hand side, boundary values, and exact solution</a>
        <li><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a>
        <li><a href="#MixedLaplaceProblemclassimplementation">MixedLaplaceProblem class implementation</a>
      <ul>
        <li><a href="#MixedLaplaceProblemMixedLaplaceProblem">MixedLaplaceProblem::MixedLaplaceProblem</a>
        <li><a href="#MixedLaplaceProblemmake_grid_and_dofs">MixedLaplaceProblem::make_grid_and_dofs</a>
        <li><a href="#MixedLaplaceProblemassemble_system">MixedLaplaceProblem::assemble_system</a>
      </ul>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#ThecodeSchurComplementcodeclass">The <code>SchurComplement</code> class</a>
        <li><a href="#ThecodeApproximateSchurComplementcodeclass">The <code>ApproximateSchurComplement</code> class</a>
        <li><a href="#MixedLaplacesolve">MixedLaplace::solve</a>
      </ul>
        <li><a href="#MixedLaplaceProblemclassimplementationcontinued">MixedLaplaceProblem class implementation (continued)</a>
      <ul>
        <li><a href="#MixedLaplacecompute_errors">MixedLaplace::compute_errors</a>
        <li><a href="#MixedLaplaceoutput_results">MixedLaplace::output_results</a>
        <li><a href="#MixedLaplacerun">MixedLaplace::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a>
        <li><a href="#Convergence">Convergence</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Morerealisticpermeabilityfields">More realistic permeability fields</a>
        <li><a href="#Betterlinearsolvers">Better linear solvers</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.html">video lecture 21</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>This program is devoted to two aspects: the use of mixed finite elements &ndash; in particular Raviart-Thomas elements &ndash; and using block matrices to define solvers, preconditioners, and nested versions of those that use the substructure of the system matrix. The equation we are going to solve is again the Laplace equation, though with a matrix-valued coefficient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot K({\mathbf x}) \nabla p &amp;=&amp; f \qquad {\textrm{in}\ } \Omega, \\ p &amp;=&amp; g \qquad {\textrm{on}\ }\partial\Omega. \end{eqnarray*}" src="form_1659.png"/>
</p>
<p> <img class="formulaInl" alt="$K({\mathbf x})$" src="form_1660.png"/> is assumed to be uniformly positive definite, i.e., there is <img class="formulaInl" alt="$\alpha&gt;0$" src="form_1661.png"/> such that the eigenvalues <img class="formulaInl" alt="$\lambda_i({\mathbf x})$" src="form_1662.png"/> of <img class="formulaInl" alt="$K(x)$" src="form_1663.png"/> satisfy <img class="formulaInl" alt="$\lambda_i({\mathbf x})\ge \alpha$" src="form_1664.png"/>. The use of the symbol <img class="formulaInl" alt="$p$" src="form_202.png"/> instead of the usual <img class="formulaInl" alt="$u$" src="form_256.png"/> for the solution variable will become clear in the next section.</p>
<p>After discussing the equation and the formulation we are going to use to solve it, this introduction will cover the use of block matrices and vectors, the definition of solvers and preconditioners, and finally the actual test case we are going to solve.</p>
<p>We are going to extend this tutorial program in <a class="el" href="step_21.html">step-21</a> to solve not only the mixed Laplace equation, but add another equation that describes the transport of a mixture of two fluids.</p>
<p>The equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Formulationweakformanddiscreteproblem"></a></p><h3>Formulation, weak form, and discrete problem</h3>
<p>In the form above, the Laplace equation is generally considered a good model equation for fluid flow in porous media. In particular, if flow is so slow that all dynamic effects such as the acceleration terms in the Navier-Stokes equation become irrelevant, and if the flow pattern is stationary, then the Laplace equation models the pressure that drives the flow reasonably well. (Because the solution variable is a pressure, we here use the name <img class="formulaInl" alt="$p$" src="form_202.png"/> instead of the name <img class="formulaInl" alt="$u$" src="form_256.png"/> more commonly used for the solution of partial differential equations.)</p>
<p>Typical applications of this view of the Laplace equation are then modeling groundwater flow, or the flow of hydrocarbons in oil reservoirs. In these applications, <img class="formulaInl" alt="$K$" src="form_57.png"/> is then the permeability tensor, i.e. a measure for how much resistance the soil or rock matrix asserts on the fluid flow. In the applications just named, a desirable feature is that the numerical scheme is locally conservative, i.e. that whatever flows into a cell also flows out of it (or the difference is equal to the integral over the source terms over each cell, if the sources are nonzero). However, as it turns out, the usual discretizations of the Laplace equation do not satisfy this property. On the other hand, one can achieve this by choosing a different formulation.</p>
<p>To this end, one first introduces a second variable, called the flux, <img class="formulaInl" alt="${\mathbf u}=-K\nabla p$" src="form_1665.png"/>. By its definition, the flux is a vector in the negative direction of the pressure gradient, multiplied by the permeability tensor. If the permeability tensor is proportional to the unit matrix, this equation is easy to understand and intuitive: the higher the permeability, the higher the flux; and the flux is proportional to the gradient of the pressure, going from areas of high pressure to areas of low pressure.</p>
<p>With this second variable, one then finds an alternative version of the Laplace equation, called the mixed formulation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} K^{-1} {\mathbf u} + \nabla p &amp;=&amp; 0 \qquad {\textrm{in}\ } \Omega, \\ -{\textrm{div}}\ {\mathbf u} &amp;=&amp; -f \qquad {\textrm{in}\ }\Omega, \\ p &amp;=&amp; g \qquad {\textrm{on}\ } \partial\Omega. \end{eqnarray*}" src="form_1666.png"/>
</p>
<p> Here, we have multiplied the equation defining the velocity <img class="formulaInl" alt="${\mathbf u}$" src="form_1667.png"/> by <img class="formulaInl" alt="$K^{-1}$" src="form_1668.png"/> because this makes the set of equations symmetric: one of the equations has the gradient, the second the negative divergence, and these two are of course adjoints of each other, resulting in a symmetric bilinear form and a consequently symmetric system matrix under the common assumption that <img class="formulaInl" alt="$K$" src="form_57.png"/> is a symmetric tensor.</p>
<p>The weak formulation of this problem is found by multiplying the two equations with test functions and integrating some terms by parts: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A(\{{\mathbf u},p\},\{{\mathbf v},q\}) = F(\{{\mathbf v},q\}), \end{eqnarray*}" src="form_1669.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A(\{{\mathbf u},p\},\{{\mathbf v},q\}) &amp;=&amp; ({\mathbf v}, K^{-1}{\mathbf u})_\Omega - ({\textrm{div}}\ {\mathbf v}, p)_\Omega - (q,{\textrm{div}}\ {\mathbf u})_\Omega \\ F(\{{\mathbf v},q\}) &amp;=&amp; -(g,{\mathbf v}\cdot {\mathbf n})_{\partial\Omega} - (f,q)_\Omega. \end{eqnarray*}" src="form_1670.png"/>
</p>
<p> Here, <img class="formulaInl" alt="${\mathbf n}$" src="form_1671.png"/> is the outward normal vector at the boundary. Note how in this formulation, Dirichlet boundary values of the original problem are incorporated in the weak form.</p>
<p>To be well-posed, we have to look for solutions and test functions in the space <img class="formulaInl" alt="$H({\textrm{div}})=\{{\mathbf w}\in L^2(\Omega)^d:\ {\textrm{div}}\ {\mathbf w}\in L^2\}$" src="form_1672.png"/> for <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/>, <img class="formulaInl" alt="$\mathbf v$" src="form_221.png"/>, and <img class="formulaInl" alt="$L^2$" src="form_700.png"/> for <img class="formulaInl" alt="$p,q$" src="form_1673.png"/>. It is a well-known fact stated in almost every book on finite element theory that if one chooses discrete finite element spaces for the approximation of <img class="formulaInl" alt="${\mathbf u},p$" src="form_1674.png"/> inappropriately, then the resulting discrete saddle-point problem is instable and the discrete solution will not converge to the exact solution.</p>
<p>To overcome this, a number of different finite element pairs for <img class="formulaInl" alt="${\mathbf u},p$" src="form_1674.png"/> have been developed that lead to a stable discrete problem. One such pair is to use the Raviart-Thomas spaces <img class="formulaInl" alt="$RT(k)$" src="form_1675.png"/> for the velocity <img class="formulaInl" alt="${\mathbf u}$" src="form_1667.png"/> and discontinuous elements of class <img class="formulaInl" alt="$DQ(k)$" src="form_1676.png"/> for the pressure <img class="formulaInl" alt="$p$" src="form_202.png"/>. For details about these spaces, we refer in particular to the book on mixed finite element methods by Brezzi and Fortin, but many other books on the theory of finite elements, for example the classic book by Brenner and Scott, also state the relevant results.</p>
<p><a class="anchor" id="Assemblingthelinearsystem"></a></p><h3>Assembling the linear system</h3>
<p>The deal.II library (of course) implements Raviart-Thomas elements <img class="formulaInl" alt="$RT(k)$" src="form_1675.png"/> of arbitrary order <img class="formulaInl" alt="$k$" src="form_44.png"/>, as well as discontinuous elements <img class="formulaInl" alt="$DG(k)$" src="form_1677.png"/>. If we forget about their particular properties for a second, we then have to solve a discrete problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A(x_h,w_h) = F(w_h), \end{eqnarray*}" src="form_1678.png"/>
</p>
<p> with the bilinear form and right hand side as stated above, and <img class="formulaInl" alt="$x_h=\{{\mathbf u}_h,p_h\}$" src="form_1679.png"/>, <img class="formulaInl" alt="$w_h=\{{\mathbf v}_h,q_h\}$" src="form_1680.png"/>. Both <img class="formulaInl" alt="$x_h$" src="form_1681.png"/> and <img class="formulaInl" alt="$w_h$" src="form_1682.png"/> are from the space <img class="formulaInl" alt="$X_h=RT(k)\times DQ(k)$" src="form_1683.png"/>, where <img class="formulaInl" alt="$RT(k)$" src="form_1675.png"/> is itself a space of <img class="formulaInl" alt="$dim$" src="form_312.png"/>-dimensional functions to accommodate for the fact that the flow velocity is vector-valued. The necessary question then is: how do we do this in a program?</p>
<p>Vector-valued elements have already been discussed in previous tutorial programs, the first time and in detail in <a class="el" href="step_8.html">step-8</a>. The main difference there was that the vector-valued space <img class="formulaInl" alt="$V_h$" src="form_79.png"/> is uniform in all its components: the <img class="formulaInl" alt="$dim$" src="form_312.png"/> components of the displacement vector are all equal and from the same function space. What we could therefore do was to build <img class="formulaInl" alt="$V_h$" src="form_79.png"/> as the outer product of the <img class="formulaInl" alt="$dim$" src="form_312.png"/> times the usual <img class="formulaInl" alt="$Q(1)$" src="form_1684.png"/> finite element space, and by this make sure that all our shape functions have only a single non-zero vector component. Instead of dealing with vector-valued shape functions, all we did in <a class="el" href="step_8.html">step-8</a> was therefore to look at the (scalar) only non-zero component and use the <code>fe.system_to_component_index(i).first</code> call to figure out which component this actually is.</p>
<p>This doesn't work with Raviart-Thomas elements: following from their construction to satisfy certain regularity properties of the space <img class="formulaInl" alt="$H({\textrm{div}})$" src="form_1685.png"/>, the shape functions of <img class="formulaInl" alt="$RT(k)$" src="form_1675.png"/> are usually nonzero in all their vector components at once. For this reason, were <code>fe.system_to_component_index(i).first</code> applied to determine the only nonzero component of shape function <img class="formulaInl" alt="$i$" src="form_90.png"/>, an exception would be generated. What we really need to do is to get at <em>all</em> vector components of a shape function. In deal.II diction, we call such finite elements <em>non-primitive</em>, whereas finite elements that are either scalar or for which every vector-valued shape function is nonzero only in a single vector component are called <em>primitive</em>.</p>
<p>So what do we have to do for non-primitive elements? To figure this out, let us go back in the tutorial programs, almost to the very beginnings. There, we learned that we use the <code><a class="el" href="classFEValues.html">FEValues</a></code> class to determine the values and gradients of shape functions at quadrature points. For example, we would call <code>fe_values.shape_value(i,q_point)</code> to obtain the value of the <code>i</code>th shape function on the quadrature point with number <code>q_point</code>. Later, in <a class="el" href="step_8.html">step-8</a> and other tutorial programs, we learned that this function call also works for vector-valued shape functions (of primitive finite elements), and that it returned the value of the only non-zero component of shape function <code>i</code> at quadrature point <code>q_point</code>.</p>
<p>For non-primitive shape functions, this is clearly not going to work: there is no single non-zero vector component of shape function <code>i</code>, and the call to <code>fe_values.shape_value(i,q_point)</code> would consequently not make much sense. However, deal.II offers a second function call, <code>fe_values.shape_value_component(i,q_point,comp)</code> that returns the value of the <code>comp</code>th vector component of shape function <code>i</code> at quadrature point <code>q_point</code>, where <code>comp</code> is an index between zero and the number of vector components of the present finite element; for example, the element we will use to describe velocities and pressures is going to have <img class="formulaInl" alt="$dim+1$" src="form_1686.png"/> components. It is worth noting that this function call can also be used for primitive shape functions: it will simply return zero for all components except one; for non-primitive shape functions, it will in general return a non-zero value for more than just one component.</p>
<p>We could now attempt to rewrite the bilinear form above in terms of vector components. For example, in 2d, the first term could be rewritten like this (note that <img class="formulaInl" alt="$u_0=x_0, u_1=x_1, p=x_2$" src="form_1687.png"/>): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} ({\mathbf u}_h^i, K^{-1}{\mathbf u}_h^j) = &amp;\left((x_h^i)_0, K^{-1}_{00} (x_h^j)_0\right) + \left((x_h^i)_0, K^{-1}_{01} (x_h^j)_1\right) + \\ &amp;\left((x_h^i)_1, K^{-1}_{10} (x_h^j)_0\right) + \left((x_h^i)_1, K^{-1}_{11} (x_h^j)_1\right). \end{eqnarray*}" src="form_1688.png"/>
</p>
<p> If we implemented this, we would get code like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      local_matrix(i,j) += (k_inverse_values[q][0][0] *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(i,q,0) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(j,q,0)</div><div class="line">                            +</div><div class="line">                            k_inverse_values[q][0][1] *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(i,q,0) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(j,q,1)</div><div class="line">                            +</div><div class="line">                            k_inverse_values[q][1][0] *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(i,q,1) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(j,q,0)</div><div class="line">                            +</div><div class="line">                            k_inverse_values[q][1][1] *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(i,q,1) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a>(j,q,1)</div><div class="line">                           )</div><div class="line">                            </div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div></div><!-- fragment --><p>This is, at best, tedious, error prone, and not dimension independent. There are obvious ways to make things dimension independent, but in the end, the code is simply not pretty. What would be much nicer is if we could simply extract the <img class="formulaInl" alt="${\mathbf u}$" src="form_1667.png"/> and <img class="formulaInl" alt="$p$" src="form_202.png"/> components of a shape function <img class="formulaInl" alt="$x_h^i$" src="form_1689.png"/>. In the program we do that in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      local_matrix(i,j) += (fe_values[velocities].value (i, q) *</div><div class="line">                            k_inverse_values[q] *</div><div class="line">                            fe_values[velocities].value (j, q)</div><div class="line">                            -</div><div class="line">                            fe_values[velocities].divergence (i, q) *</div><div class="line">                            fe_values[pressure].value (j, q)</div><div class="line">                            -</div><div class="line">                            fe_values[pressure].value (i, q) *</div><div class="line">                            fe_values[velocities].divergence (j, q)) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div></div><!-- fragment --><p>This is, in fact, not only the first term of the bilinear form, but the whole thing (sans boundary contributions).</p>
<p>What this piece of code does is, given an <code>fe_values</code> object, to extract the values of the first <img class="formulaInl" alt="$dim$" src="form_312.png"/> components of shape function <code>i</code> at quadrature points <code>q</code>, that is the velocity components of that shape function. Put differently, if we write shape functions <img class="formulaInl" alt="$x_h^i$" src="form_1689.png"/> as the tuple <img class="formulaInl" alt="$\{{\mathbf u}_h^i,p_h^i\}$" src="form_1690.png"/>, then the function returns the velocity part of this tuple. Note that the velocity is of course a <code>dim</code>-dimensional tensor, and that the function returns a corresponding object. Similarly, where we subscript with the pressure extractor, we extract the scalar pressure component. The whole mechanism is described in more detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p>In practice, it turns out that we can do a bit better if we evaluate the shape functions, their gradients and divergences only once per outermost loop, and store the result, as this saves us a few otherwise repeated computations (it is possible to save even more repeated operations by calculating all relevant quantities in advance and then only inserting the results in the actual loop, see <a class="el" href="step_22.html">step-22</a> for a realization of that approach). The final result then looks like this, working in every space dimension:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                rhs_values);</div><div class="line">    k_inverse.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                          k_inverse_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_i_u     = fe_values[velocities].value (i, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_i_u = fe_values[velocities].divergence (i, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_p     = fe_values[pressure].value (i, q);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_j_u     = fe_values[velocities].value (j, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_j_u = fe_values[velocities].divergence (j, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_p     = fe_values[pressure].value (j, q);</div><div class="line"></div><div class="line">              local_matrix(i,j) += (phi_i_u * k_inverse_values[q] * phi_j_u</div><div class="line">                                    - div_phi_i_u * phi_j_p</div><div class="line">                                    - phi_i_p * div_phi_j_u) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">          local_rhs(i) += -phi_i_p *</div><div class="line">                          rhs_values[q] *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div></div><!-- fragment --><p>This very closely resembles the form in which we have originally written down the bilinear form and right hand side.</p>
<p>There is one final term that we have to take care of: the right hand side contained the term <img class="formulaInl" alt="$(g,{\mathbf v}\cdot {\mathbf n})_{\partial\Omega}$" src="form_1691.png"/>, constituting the weak enforcement of pressure boundary conditions. We have already seen in <a class="el" href="step_7.html">step-7</a> how to deal with face integrals: essentially exactly the same as with domain integrals, except that we have to use the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> class instead of <code><a class="el" href="classFEValues.html">FEValues</a></code>. To compute the boundary term we then simply have to loop over all boundary faces and integrate there. The mechanism works in the same way as above, i.e. the extractor classes also work on <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">     face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face_no)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">    {</div><div class="line">      fe_face_values.reinit (cell, face_no);</div><div class="line"></div><div class="line">      pressure_boundary_values</div><div class="line">        .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                     boundary_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          local_rhs(i) += -(fe_face_values[velocities].value (i, q) *</div><div class="line">                            fe_face_values.normal_vector(q) *</div><div class="line">                            boundary_values[q] *</div><div class="line">                            fe_face_values.JxW(q));</div><div class="line">    }</div></div><!-- fragment --><p>You will find the exact same code as above in the sources for the present program. We will therefore not comment much on it below.</p>
<p><a class="anchor" id="Linearsolversandpreconditioners"></a></p><h3>Linear solvers and preconditioners</h3>
<p>After assembling the linear system we are faced with the task of solving it. The problem here is: the matrix has a zero block at the bottom right (there is no term in the bilinear form that couples the pressure <img class="formulaInl" alt="$p$" src="form_202.png"/> with the pressure test function <img class="formulaInl" alt="$q$" src="form_171.png"/>), and it is indefinite. At least it is symmetric. In other words: the Conjugate Gradient method is not going to work. We would have to resort to other iterative solvers instead, such as MinRes, SymmLQ, or GMRES, that can deal with indefinite systems. However, then the next problem immediately surfaces: due to the zero block, there are zeros on the diagonal and none of the usual preconditioners (Jacobi, SSOR) will work as they require division by diagonal elements.</p>
<p>For the matrix sizes we expect to run with this program, the by far simplest approach would be to just use a direct solver (in particular, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that is bundled with deal.II). <a class="el" href="step_29.html">step-29</a> goes this route and shows that solving <em>any</em> linear system can be done in just 3 or 4 lines of code.</p>
<p>But then, this is a tutorial: we teach how to do things. Consequently, in the following, we will introduce some techniques that can be used in cases like these. Namely, we will consider the linear system as not consisting of one large matrix and vectors, but we will want to decompose matrices into <em>blocks</em> that correspond to the individual operators that appear in the system. We note that the resulting solver is not optimal &ndash; there are much better ways, for example those explained in the results section of <a class="el" href="step_22.html">step-22</a> or the one we use in <a class="el" href="step_43.html">step-43</a> for a problem rather similar to the current one &ndash; but that the goal is to introduce techniques rather than optimal solvers.</p>
<p><a class="anchor" id="SolvingusingtheSchurcomplement"></a></p><h4>Solving using the Schur complement</h4>
<p>In view of the difficulties using standard solvers and preconditioners mentioned above, let us take another look at the matrix. If we sort our degrees of freedom so that all velocity come before all pressure variables, then we can subdivide the linear system <img class="formulaInl" alt="$Ax=h$" src="form_1692.png"/> into the following blocks: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left(\begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}" src="form_1693.png"/>
</p>
<p> where <img class="formulaInl" alt="$U,P$" src="form_63.png"/> are the values of velocity and pressure degrees of freedom, respectively, <img class="formulaInl" alt="$M$" src="form_64.png"/> is the mass matrix on the velocity space, <img class="formulaInl" alt="$B^T$" src="form_66.png"/> corresponds to the negative divergence operator, and <img class="formulaInl" alt="$B$" src="form_65.png"/> is its transpose and corresponds to the gradient.</p>
<p>By block elimination, we can then re-order this system in the following way (multiply the first row of the system by <img class="formulaInl" alt="$B^TM^{-1}$" src="form_242.png"/> and then subtract the second row from it): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} B^TM^{-1}B P &amp;=&amp; B^TM^{-1} F - G, \\ MU &amp;=&amp; F - BP. \end{eqnarray*}" src="form_1694.png"/>
</p>
<p> Here, the matrix <img class="formulaInl" alt="$S=B^TM^{-1}B$" src="form_1695.png"/> (called the <em>Schur complement</em> of <img class="formulaInl" alt="$A$" src="form_40.png"/>) is obviously symmetric and, owing to the positive definiteness of <img class="formulaInl" alt="$M$" src="form_64.png"/> and the fact that <img class="formulaInl" alt="$B$" src="form_65.png"/> has full column rank, <img class="formulaInl" alt="$S$" src="form_731.png"/> is also positive definite.</p>
<p>Consequently, if we could compute <img class="formulaInl" alt="$S$" src="form_731.png"/>, we could apply the Conjugate Gradient method to it. However, computing <img class="formulaInl" alt="$S$" src="form_731.png"/> is expensive, and <img class="formulaInl" alt="$S$" src="form_731.png"/> is in fact also a full matrix. On the other hand, the CG algorithm doesn't require us to actually have a representation of <img class="formulaInl" alt="$S$" src="form_731.png"/>, it is sufficient to form matrix-vector products with it. We can do so in steps: to compute <img class="formulaInl" alt="$Sv=B^TM^{-1}Bv=B^T(M^{-1}(Bv))$" src="form_1696.png"/>, we </p><ol>
<li>
form <img class="formulaInl" alt="$w = B v$" src="form_1697.png"/>; </li>
<li>
solve <img class="formulaInl" alt="$My = w$" src="form_1698.png"/> for <img class="formulaInl" alt="$y=M^{-1}w$" src="form_1699.png"/>, using the CG method applied to the positive definite and symmetric mass matrix <img class="formulaInl" alt="$M$" src="form_64.png"/>; </li>
<li>
form <img class="formulaInl" alt="$z=B^Ty$" src="form_1700.png"/> to obtain <img class="formulaInl" alt="$z=Sv$" src="form_1701.png"/>. </li>
</ol>
<p>Note how we evaluate the expression <img class="formulaInl" alt="$B^TM^{-1}Bv$" src="form_1702.png"/> right to left to avoid matrix-matrix products; this way, all we have to do is evaluate matrix-vector products.</p>
<dl class="section note"><dt>Note</dt><dd>The key point in this consideration is to recognize that to implement an iterative solver such as CG or GMRES, we never actually need the actual <em>elements</em> of a matrix! All that is required is that we can form matrix-vector products. The same is true for preconditioners. In deal.II we encode this requirement by only requiring that matrices and preconditioners given to solver classes have a <code>vmult()</code> member function that does the matrix-vector product. How a class chooses to implement this function is not important to the solver. Consequently, classes can implement it by, for example, doing a sequence of products and linear solves as discussed above.</dd></dl>
<p>Using this strategy, we can then implement a class that provides the function <code>vmult()</code> that is all that the <a class="el" href="classSolverCG.html">SolverCG</a> class requires from an object representing a matrix. We can make our life a bit easier by also introducing an object that represents <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/> and that has its own <code>vmult()</code> function that, if called, solves the linear system with <img class="formulaInl" alt="$M$" src="form_64.png"/>. Using this (which we will implement as the <code>InverseMatrix</code> class in the body of the program), the class that implements the Schur only needs to offer the <code>vmult()</code> function to perform a matrix-vector multiplication, using the algorithm above. Here are again the relevant parts of the code:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;A,</div><div class="line">                     <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;inverse_mass);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a> &gt; &gt; inverse_mass;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> SchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;block(0,1).vmult (tmp1, src); <span class="comment">// multiply with the top right block: B</span></div><div class="line">  inverse_mass-&gt;vmult (tmp2, tmp1);            <span class="comment">// multiply with M^-1</span></div><div class="line">  system_matrix-&gt;block(1,0).vmult (dst, tmp2); <span class="comment">// multiply with the bottom left block: B^T</span></div><div class="line">}</div></div><!-- fragment --><p>In this code, the constructor takes a reference to a block sparse matrix for the entire system, and a reference to the object representing the inverse of the mass matrix. It stores these using <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> objects (see <a class="el" href="step_7.html">step-7</a>), and additionally allocates two temporary vectors <code>tmp1</code> and <code>tmp2</code> for the vectors labeled <img class="formulaInl" alt="$w,y$" src="form_1704.png"/> in the list above.</p>
<p>In the matrix-vector multiplication function, the product <img class="formulaInl" alt="$Sv$" src="form_1705.png"/> is performed in exactly the order outlined above. Note how we access the blocks <img class="formulaInl" alt="$B$" src="form_65.png"/> and <img class="formulaInl" alt="$B^T$" src="form_66.png"/> by calling <code>system_matrix-&gt;block(0,1)</code> and <code>system_matrix-&gt;block(1,0)</code> respectively, thereby picking out individual blocks of the block system. Multiplication by <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/> happens using the object introduced above.</p>
<p>With all this, we can go ahead and write down the solver we are going to use. Essentially, all we need to do is form the right hand sides of the two equations defining <img class="formulaInl" alt="$P$" src="form_98.png"/> and <img class="formulaInl" alt="$U$" src="form_203.png"/>, and then solve them with the Schur complement matrix and the mass matrix, respectively:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  InverseMatrix&lt;SparseMatrix&lt;double&gt; &gt; inverse_mass (system_matrix.block(0,0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line"></div><div class="line">  {</div><div class="line">    SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (system_matrix, inverse_mass);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">    inverse_mass.vmult (tmp, system_rhs.block(0));</div><div class="line">    system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">    schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> preconditioner;</div><div class="line">    cg.solve (<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs,</div><div class="line">              preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    system_matrix.block(0,1).<a class="code" href="classPreconditionSSOR.html#ad2369ede91810bf1f8b40edccad48175">vmult</a> (tmp, solution.block(1));</div><div class="line">    tmp *= -1;</div><div class="line">    tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">    inverse_mass.vmult (solution.block(0), tmp);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>This code looks more impressive than it actually is. At the beginning, we declare an object representing <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/> and a temporary vector (of the size of the first block of the solution, i.e. with as many entries as there are velocity unknowns), and the two blocks surrounded by braces then solve the two equations for <img class="formulaInl" alt="$P$" src="form_98.png"/> and <img class="formulaInl" alt="$U$" src="form_203.png"/>, in this order. Most of the code in each of the two blocks is actually devoted to constructing the proper right hand sides. For the first equation, this would be <img class="formulaInl" alt="$B^TM^{-1}F-G$" src="form_1706.png"/>, and <img class="formulaInl" alt="$-BP+F$" src="form_1707.png"/> for the second one. The first hand side is then solved with the Schur complement matrix, and the second simply multiplied with <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/>. The code as shown uses no preconditioner (i.e. the identity matrix as preconditioner) for the Schur complement.</p>
<p><a class="anchor" id="ApreconditionerfortheSchurcomplement"></a></p><h4>A preconditioner for the Schur complement</h4>
<p>One may ask whether it would help if we had a preconditioner for the Schur complement <img class="formulaInl" alt="$S=B^TM^{-1}B$" src="form_1695.png"/>. The general answer, as usual, is: of course. The problem is only, we don't know anything about this Schur complement matrix. We do not know its entries, all we know is its action. On the other hand, we have to realize that our solver is expensive since in each iteration we have to do one matrix-vector product with the Schur complement, which means that we have to do invert the mass matrix once in each iteration.</p>
<p>There are different approaches to preconditioning such a matrix. On the one extreme is to use something that is cheap to apply and therefore has no real impact on the work done in each iteration. The other extreme is a preconditioner that is itself very expensive, but in return really brings down the number of iterations required to solve with <img class="formulaInl" alt="$S$" src="form_731.png"/>.</p>
<p>We will try something along the second approach, as much to improve the performance of the program as to demonstrate some techniques. To this end, let us recall that the ideal preconditioner is, of course, <img class="formulaInl" alt="$S^{-1}$" src="form_1708.png"/>, but that is unattainable. However, how about </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \tilde S^{-1} = [B^T ({\textrm{diag}\ }M)^{-1}B]^{-1} \end{eqnarray*}" src="form_1709.png"/>
</p>
<p> as a preconditioner? That would mean that every time we have to do one preconditioning step, we actually have to solve with <img class="formulaInl" alt="$\tilde S$" src="form_1710.png"/>. At first, this looks almost as expensive as solving with <img class="formulaInl" alt="$S$" src="form_731.png"/> right away. However, note that in the inner iteration, we do not have to calculate <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/>, but only the inverse of its diagonal, which is cheap.</p>
<p>The next step is to define a class that represents this approximate Schur complement. This should look very much like the Schur complement class itself, except that it doesn't need the object representing <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/> any more since we can compute the inverse of the diagonal of <img class="formulaInl" alt="$M$" src="form_64.png"/> on the fly:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ApproximateSchurComplement::vmult</div><div class="line">  (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">    system_matrix-&gt;block(0,0).precondition_Jacobi (tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">  }</div></div><!-- fragment --><p>Note how the <code>vmult</code> function differs in simply doing one Jacobi sweep (i.e. multiplying with the inverses of the diagonal) instead of multiplying with the full <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/>. (This is how a single Jacobi preconditioner step with <img class="formulaInl" alt="$M$" src="form_64.png"/> is defined: it is the multiplication with the inverse of the diagonal of <img class="formulaInl" alt="$M$" src="form_64.png"/>; in other words, the operation <img class="formulaInl" alt="$({\textrm{diag}\ }M)^{-1}x$" src="form_1711.png"/> on a vector <img class="formulaInl" alt="$x$" src="form_9.png"/> is exactly what the function <a class="el" href="classSparseMatrix.html#a0b1f22866ffd7e47bfb32f62a1d3e711">SparseMatrix::precondition_Jacobi</a> above does.)</p>
<p>With all this, we nearly already have the preconditioner: it should be the inverse of the approximate Schur complement. We implement this with the <code>InverseMatrix</code> class:</p>
<div class="fragment"><div class="line">ApproximateSchurComplement approximate_schur (system_matrix);</div><div class="line">InverseMatrix&lt;ApproximateSchurComplement&gt; approximate_inverse</div><div class="line">(approximate_schur);</div></div><!-- fragment --><p>That's all!</p>
<p>Taken together, the first block of our <code>solve()</code> function will then look like this:</p>
<div class="fragment"><div class="line">SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (system_matrix, inverse_mass);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">inverse_mass.vmult (tmp, system_rhs.block(0));</div><div class="line">system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div><div class="line"></div><div class="line">ApproximateSchurComplement approximate_schur (system_matrix);</div><div class="line">InverseMatrix&lt;ApproximateSchurComplement&gt; approximate_inverse</div><div class="line">(approximate_schur);</div><div class="line">cg.solve (<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs,</div><div class="line">          approximate_inverse);</div></div><!-- fragment --><p>Note how we pass the so-defined preconditioner to the solver working on the Schur complement matrix.</p>
<p>Obviously, applying this inverse of the approximate Schur complement is a very expensive preconditioner, almost as expensive as inverting the Schur complement itself. We can expect it to significantly reduce the number of outer iterations required for the Schur complement. In fact it does: in a typical run on 5 times refined meshes using elements of order 0, the number of outer iterations drops from 164 to 12. On the other hand, we now have to apply a very expensive preconditioner 12 times. A better measure is therefore simply the run-time of the program: on my laptop, it drops from 28 to 23 seconds for this test case. That doesn't seem too impressive, but the savings become more pronounced on finer meshes and with elements of higher order. For example, a six times refined mesh and using elements of order 2 yields an improvement of 318 to 12 outer iterations, at a runtime of 338 seconds to 229 seconds. Not earth shattering, but significant.</p>
<p><a class="anchor" id="AremarkonsimilarfunctionalityindealII"></a></p><h4>A remark on similar functionality in deal.II</h4>
<p>As a final remark about solvers and preconditioners, let us note that a significant amount of functionality introduced above is actually also present in the library itself. It probably even is more powerful and general, but we chose to introduce this material here anyway to demonstrate how to work with block matrices and to develop solvers and preconditioners, rather than using black box components from the library.</p>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>In this tutorial program, we will solve the Laplace equation in mixed formulation as stated above. Since we want to monitor convergence of the solution inside the program, we choose right hand side, boundary conditions, and the coefficient so that we recover a solution function known to us. In particular, we choose the pressure solution </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} p = -\left(\frac \alpha 2 xy^2 + \beta x - \frac \alpha 6 x^3\right), \end{eqnarray*}" src="form_1712.png"/>
</p>
<p> and for the coefficient we choose the unit matrix <img class="formulaInl" alt="$K_{ij}=\delta_{ij}$" src="form_1713.png"/> for simplicity. Consequently, the exact velocity satisfies </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} {\mathbf u} = \left(\begin{array}{cc} \frac \alpha 2 y^2 + \beta - \frac \alpha 2 x^2 \\ \alpha xy \end{array}\right). \end{eqnarray*}" src="form_1714.png"/>
</p>
<p> This solution was chosen since it is exactly divergence free, making it a realistic test case for incompressible fluid flow. By consequence, the right hand side equals <img class="formulaInl" alt="$f=0$" src="form_1715.png"/>, and as boundary values we have to choose <img class="formulaInl" alt="$g=p|_{\partial\Omega}$" src="form_1716.png"/>.</p>
<p>For the computations in this program, we choose <img class="formulaInl" alt="$\alpha=0.3,\beta=1$" src="form_1717.png"/>. You can find the resulting solution in the <a class="anchor" id="#Results"></a>results section below, after the commented program. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Since this program is only an adaptation of <a class="el" href="step_4.html">step-4</a>, there is not much new stuff in terms of header files. In deal.II, we usually list include files in the order base-lac-grid-dofs-fe-numerics, followed by C++ standard include files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This is the only significant new header, namely the one in which the Raviart-Thomas finite element is declared:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_raviart_thomas.h&gt;</span></div></div><!-- fragment --><p>Finally, as a bonus in this program, we will use a tensorial coefficient. Since it may have a spatial dependence, we consider it a tensor-valued function. The following include file provides the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class that offers such functionality:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step20</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMixedLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>MixedLaplaceProblem</code> class template</h3>
<p>Again, since this is an adaptation of <a class="el" href="step_6.html">step-6</a>, the main class is almost the same as the one in that tutorial program. In terms of member functions, the main differences are that the constructor takes the degree of the Raviart-Thomas element as an argument (and that there is a corresponding member variable to store this value) and the addition of the <code>compute_error</code> function in which, no surprise, we will compute the difference between the exact and the numerical solution to determine convergence of our computations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MixedLaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MixedLaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> compute_errors () <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div></div><!-- fragment --><p>The second difference is that the sparsity pattern, the system matrix, and solution and right hand side vectors are now blocked. What this means and what one can do with such objects is explained in the introduction to this program as well as further down below when we explain the linear solvers and preconditioners for this problem:</p>
<div class="fragment"><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandexactsolution"></a> </p><h3>Right hand side, boundary values, and exact solution</h3>
<p>Our next task is to define the right hand side of our problem (i.e., the scalar right hand side for the pressure in the original Laplace equation), boundary values for the pressure, as well as a function that describes both the pressure and the velocity of the exact solution for later computations of the error. Note that these functions have one, one, and <code>dim+1</code> components, respectively, and that we pass the number of components down to the <code><a class="el" href="classFunction.html">Function</a>&lt;dim&gt;</code> base class. For the exact solution, we only declare the function that actually returns the entire solution vector (i.e. all components of it) at once. Here are the respective declarations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactSolution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>And then we also have to define these respective functions, of course. Given our discussion in the introduction of how the solution should look like, the following computations should be straightforward:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> PressureBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 0.3;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> beta = 1;</div><div class="line">  <span class="keywordflow">return</span> -(alpha*p[0]*p[1]*p[1]/2 + beta*p[0] - alpha*p[0]*p[0]*p[0]/6);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ExactSolution&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim+1,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim+1));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 0.3;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> beta = 1;</div><div class="line"></div><div class="line">  values(0) = alpha*p[1]*p[1]/2 + beta - alpha*p[0]*p[0]/2;</div><div class="line">  values(1) = alpha*p[0]*p[1];</div><div class="line">  values(2) = -(alpha*p[0]*p[1]*p[1]/2 + beta*p[0] - alpha*p[0]*p[0]*p[0]/6);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theinversepermeabilitytensor"></a> </p><h3>The inverse permeability tensor</h3>
<p>In addition to the other equation data, we also want to use a permeability tensor, or better &ndash; because this is all that appears in the weak form &ndash; the inverse of the permeability tensor, <code>KInverse</code>. For the purpose of verifying the exactness of the solution and determining convergence orders, this tensor is more in the way than helpful. We will therefore simply set it to the identity matrix.</p>
<p>However, a spatially varying permeability tensor is indispensable in real-life porous media flow simulations, and we would like to use the opportunity to demonstrate the technique to use tensor valued functions.</p>
<p>Possibly unsurprising, deal.II also has a base class not only for scalar and generally vector-valued functions (the <code><a class="el" href="classFunction.html">Function</a></code> base class) but also for functions that return tensors of fixed dimension and rank, the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> template. Here, the function under consideration returns a dim-by-dim matrix, i.e. a tensor of rank 2 and dimension <code>dim</code>. We then choose the template arguments of the base class appropriately.</p>
<p>The interface that the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class provides is essentially equivalent to the <code><a class="el" href="classFunction.html">Function</a></code> class. In particular, there exists a <code>value_list</code> function that takes a list of points at which to evaluate the function, and returns the values of the function in the second argument, a list of tensors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  KInverse () : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTensorFunction.html#a03a36987a917df2a65a2ad1873431fc9">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The implementation is less interesting. As in previous examples, we add a check to the beginning of the class to make sure that the sizes of input and output parameters are the same (see <a class="el" href="step_5.html">step-5</a> for a discussion of this technique). Then we loop over all evaluation points, and for each one first clear the output tensor and then set all its diagonal elements to one (i.e. fill the tensor with the identity matrix):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">    {</div><div class="line">      values[p].clear ();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        values[p][d][d] = 1.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplaceProblemclassimplementation"></a> </p><h3>MixedLaplaceProblem class implementation</h3>
<p><a class="anchor" id="MixedLaplaceProblemMixedLaplaceProblem"></a> </p><h4>MixedLaplaceProblem::MixedLaplaceProblem</h4>
<p>In the constructor of this class, we first store the value that was passed in concerning the degree of the finite elements we shall use (a degree of zero, for example, means to use RT(0) and DG(0)), and then construct the vector valued element belonging to the space <img class="formulaInl" alt="$X_h$" src="form_1718.png"/> described in the introduction. The rest of the constructor is as in the early tutorial programs.</p>
<p>The only thing worth describing here is the constructor call of the <code>fe</code> variable. The <code><a class="el" href="classFESystem.html">FESystem</a></code> class to which this variable belongs has a number of different constructors that all refer to binding simpler elements together into one larger element. In the present case, we want to couple a single RT(degree) element with a single DQ(degree) element. The constructor to <code><a class="el" href="classFESystem.html">FESystem</a></code> that does this requires us to specify first the first base element (the <code><a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a></code> object of given degree) and then the number of copies for this base element, and then similarly the kind and number of <code><a class="el" href="classFE__DGQ.html">FE_DGQ</a></code> elements. Note that the Raviart-Thomas element already has <code>dim</code> vector components, so that the coupled element will have <code>dim+1</code> vector components, the first <code>dim</code> of which correspond to the velocity variable whereas the last one corresponds to the pressure.</p>
<p>It is also worth comparing the way we constructed this element from its base elements, with the way we have done so in <a class="el" href="step_8.html">step-8</a>: there, we have built it as <code>fe (<a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim)</code>, i.e. we have simply used <code>dim</code> copies of the <code><a class="el" href="classFE__Q.html">FE_Q(1)</a></code> element, one copy for the displacement in each coordinate direction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MixedLaplaceProblem&lt;dim&gt;::MixedLaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  :</div><div class="line">  degree (degree),</div><div class="line">  fe (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree), 1,</div><div class="line">      <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplaceProblemmake_grid_and_dofs"></a> </p><h4>MixedLaplaceProblem::make_grid_and_dofs</h4>
<p>This next function starts out with well-known functions calls that create and refine a mesh, and then associate degrees of freedom with it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div></div><!-- fragment --><p>However, then things become different. As mentioned in the introduction, we want to subdivide the matrix into blocks corresponding to the two different kinds of variables, velocity and pressure. To this end, we first have to make sure that the indices corresponding to velocities and pressures are not intermingled: First all velocity degrees of freedom, then all pressure DoFs. This way, the global matrix separates nicely into a <img class="formulaInl" alt="$2 \times 2$" src="form_1719.png"/> system. To achieve this, we have to renumber degrees of freedom base on their vector component, an operation that conveniently is already implemented:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler);</div></div><!-- fragment --><p>The next thing is that we want to figure out the sizes of these blocks so that we can allocate an appropriate amount of space. To this end, we call the <a class="el" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component()</a> function that counts how many shape functions are non-zero for a particular vector component. We have <code>dim+1</code> vector components, and <a class="el" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component()</a> will count how many shape functions belong to each of these components.</p>
<p>There is one problem here. As described in the documentation of that function, it <em>wants</em> to put the number of <img class="formulaInl" alt="$x$" src="form_9.png"/>-velocity shape functions into <code>dofs_per_component[0]</code>, the number of <img class="formulaInl" alt="$y$" src="form_10.png"/>-velocity shape functions into <code>dofs_per_component[1]</code> (and similar in 3d), and the number of pressure shape functions into <code>dofs_per_component[dim]</code>. But, the Raviart-Thomas element is special in that it is non-<a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>, i.e., for Raviart-Thomas elements all velocity shape functions are nonzero in all components. In other words, the function cannot distinguish between <img class="formulaInl" alt="$x$" src="form_9.png"/> and <img class="formulaInl" alt="$y$" src="form_10.png"/> velocity functions because there <em>is</em> no such distinction. It therefore puts the overall number of velocity into each of <code>dofs_per_component[c]</code>, <img class="formulaInl" alt="$0\le c\le \text{dim}$" src="form_1720.png"/>. On the other hand, the number of pressure variables equals the number of shape functions that are nonzero in the dim-th component.</p>
<p>Using this knowledge, we can get the number of velocity shape functions from any of the first <code>dim</code> elements of <code>dofs_per_component</code>, and then use this below to initialize the vector and matrix block sizes, as well as create output.</p>
<dl class="section note"><dt>Note</dt><dd>If you find this concept difficult to understand, you may want to consider using the function <a class="el" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block()</a> instead, as we do in the corresponding piece of code in <a class="el" href="step_22.html">step-22</a>. You might also want to read up on the difference between <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> and <a class="el" href="DEALGlossary.html#GlossComponent">components</a> in the glossary.</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; dofs_per_component (dim+1);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a> (dof_handler, dofs_per_component);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                   n_p = dofs_per_component[dim];</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span></div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next task is to allocate a sparsity pattern for the matrix that we will create. We use a compressed sparsity pattern like in the previous steps, but as <code>system_matrix</code> is a block matrix we use the class <code><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></code> instead of just <code><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></code>. This block sparsity pattern has four blocks in a <img class="formulaInl" alt="$2 \times 2$" src="form_1719.png"/> pattern. The blocks' sizes depend on <code>n_u</code> and <code>n_p</code>, which hold the number of velocity and pressure variables. In the second step we have to instruct the block system to update its knowledge about the sizes of the blocks it manages; this happens with the <code>dsp.collect_sizes ()</code> call.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line">dsp.block(0, 0).reinit (n_u, n_u);</div><div class="line">dsp.block(1, 0).reinit (n_p, n_u);</div><div class="line">dsp.block(0, 1).reinit (n_u, n_p);</div><div class="line">dsp.block(1, 1).reinit (n_p, n_p);</div><div class="line">dsp.collect_sizes ();</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div></div><!-- fragment --><p>We use the compressed block sparsity pattern in the same way as the non-block version to create the sparsity pattern and then the system matrix:</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">system_matrix.reinit (sparsity_pattern);</div></div><!-- fragment --><p>Then we have to resize the solution and right hand side vectors in exactly the same way as the block compressed sparsity pattern:</p>
<div class="fragment"><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (2);</div><div class="line">  solution.block(0).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_u);</div><div class="line">  solution.block(1).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_p);</div><div class="line">  solution.collect_sizes ();</div><div class="line"></div><div class="line">  system_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (2);</div><div class="line">  system_rhs.block(0).reinit (n_u);</div><div class="line">  system_rhs.block(1).reinit (n_p);</div><div class="line">  system_rhs.collect_sizes ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplaceProblemassemble_system"></a> </p><h4>MixedLaplaceProblem::assemble_system</h4>
<p>Similarly, the function that assembles the linear system has mostly been discussed already in the introduction to this example. At its top, what happens are all the usual steps, with the addition that we do not only allocate quadrature and <code><a class="el" href="classFEValues.html">FEValues</a></code> objects for the cell terms, but also for face terms. After that, we define the usual abbreviations for variables, and the allocate space for the local matrix and right hand side contributions, and the array that holds the global numbers of the degrees of freedom local to the present cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>The next step is to declare objects that represent the source term, pressure boundary value, and coefficient in the equation. In addition to these objects that represent continuous functions, we also need arrays to hold their values at the quadrature points of individual cells (or faces, for the boundary values). Note that in the case of the coefficient, the array has to be one of matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt;          right_hand_side;</div><div class="line"><span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line"><span class="keyword">const</span> KInverse&lt;dim&gt;               k_inverse;</div><div class="line"></div><div class="line">std::vector&lt;double&gt; rhs_values (n_q_points);</div><div class="line">std::vector&lt;double&gt; boundary_values (n_face_q_points);</div><div class="line">std::vector&lt;Tensor&lt;2,dim&gt; &gt; k_inverse_values (n_q_points);</div></div><!-- fragment --><p>Finally, we need a couple of extractors that we will use to get at the velocity and pressure components of vector-valued shape functions. Their function and use is described in detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> report. Essentially, we will use them as subscripts on the <a class="el" href="classFEValues.html">FEValues</a> objects below: the <a class="el" href="classFEValues.html">FEValues</a> object describes all vector components of shape functions, while after subscription, it will only refer to the velocities (a set of <code>dim</code> components starting at component zero) or the pressure (a scalar component located at position <code>dim</code>):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div></div><!-- fragment --><p>With all this in place, we can go on with the loop over all cells. The body of this loop has been discussed in the introduction, and will not be commented any further here:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                rhs_values);</div><div class="line">    k_inverse.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                          k_inverse_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_i_u     = fe_values[velocities].value (i, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_i_u = fe_values[velocities].divergence (i, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_p     = fe_values[pressure].value (i, q);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_j_u     = fe_values[velocities].value (j, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_j_u = fe_values[velocities].divergence (j, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_p     = fe_values[pressure].value (j, q);</div><div class="line"></div><div class="line">              local_matrix(i,j) += (phi_i_u * k_inverse_values[q] * phi_j_u</div><div class="line">                                    - div_phi_i_u * phi_j_p</div><div class="line">                                    - phi_i_p * div_phi_j_u)</div><div class="line">                                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">          local_rhs(i) += -phi_i_p *</div><div class="line">                          rhs_values[q] *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_n=0;</div><div class="line">         face_n&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">         ++face_n)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_n))</div><div class="line">        {</div><div class="line">          fe_face_values.reinit (cell, face_n);</div><div class="line"></div><div class="line">          pressure_boundary_values</div><div class="line">          .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                       boundary_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) += -(fe_face_values[velocities].value (i, q) *</div><div class="line">                                fe_face_values.normal_vector(q) *</div><div class="line">                                boundary_values[q] *</div><div class="line">                                fe_face_values.JxW(q));</div><div class="line">        }</div></div><!-- fragment --><p>The final step in the loop over all cells is to transfer local contributions into the global matrix and right hand side vector. Note that we use exactly the same interface as in previous examples, although we now use block matrices and vectors instead of the regular ones. In other words, to the outside world, block objects have the same interface as matrices and vectors, but they additionally allow to access individual blocks.</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add (local_dof_indices[i],</div><div class="line">                             local_dof_indices[j],</div><div class="line">                             local_matrix(i,j));</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers and preconditioners we use in this example have been discussed in significant detail already in the introduction. We will therefore not discuss the rationale for these classes here any more, but rather only comment on implementational aspects.</p>
<p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>There are a few places in this program where we will need either the action of the inverse of the mass matrix or the action of the inverse of the approximate Schur complement. Rather than explicitly calling <a class="el" href="classSolverCG.html#aca3e6e9a7166802be109415e45203889">SolverCG::solve</a> every time that we need to solve such a system, we will wrap the action of either inverse in a simple class. The only things we would like to note are that this class is derived from <code><a class="el" href="classSubscriptor.html">Subscriptor</a></code> and, as mentioned above, it stores a pointer to the underlying matrix with a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> object. This class also appears in <a class="el" href="step_21.html">step-21</a> and a more advanced version of it appears in <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> matrix;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">InverseMatrix&lt;MatrixType&gt;::InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">  :</div><div class="line">  matrix (&amp;m)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>To make the control flow simpler, we recreate both the <a class="el" href="classReductionControl.html">ReductionControl</a> and <a class="el" href="classSolverCG.html">SolverCG</a> objects every time this is called. This is not the most efficient choice because <a class="el" href="classSolverCG.html">SolverCG</a> instances allocate memory whenever they are created; this is just a tutorial so such inefficiencies are acceptable for the sake of exposition.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (std::max(src.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (200)),</div><div class="line">                                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  cg.solve (*matrix, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSchurComplementcodeclass"></a> </p><h4>The <code>SchurComplement</code> class</h4>
<p>The next class is the Schur complement class. Its rationale has also been discussed in length in the introduction. Like <code>InverseMatrix</code>, this class is derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> and stores <a class="el" href="classSmartPointer.html">SmartPointer</a>&#160;s pointing to the system matrix and <code>InverseMatrix</code> wrapper.</p>
<p>The <code>vmult</code> function requires two temporary vectors that we do not want to re-allocate and free every time we call this function. Since here, we have full control over the use of these vectors (unlike above, where a class called by the <code>vmult</code> function required these vectors, not the <code>vmult</code> function itself), we allocate them directly, rather than going through the <code><a class="el" href="classVectorMemory.html">VectorMemory</a></code> mechanism. However, again, these member variables do not carry any state between successive calls to the member functions of this class (i.e., we never care what values they were set to the last time a member function was called), we mark these vectors as <code>mutable</code>.</p>
<p>The rest of the (short) implementation of this class is straightforward if you know the order of matrix-vector multiplications performed by the <code>vmult</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;A,</div><div class="line">                   <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a> &gt; &gt; m_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">SchurComplement</div><div class="line">::SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;A,</div><div class="line">                   <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv)</div><div class="line">  :</div><div class="line">  system_matrix (&amp;A),</div><div class="line">  m_inverse (&amp;Minv),</div><div class="line">  tmp1 (A.block(0,0).m()),</div><div class="line">  tmp2 (A.block(0,0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> SchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">  m_inverse-&gt;vmult (tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeApproximateSchurComplementcodeclass"></a> </p><h4>The <code>ApproximateSchurComplement</code> class</h4>
<p>The third component of our solver and preconditioner system is the class that approximates the Schur complement with the method described in the introduction. We will use this class to build a preconditioner for our system matrix.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">ApproximateSchurComplement::ApproximateSchurComplement</div><div class="line">(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A) :</div><div class="line">  system_matrix (&amp;A),</div><div class="line">  tmp1 (A.block(0,0).m()),</div><div class="line">  tmp2 (A.block(0,0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ApproximateSchurComplement::vmult</div><div class="line">(<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line"> <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">  system_matrix-&gt;block(0,0).precondition_Jacobi (tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplacesolve"></a> </p><h4>MixedLaplace::solve</h4>
<p>After all these preparations, we can finally write the function that actually solves the linear problem. We will go through the two parts it has that each solve one of the two equations, the first one for the pressure (component 1 of the solution), then the velocities (component 0 of the solution).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  InverseMatrix&lt;SparseMatrix&lt;double&gt; &gt; inverse_mass (system_matrix.block(0,0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div></div><!-- fragment --><p>Now on to the first equation. The right hand side of it is <img class="formulaInl" alt="$B^TM^{-1}F-G$" src="form_1706.png"/>, which is what we compute in the first few lines:</p>
<div class="fragment"><div class="line">{</div><div class="line">  SchurComplement <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (system_matrix, inverse_mass);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">  inverse_mass.vmult (tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div></div><!-- fragment --><p>Now that we have the right hand side we can go ahead and solve for the pressure, using our approximation of the inverse as a preconditioner:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div><div class="line"></div><div class="line">  ApproximateSchurComplement approximate_schur (system_matrix);</div><div class="line">  InverseMatrix&lt;ApproximateSchurComplement&gt; approximate_inverse</div><div class="line">  (approximate_schur);</div><div class="line">  cg.solve (<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs,</div><div class="line">            approximate_inverse);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations to obtain convergence.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>After we have the pressure, we can compute the velocity. The equation reads <img class="formulaInl" alt="$MU=-BP+F$" src="form_1721.png"/>, and we solve it by first computing the right hand side, and then multiplying it with the object that represents the inverse of the mass matrix:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    system_matrix.block(0,1).vmult (tmp, solution.block(1));</div><div class="line">    tmp *= -1;</div><div class="line">    tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">    inverse_mass.vmult (solution.block(0), tmp);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplaceProblemclassimplementationcontinued"></a> </p><h3>MixedLaplaceProblem class implementation (continued)</h3>
<p><a class="anchor" id="MixedLaplacecompute_errors"></a> </p><h4>MixedLaplace::compute_errors</h4>
<p>After we have dealt with the linear solver and preconditioners, we continue with the implementation of our main class. In particular, the next task is to compute the errors in our numerical solution, in both the pressures as well as velocities.</p>
<p>To compute errors in the solution, we have already introduced the <code><a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a></code> function in <a class="el" href="step_7.html">step-7</a> and <a class="el" href="step_11.html">step-11</a>. However, there we only dealt with scalar solutions, whereas here we have a vector-valued solution with components that even denote different quantities and may have different orders of convergence (this isn't the case here, by choice of the used finite elements, but is frequently the case in mixed finite element applications). What we therefore have to do is to `mask' the components that we are interested in. This is easily done: the <code><a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a></code> function takes as one of its arguments a pointer to a weight function (the parameter defaults to the null pointer, meaning unit weights). What we have to do is to pass a function object that equals one in the components we are interested in, and zero in the other ones. For example, to compute the pressure error, we should pass a function that represents the constant vector with a unit value in component <code>dim</code>, whereas for the velocity the constant vector should be one in the first <code>dim</code> components, and zero in the location of the pressure.</p>
<p>In deal.II, the <code><a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a></code> does exactly this: it wants to know how many vector components the function it is to represent should have (in our case this would be <code>dim+1</code>, for the joint velocity-pressure space) and which individual or range of components should be equal to one. We therefore define two such masks at the beginning of the function, following by an object representing the exact solution and a vector in which we will store the cellwise errors as computed by <code>integrate_difference</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::compute_errors ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">  pressure_mask (dim, dim+1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">  velocity_mask(std::make_pair(0, dim), dim+1);</div><div class="line"></div><div class="line">  ExactSolution&lt;dim&gt; exact_solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cellwise_errors (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>As already discussed in <a class="el" href="step_7.html">step-7</a>, we have to realize that it is impossible to integrate the errors exactly. All we can do is approximate this integral using quadrature. This actually presents a slight twist here: if we naively chose an object of type <code><a class="el" href="classQGauss.html">QGauss</a>&lt;dim&gt;(degree+1)</code> as one may be inclined to do (this is what we used for integrating the linear system), one realizes that the error is very small and does not follow the expected convergence curves at all. What is happening is that for the mixed finite elements used here, the Gauss points happen to be superconvergence points in which the pointwise error is much smaller (and converges with higher order) than anywhere else. These are therefore not particularly good points for integration. To avoid this problem, we simply use a trapezoidal rule and iterate it <code>degree+2</code> times in each coordinate direction (again as explained in <a class="el" href="step_7.html">step-7</a>):</p>
<div class="fragment"><div class="line"><a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>     q_trapez;</div><div class="line"><a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature (q_trapez, degree+2);</div></div><!-- fragment --><p>With this, we can then let the library compute the errors and output them to the screen:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler, solution, exact_solution,</div><div class="line">                                     cellwise_errors, quadrature,</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                     &amp;pressure_mask);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> p_l2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              cellwise_errors,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler, solution, exact_solution,</div><div class="line">                                     cellwise_errors, quadrature,</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                     &amp;velocity_mask);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u_l2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              cellwise_errors,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Errors: ||e_p||_L2 = &quot;</span> &lt;&lt; p_l2_error</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;,   ||e_u||_L2 = &quot;</span> &lt;&lt; u_l2_error</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplaceoutput_results"></a> </p><h4>MixedLaplace::output_results</h4>
<p>The last interesting function is the one in which we generate graphical output. Note that all velocity components get the same solution name "u". Together with using <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a>::::component_is_part_of_vector this will cause <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOut&lt;dim&gt;::write_vtu()</a> to generate a vector representation of the individual velocity components, see <a class="el" href="step_22.html">step-22</a> or the <a class="el" href="group__vector__valued.html#VVOutput">Generating graphical output</a> section of the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module for more information. Finally, it seems inappropriate for higher order elements to only show a single bilinear quadrilateral per cell in the graphical output. We therefore generate patches of size (degree+1)x(degree+1) to capture the full information content of the solution. See the <a class="el" href="step_7.html">step-7</a> tutorial program for more information on this.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  interpretation (dim,</div><div class="line">                  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (dof_handler, solution, solution_names, interpretation);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (degree+1);</div><div class="line"></div><div class="line">  std::ofstream output (<span class="stringliteral">&quot;solution.vtu&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="MixedLaplacerun"></a> </p><h4>MixedLaplace::run</h4>
<p>This is the final function of our main class. It's only job is to call the other functions in their natural order:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system ();</div><div class="line">    solve ();</div><div class="line">    compute_errors ();</div><div class="line">    output_results ();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function we stole from <a class="el" href="step_6.html">step-6</a> instead of <a class="el" href="step_4.html">step-4</a>. It is almost equal to the one in <a class="el" href="step_6.html">step-6</a> (apart from the changed class names, of course), the only exception is that we pass the degree of the finite element space to the constructor of the mixed Laplace problem (here, we use zero-th order elements).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step20;</div><div class="line"></div><div class="line">      MixedLaplaceProblem&lt;2&gt; mixed_laplace_problem(0);</div><div class="line">      mixed_laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Outputoftheprogramandgraphicalvisualization"></a></p><h3>Output of the program and graphical visualization</h3>
<p>If we run the program as is, we get this output for the <img class="formulaInl" alt="$8\times 8$" src="form_1722.png"/> mesh we use (for a total of 64 cells with 64 pressure degrees of freedom since we use piecewise constants, and 144 velocities because the Raviart-Thomas element defines one degree per freedom per face and there are 72 faces parallel to the <img class="formulaInl" alt="$x$" src="form_9.png"/>-axis and the same number parallel to the <img class="formulaInl" alt="$y$" src="form_10.png"/>-axis): </p><pre class="fragment">$ make run
[ 66%] Built target step-20
Scanning dependencies of target run
[100%] Run step-20 with Release configuration
Number of active cells: 64
Total number of cells: 85
Number of degrees of freedom: 208 (144+64)
15 CG Schur complement iterations to obtain convergence.
Errors: ||e_p||_L2 = 0.178055,   ||e_u||_L2 = 0.0433435
[100%] Built target run
</pre><p>The fact that the number of iterations is so small, of course, is due to good (but expensive!) preconditioner we have developed. To get confidence in the solution, let us take a look at it. The following three images show (from left to right) the x-velocity, the y-velocity, and the pressure:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.u.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.v.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.p.png"/>
</div>
<p>Let us start with the pressure: it is highest at the left and lowest at the right, so flow will be from left to right. In addition, though hardly visible in the graph, we have chosen the pressure field such that the flow left-right flow first channels towards the center and then outward again. Consequently, the x-velocity has to increase to get the flow through the narrow part, something that can easily be seen in the left image. The middle image represents inward flow in y-direction at the left end of the domain, and outward flow in y-direction at the right end of the domain.</p>
<p>As an additional remark, note how the x-velocity in the left image is only continuous in x-direction, whereas the y-velocity is continuous in y-direction. The flow fields are discontinuous in the other directions. This very obviously reflects the continuity properties of the Raviart-Thomas elements, which are, in fact, only in the space H(div) and not in the space <img class="formulaInl" alt="$H^1$" src="form_38.png"/>. Finally, the pressure field is completely discontinuous, but that should not surprise given that we have chosen <code><a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a></code> as the finite element for that solution component.</p>
<p><a class="anchor" id="Convergence"></a></p><h3>Convergence</h3>
<p>The program offers two obvious places where playing and observing convergence is in order: the degree of the finite elements used (passed to the constructor of the <code>MixedLaplaceProblem</code> class from <code>main()</code>), and the refinement level (determined in <code>MixedLaplaceProblem::make_grid_and_dofs</code>). What one can do is to change these values and observe the errors computed later on in the course of the program run.</p>
<p>If one does this, one finds the following pattern for the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error in the pressure variable: </p><table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td></td><td colspan="3" align="center"><p class="starttd">Finite element order </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Refinement level </td><td>0 </td><td>1 </td><td><p class="starttd">2 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>0 </td><td>1.45344 </td><td>0.0831743 </td><td><p class="starttd">0.0235186 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1 </td><td>0.715099 </td><td>0.0245341 </td><td><p class="starttd">0.00293983 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>2 </td><td>0.356383 </td><td>0.0063458 </td><td><p class="starttd">0.000367478 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>3 </td><td>0.178055 </td><td>0.00159944 </td><td><p class="starttd">4.59349e-05 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>4 </td><td>0.0890105 </td><td>0.000400669 </td><td><p class="starttd">5.74184e-06 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5 </td><td>0.0445032 </td><td>0.000100218 </td><td><p class="starttd">7.17799e-07 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>6 </td><td>0.0222513 </td><td>2.50576e-05 </td><td><p class="starttd">9.0164e-08 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td></td><td><img class="formulaInl" alt="$O(h)$" src="form_1723.png"/> </td><td><img class="formulaInl" alt="$O(h^2)$" src="form_1724.png"/> </td><td><img class="formulaInl" alt="$O(h^3)$" src="form_1725.png"/>  </td></tr>
</table>
<p>The theoretically expected convergence orders are very nicely reflected by the experimentally observed ones indicated in the last row of the table.</p>
<p>One can make the same experiment with the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error in the velocity variables: </p><table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td></td><td colspan="3" align="center"><p class="starttd">Finite element order </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Refinement level </td><td>0 </td><td>1 </td><td><p class="starttd">2 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>0 </td><td>0.367423 </td><td>0.127657 </td><td><p class="starttd">5.10388e-14 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1 </td><td>0.175891 </td><td>0.0319142 </td><td><p class="starttd">9.04414e-15 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>2 </td><td>0.0869402 </td><td>0.00797856 </td><td><p class="starttd">1.23723e-14 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>3 </td><td>0.0433435 </td><td>0.00199464 </td><td><p class="starttd">1.86345e-07 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>4 </td><td>0.0216559 </td><td>0.00049866 </td><td><p class="starttd">2.72566e-07 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5 </td><td>0.010826 </td><td>0.000124664 </td><td><p class="starttd">3.57141e-07 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>6 </td><td>0.00541274 </td><td>3.1166e-05 </td><td><p class="starttd">4.46124e-07 </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td></td><td><img class="formulaInl" alt="$O(h)$" src="form_1723.png"/> </td><td><img class="formulaInl" alt="$O(h^2)$" src="form_1724.png"/> </td><td><img class="formulaInl" alt="$O(h^3)$" src="form_1725.png"/>  </td></tr>
</table>
<p>The result concerning the convergence order is the same here.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Morerealisticpermeabilityfields"></a></p><h4>More realistic permeability fields</h4>
<p>Realistic flow computations for ground water or oil reservoir simulations will not use a constant permeability. Here's a first, rather simple way to change this situation: we use a permeability that decays very rapidly away from a central flowline until it hits a background value of 0.001. This is to mimic the behavior of fluids in sandstone: in most of the domain, the sandstone is homogeneous and, while permeable to fluids, not overly so; on the other stone, the stone has cracked, or faulted, along one line, and the fluids flow much easier along this large crack. Here is how we could implement something like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">    {</div><div class="line">      values[p].clear ();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline</div><div class="line">        = std::fabs(points[p][1]-0.2*std::sin(10*points[p][0]));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> permeability = std::max(std::exp(-(distance_to_flowline*</div><div class="line">                                                      distance_to_flowline)</div><div class="line">                                                    / (0.1 * 0.1)),</div><div class="line">                                           0.001);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        values[p][d][d] = 1./permeability;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Remember that the function returns the inverse of the permeability tensor.</p>
<p>With a significantly higher mesh resolution, we can visualize this, here with x- and y-velocity:</p>
<table style="width:60%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.u-wiggle.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.v-wiggle.png"/>
</div>
  </td></tr>
</table>
<p>It is obvious how fluids flow essentially only along the middle line, and not anywhere else.</p>
<p>Another possibility would be to use a random permeability field. A simple way to achieve this would be to scatter a number of centers around the domain and then use a permeability field that is the sum of (negative) exponentials for each of these centers. Flow would then try to hop from one center of high permeability to the next one. This is an entirely unscientific attempt at describing a random medium, but one possibility to implement this behavior would look like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse ();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTensorFunction.html#a03a36987a917df2a65a2ad1873431fc9">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; centers;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">KInverse&lt;dim&gt;::KInverse ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = 40;</div><div class="line">  centers.resize (N);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;N; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      centers[i][d] = 2.*rand()/RAND_MAX-1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">    {</div><div class="line">      values[p].clear ();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> permeability = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;centers.size(); ++i)</div><div class="line">        permeability += std::exp(-(points[p]-centers[i]).square()</div><div class="line">                                 / (0.1 * 0.1));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability</div><div class="line">        = std::max(permeability, 0.005);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        values[p][d][d] = 1./normalized_permeability;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>A piecewise constant interpolation of the diagonal elements of the inverse of this tensor (i.e., of <code>normalized_permeability</code>) looks as follows:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.k-random.png"/>
</div>
<p>With a permeability field like this, we would get x-velocities and pressures as follows:</p>
<table style="width:60%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.u-random.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-20.p-random.png"/>
</div>
  </td></tr>
</table>
<p>We will use these permeability fields again in <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_43.html">step-43</a>.</p>
<p><a class="anchor" id="Betterlinearsolvers"></a></p><h4>Better linear solvers</h4>
<p>As mentioned in the introduction, the Schur complement solver used here is not the best one conceivable (nor is it intended to be a particularly good one). Better ones can be found in the literature and can be built using the same block matrix techniques that were introduced here. We pick up on this theme again in <a class="el" href="step_22.html">step-22</a>, where we first build a Schur complement solver for the Stokes equation as we did here, and then in the <a href="step_22.html#improved-solver">Improved Solvers</a> section discuss better ways based on solving the system as a whole but preconditioning based on individual blocks. We will also come back to this in <a class="el" href="step_43.html">step-43</a>. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2005 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2005, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_raviart_thomas.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step20</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MixedLaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MixedLaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> compute_errors () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactSolution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> PressureBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 0.3;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta = 1;</div><div class="line">    <span class="keywordflow">return</span> -(alpha*p[0]*p[1]*p[1]/2 + beta*p[0] - alpha*p[0]*p[0]*p[0]/6);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  ExactSolution&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim+1,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim+1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 0.3;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta = 1;</div><div class="line"></div><div class="line">    values(0) = alpha*p[1]*p[1]/2 + beta - alpha*p[0]*p[0]/2;</div><div class="line">    values(1) = alpha*p[0]*p[1];</div><div class="line">    values(2) = -(alpha*p[0]*p[1]*p[1]/2 + beta*p[0] - alpha*p[0]*p[0]*p[0]/6);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse () : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear ();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MixedLaplaceProblem&lt;dim&gt;::MixedLaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    :</div><div class="line">    degree (degree),</div><div class="line">    fe (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree), 1,</div><div class="line">        <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">    dof_handler (triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs_per_component (dim+1);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a> (dof_handler, dofs_per_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                       n_p = dofs_per_component[dim];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line">    dsp.block(0, 0).reinit (n_u, n_u);</div><div class="line">    dsp.block(1, 0).reinit (n_p, n_u);</div><div class="line">    dsp.block(0, 1).reinit (n_u, n_p);</div><div class="line">    dsp.block(1, 1).reinit (n_p, n_p);</div><div class="line">    dsp.collect_sizes ();</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (2);</div><div class="line">    solution.block(0).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_u);</div><div class="line">    solution.block(1).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_p);</div><div class="line">    solution.collect_sizes ();</div><div class="line"></div><div class="line">    system_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (2);</div><div class="line">    system_rhs.block(0).reinit (n_u);</div><div class="line">    system_rhs.block(1).reinit (n_p);</div><div class="line">    system_rhs.collect_sizes ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;          right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">    <span class="keyword">const</span> KInverse&lt;dim&gt;               k_inverse;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; rhs_values (n_q_points);</div><div class="line">    std::vector&lt;double&gt; boundary_values (n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2,dim&gt; &gt; k_inverse_values (n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs = 0;</div><div class="line"></div><div class="line">        right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    rhs_values);</div><div class="line">        k_inverse.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_i_u     = fe_values[velocities].value (i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_i_u = fe_values[velocities].divergence (i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_p     = fe_values[pressure].value (i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_j_u     = fe_values[velocities].value (j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_j_u = fe_values[velocities].divergence (j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_p     = fe_values[pressure].value (j, q);</div><div class="line"></div><div class="line">                  local_matrix(i,j) += (phi_i_u * k_inverse_values[q] * phi_j_u</div><div class="line">                                        - div_phi_i_u * phi_j_p</div><div class="line">                                        - phi_i_p * div_phi_j_u)</div><div class="line">                                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) += -phi_i_p *</div><div class="line">                              rhs_values[q] *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_n=0;</div><div class="line">             face_n&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_n)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_n))</div><div class="line">            {</div><div class="line">              fe_face_values.reinit (cell, face_n);</div><div class="line"></div><div class="line">              pressure_boundary_values</div><div class="line">              .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                           boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                  local_rhs(i) += -(fe_face_values[velocities].value (i, q) *</div><div class="line">                                    fe_face_values.normal_vector(q) *</div><div class="line">                                    boundary_values[q] *</div><div class="line">                                    fe_face_values.JxW(q));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add (local_dof_indices[i],</div><div class="line">                               local_dof_indices[j],</div><div class="line">                               local_matrix(i,j));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;m);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> matrix;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType&gt;::InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">    :</div><div class="line">    matrix (&amp;m)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (std::max(src.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (200)),</div><div class="line">                                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve (*matrix, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;A,</div><div class="line">                     <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a> &gt; &gt; m_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  SchurComplement</div><div class="line">  ::SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;A,</div><div class="line">                     <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv)</div><div class="line">    :</div><div class="line">    system_matrix (&amp;A),</div><div class="line">    m_inverse (&amp;Minv),</div><div class="line">    tmp1 (A.block(0,0).m()),</div><div class="line">    tmp2 (A.block(0,0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> SchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">    m_inverse-&gt;vmult (tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  ApproximateSchurComplement::ApproximateSchurComplement</div><div class="line">  (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A) :</div><div class="line">    system_matrix (&amp;A),</div><div class="line">    tmp1 (A.block(0,0).m()),</div><div class="line">    tmp2 (A.block(0,0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  ApproximateSchurComplement::vmult</div><div class="line">  (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">    system_matrix-&gt;block(0,0).precondition_Jacobi (tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    InverseMatrix&lt;SparseMatrix&lt;double&gt; &gt; inverse_mass (system_matrix.block(0,0));</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line"></div><div class="line">    {</div><div class="line">      SchurComplement schur_complement (system_matrix, inverse_mass);</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">      inverse_mass.vmult (tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                                    1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control);</div><div class="line"></div><div class="line">      ApproximateSchurComplement approximate_schur (system_matrix);</div><div class="line">      InverseMatrix&lt;ApproximateSchurComplement&gt; approximate_inverse</div><div class="line">      (approximate_schur);</div><div class="line">      cg.solve (schur_complement, solution.block(1), schur_rhs,</div><div class="line">                approximate_inverse);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations to obtain convergence.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0,1).vmult (tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      inverse_mass.vmult (solution.block(0), tmp);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::compute_errors ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">    pressure_mask (dim, dim+1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">    velocity_mask(std::make_pair(0, dim), dim+1);</div><div class="line"></div><div class="line">    ExactSolution&lt;dim&gt; exact_solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cellwise_errors (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>     q_trapez;</div><div class="line">    <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature (q_trapez, degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler, solution, exact_solution,</div><div class="line">                                       cellwise_errors, quadrature,</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                       &amp;pressure_mask);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p_l2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                                cellwise_errors,</div><div class="line">                                                                <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler, solution, exact_solution,</div><div class="line">                                       cellwise_errors, quadrature,</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                       &amp;velocity_mask);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> u_l2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                                cellwise_errors,</div><div class="line">                                                                <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Errors: ||e_p||_L2 = &quot;</span> &lt;&lt; p_l2_error</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;,   ||e_u||_L2 = &quot;</span> &lt;&lt; u_l2_error</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    interpretation (dim,</div><div class="line">                    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (dof_handler, solution, solution_names, interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (degree+1);</div><div class="line"></div><div class="line">    std::ofstream output (<span class="stringliteral">&quot;solution.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MixedLaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line">    assemble_system ();</div><div class="line">    solve ();</div><div class="line">    compute_errors ();</div><div class="line">    output_results ();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step20;</div><div class="line"></div><div class="line">      MixedLaplaceProblem&lt;2&gt; mixed_laplace_problem(0);</div><div class="line">      mixed_laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
