<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-18 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-18 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Quasistaticelasticdeformation">Quasistatic elastic deformation</a>
      <ul>
        <li><a href="#Motivationofthemodel">Motivation of the model</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Updatingthestressvariable">Updating the stress variable</a>
      </ul>
        <li><a href="#Parallelgraphicaloutput">Parallel graphical output</a>
        <li><a href="#Atriangulationwithautomaticpartitioning">A triangulation with automatic partitioning</a>
        <li><a href="#Overallstructureoftheprogram">Overall structure of the program</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#ThecodePointHistorycodeclass">The <code>PointHistory</code> class</a>
        <li><a href="#Thestressstraintensor">The stress-strain tensor</a>
        <li><a href="#Auxiliaryfunctions">Auxiliary functions</a>
        <li><a href="#ThecodeTopLevelcodeclass">The <code>TopLevel</code> class</a>
        <li><a href="#ThecodeBodyForcecodeclass">The <code>BodyForce</code> class</a>
        <li><a href="#ThecodeIncrementalBoundaryValuecodeclass">The <code>IncrementalBoundaryValue</code> class</a>
        <li><a href="#ImplementationofthecodeTopLevelcodeclass">Implementation of the <code>TopLevel</code> class</a>
      <ul>
        <li><a href="#Thepublicinterface">The public interface</a>
        <li><a href="#TopLevelcreate_coarse_grid">TopLevel::create_coarse_grid</a>
        <li><a href="#TopLevelsetup_system">TopLevel::setup_system</a>
        <li><a href="#TopLevelassemble_system">TopLevel::assemble_system</a>
        <li><a href="#TopLevelsolve_timestep">TopLevel::solve_timestep</a>
        <li><a href="#TopLevelsolve_linear_problem">TopLevel::solve_linear_problem</a>
        <li><a href="#TopLeveloutput_results">TopLevel::output_results</a>
        <li><a href="#TopLeveldo_initial_timestep">TopLevel::do_initial_timestep</a>
        <li><a href="#TopLeveldo_timestep">TopLevel::do_timestep</a>
        <li><a href="#TopLevelrefine_initial_grid">TopLevel::refine_initial_grid</a>
        <li><a href="#TopLevelmove_mesh">TopLevel::move_mesh</a>
        <li><a href="#TopLevelsetup_quadrature_point_history">TopLevel::setup_quadrature_point_history</a>
        <li><a href="#TopLevelupdate_quadrature_point_history">TopLevel::update_quadrature_point_history</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibledirectionsforextensions">Possible directions for extensions</a>
      <ul>
      <ul>
        <li><a href="#Plasticitymodels">Plasticity models</a>
        <li><a href="#Stabilizationissues">Stabilization issues</a>
        <li><a href="#Refinementduringtimesteps">Refinement during timesteps</a>
        <li><a href="#Ensuringmeshregularity">Ensuring mesh regularity</a>
    </ul>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program is another one in the series on the elasticity problem that we have already started with <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a>. It extends it into two different directions: first, it solves the quasistatic but time dependent elasticity problem for large deformations with a Lagrangian mesh movement approach. Secondly, it shows some more techniques for solving such problems using parallel processing with PETSc's linear algebra. In addition to this, we show how to work around one of the two major bottlenecks of <a class="el" href="step_17.html">step-17</a>, namely that we generated graphical output from only one process, and that this scaled very badly with larger numbers of processes and on large problems. (The other bottleneck, namely that every processor has to hold the entire mesh and <a class="el" href="classDoFHandler.html">DoFHandler</a>, is addressed in <a class="el" href="step_40.html">step-40</a>.) Finally, a good number of assorted improvements and techniques are demonstrated that have not been shown yet in previous programs.</p>
<p>As before in <a class="el" href="step_17.html">step-17</a>, the program runs just as fine on a single sequential machine as long as you have PETSc installed. Information on how to tell deal.II about a PETSc installation on your system can be found in the deal.II README file, which is linked to from the <a href="../../index.html">main documentation page</a> in your installation of deal.II, or on <a href="http://www.dealii.org/">the deal.II webpage</a>.</p>
<p><a class="anchor" id="Quasistaticelasticdeformation"></a></p><h3>Quasistatic elastic deformation</h3>
<p><a class="anchor" id="Motivationofthemodel"></a></p><h4>Motivation of the model</h4>
<p>In general, time-dependent small elastic deformations are described by the elastic wave equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho \frac{\partial^2 \mathbf{u}}{\partial t^2} + c \frac{\partial \mathbf{u}}{\partial t} - \textrm{div}\ ( C \varepsilon(\mathbf{u})) = \mathbf{f} \qquad \textrm{in}\ \Omega, \]" src="form_1589.png"/>
</p>
<p> where <img class="formulaInl" alt="$\mathbf{u}=\mathbf{u} (\mathbf{x},t)$" src="form_1590.png"/> is the deformation of the body, <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> and <img class="formulaInl" alt="$c$" src="form_257.png"/> the density and attenuation coefficient, and <img class="formulaInl" alt="$\mathbf{f}$" src="form_1592.png"/> external forces. In addition, initial conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{u}(\cdot, 0) = \mathbf{u}_0(\cdot) \qquad \textrm{on}\ \Omega, \]" src="form_1593.png"/>
</p>
<p> and Dirichlet (displacement) or Neumann (traction) boundary conditions need to be specified for a unique solution: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mathbf{u}(\mathbf{x},t) &amp;=&amp; \mathbf{d}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_D\subset\partial\Omega, \\ \mathbf{n} \ C \varepsilon(\mathbf{u}(\mathbf{x},t)) &amp;=&amp; \mathbf{b}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_N=\partial\Omega\backslash\Gamma_D. \end{eqnarray*}" src="form_1594.png"/>
</p>
<p> In above formulation, <img class="formulaInl" alt="$\varepsilon(\mathbf{u})= \frac 12 (\nabla \mathbf{u} + \nabla \mathbf{u}^T)$" src="form_1595.png"/> is the symmetric gradient of the displacement, also called the <em>strain</em>. <img class="formulaInl" alt="$C$" src="form_43.png"/> is a tensor of rank 4, called the <em>stress-strain tensor</em> that contains knowledge of the elastic strength of the material; its symmetry properties make sure that it maps symmetric tensors of rank 2 (&ldquo;matrices&rdquo; of dimension <img class="formulaInl" alt="$d$" src="form_301.png"/>, where <img class="formulaInl" alt="$d$" src="form_301.png"/> is the spatial dimensionality) onto symmetric tensors of the same rank. We will comment on the roles of the strain and stress tensors more below. For the moment it suffices to say that we interpret the term <img class="formulaInl" alt="$\textrm{div}\ ( C \varepsilon(\mathbf{u}))$" src="form_1596.png"/> as the vector with components <img class="formulaInl" alt="$\frac \partial{\partial x_j} C_{ijkl} \varepsilon(\mathbf{u})_{kl}$" src="form_1597.png"/>, where summation over indices <img class="formulaInl" alt="$j,k,l$" src="form_1598.png"/> is implied.</p>
<p>The quasistatic limit of this equation is motivated as follows: each small perturbation of the body, for example by changes in boundary condition or the forcing function, will result in a corresponding change in the configuration of the body. In general, this will be in the form of waves radiating away from the location of the disturbance. Due to the presence of the damping term, these waves will be attenuated on a time scale of, say, <img class="formulaInl" alt="$\tau$" src="form_1599.png"/>. Now, assume that all changes in external forcing happen on times scales that are much larger than <img class="formulaInl" alt="$\tau$" src="form_1599.png"/>. In that case, the dynamic nature of the change is unimportant: we can consider the body to always be in static equilibrium, i.e. we can assume that at all times the body satisfies </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \textrm{div}\ ( C \varepsilon(\mathbf{u})) &amp;=&amp; \mathbf{f}(\mathbf{x},t) \qquad \textrm{in}\ \Omega, \\ \mathbf{u}(\mathbf{x},t) &amp;=&amp; \mathbf{d}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_D, \\ \mathbf{n} \ C \varepsilon(\mathbf{u}(\mathbf{x},t)) &amp;=&amp; \mathbf{b}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_N. \end{eqnarray*}" src="form_1600.png"/>
</p>
<p> Note that the differential equation does not contain any time derivatives any more &ndash; all time dependence is introduced through boundary conditions and a possibly time-varying force function <img class="formulaInl" alt="$\mathbf{f}(\mathbf{x},t)$" src="form_1601.png"/>. The changes in configuration can therefore be considered as being stationary instantaneously. An alternative view of this is that <img class="formulaInl" alt="$t$" src="form_844.png"/> is not really a time variable, but only a time-like parameter that governs the evolution of the problem.</p>
<p>While these equations are sufficient to describe small deformations, computing large deformations is a little more complicated and, in general, leads to nonlinear equations such as those treated in <a class="el" href="step_44.html">step-44</a>. In the following, let us consider some of the tools one would employ when simulating problems in which the deformation becomes <em>large</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The model we will consider below is not founded on anything that would be mathematically sound: we will consider a model in which we produce a small deformation, deform the physical coordinates of the body by this deformation, and then consider the next loading step again as a linear problem. This isn't consistent, since the assumption of linearity implies that deformations are infinitesimal and so moving around the vertices of our mesh by a finite amount before solving the next linear problem is an inconsistent approach. We should therefore note that it is not surprising that the equations discussed below can't be found in the literature: <b>The model considered here has little to do with reality!</b> On the other hand, the implementational techniques we consider are very much what one would need to use when implementing a <em>real</em> model, as we will see in <a class="el" href="step_44.html">step-44</a>.</dd></dl>
<p>To come back to defining our "artificial" model, let us first introduce a tensorial stress variable <img class="formulaInl" alt="$\sigma$" src="form_456.png"/>, and write the differential equations in terms of the stress: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \textrm{div}\ \sigma &amp;=&amp; \mathbf{f}(\mathbf{x},t) \qquad \textrm{in}\ \Omega(t), \\ \mathbf{u}(\mathbf{x},t) &amp;=&amp; \mathbf{d}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_D\subset\partial\Omega(t), \\ \mathbf{n} \ C \varepsilon(\mathbf{u}(\mathbf{x},t)) &amp;=&amp; \mathbf{b}(\mathbf{x},t) \qquad \textrm{on}\ \Gamma_N=\partial\Omega(t)\backslash\Gamma_D. \end{eqnarray*}" src="form_1602.png"/>
</p>
<p> Note that these equations are posed on a domain <img class="formulaInl" alt="$\Omega(t)$" src="form_1603.png"/> that changes with time, with the boundary moving according to the displacements <img class="formulaInl" alt="$\mathbf{u}(\mathbf{x},t)$" src="form_1604.png"/> of the points on the boundary. To complete this system, we have to specify the incremental relationship between the stress and the strain, as follows: <a class="anchor" id="step_18.stress-strain"></a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \dot\sigma = C \varepsilon (\dot{\mathbf{u}}), \qquad \qquad \textrm{[stress-strain]} \]" src="form_1605.png"/>
</p>
<p> where a dot indicates a time derivative. Both the stress <img class="formulaInl" alt="$\sigma$" src="form_456.png"/> and the strain <img class="formulaInl" alt="$\varepsilon(\mathbf{u})$" src="form_1606.png"/> are symmetric tensors of rank 2.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h4>Time discretization</h4>
<p>Numerically, this system is solved as follows: first, we discretize the time component using a backward Euler scheme. This leads to a discrete equilibrium of force at time step <img class="formulaInl" alt="$n$" src="form_73.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\textrm{div}\ \sigma^n = f^n, \]" src="form_1607.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma^n = \sigma^{n-1} + C \varepsilon (\Delta \mathbf{u}^n), \]" src="form_1608.png"/>
</p>
<p> and <img class="formulaInl" alt="$\Delta \mathbf{u}^n$" src="form_1609.png"/> the incremental displacement for time step <img class="formulaInl" alt="$n$" src="form_73.png"/>. In addition, we have to specify initial data <img class="formulaInl" alt="$\mathbf{u}(\cdot,0)=\mathbf{u}_0$" src="form_1610.png"/>. This way, if we want to solve for the displacement increment, we have to solve the following system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} - \textrm{div}\ C \varepsilon(\Delta\mathbf{u}^n) &amp;= \mathbf{f} + \textrm{div}\ \sigma^{n-1} \qquad &amp;&amp;\textrm{in}\ \Omega(t_{n-1}), \\ \Delta \mathbf{u}^n(\mathbf{x},t) &amp;= \mathbf{d}(\mathbf{x},t_n) - \mathbf{d}(\mathbf{x},t_{n-1}) \qquad &amp;&amp;\textrm{on}\ \Gamma_D\subset\partial\Omega(t_{n-1}), \\ \mathbf{n} \ C \varepsilon(\Delta \mathbf{u}^n(\mathbf{x},t)) &amp;= \mathbf{b}(\mathbf{x},t_n)-\mathbf{b}(\mathbf{x},t_{n-1}) \qquad &amp;&amp;\textrm{on}\ \Gamma_N=\partial\Omega(t_{n-1})\backslash\Gamma_D. \end{align*}" src="form_1611.png"/>
</p>
<p> The weak form of this set of equations, which as usual is the basis for the finite element formulation, reads as follows: find <img class="formulaInl" alt="$\Delta \mathbf{u}^n \in \{v\in H^1(\Omega(t_{n-1}))^d: v|_{\Gamma_D}=\mathbf{d}(\cdot,t_n) - \mathbf{d}(\cdot,t_{n-1})\}$" src="form_1612.png"/> such that <a class="anchor" id="step_18.linear-system"></a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (C \varepsilon(\Delta\mathbf{u}^n), \varepsilon(\varphi) )_{\Omega(t_{n-1})} &amp;= (\mathbf{f}, \varphi)_{\Omega(t_{n-1})} -(\sigma^{n-1},\varepsilon(\varphi))_{\Omega(t_{n-1})} \\ &amp;\qquad +(\mathbf{b}(\mathbf{x},t_n)-\mathbf{b}(\mathbf{x},t_{n-1}), \varphi)_{\Gamma_N} \\ &amp;\qquad\qquad \forall \varphi \in \{\mathbf{v}\in H^1(\Omega(t_{n-1}))^d: \mathbf{v}|_{\Gamma_D}=0\}. \qquad \qquad \textrm{[linear-system]} \end{align*}" src="form_1613.png"/>
</p>
<p> We note that, for simplicity, in the program we will always assume that there are no boundary forces, i.e. <img class="formulaInl" alt="$\mathbf{b} = 0$" src="form_1614.png"/>, and that the deformation of the body is driven by body forces <img class="formulaInl" alt="$\mathbf{f}$" src="form_1592.png"/> and prescribed boundary displacements <img class="formulaInl" alt="$\mathbf{d}$" src="form_1615.png"/> alone. It is also worth noting that when integrating by parts, we would get terms of the form <img class="formulaInl" alt="$(C \varepsilon(\Delta\mathbf{u}^n), \nabla \varphi )_{\Omega(t_{n-1})}$" src="form_1616.png"/>, but that we replace it with the term involving the symmetric gradient <img class="formulaInl" alt="$\varepsilon(\varphi)$" src="form_1617.png"/> instead of <img class="formulaInl" alt="$\nabla\varphi$" src="form_1618.png"/>. Due to the symmetry of <img class="formulaInl" alt="$C$" src="form_43.png"/>, the two terms are equivalent, but the symmetric version avoids a potential for round-off to render the resulting matrix slightly non-symmetric.</p>
<p>The system at time step <img class="formulaInl" alt="$n$" src="form_73.png"/>, to be solved on the old domain <img class="formulaInl" alt="$\Omega(t_{n-1})$" src="form_1619.png"/>, has exactly the form of a stationary elastic problem, and is therefore similar to what we have already implemented in previous example programs. We will therefore not comment on the space discretization beyond saying that we again use lowest order continuous finite elements.</p>
<p>There are differences, however: </p><ol>
<li>
<p class="startli">We have to move (update) the mesh after each time step, in order to be able to solve the next time step on a new domain;</p>
<p class="endli"></p>
</li>
<li>
We need to know <img class="formulaInl" alt="$\sigma^{n-1}$" src="form_1620.png"/> to compute the next incremental displacement, i.e. we need to compute it at the end of the time step to make sure it is available for the next time step. Essentially, the stress variable is our window to the history of deformation of the body. </li>
</ol>
<p>These two operations are done in the functions <code>move_mesh</code> and <code>update_quadrature_point_history</code> in the program. While moving the mesh is only a technicality, updating the stress is a little more complicated and will be discussed in the next section.</p>
<p><a class="anchor" id="Updatingthestressvariable"></a></p><h4>Updating the stress variable</h4>
<p>As indicated above, we need to have the stress variable <img class="formulaInl" alt="$\sigma^n$" src="form_1621.png"/> available when computing time step <img class="formulaInl" alt="$n+1$" src="form_903.png"/>, and we can compute it using <a class="anchor" id="step_18.stress-update"></a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma^n = \sigma^{n-1} + C \varepsilon (\Delta \mathbf{u}^n). \qquad \qquad \textrm{[stress-update]} \]" src="form_1622.png"/>
</p>
<p> There are, despite the apparent simplicity of this equation, two questions that we need to discuss. The first concerns the way we store <img class="formulaInl" alt="$\sigma^n$" src="form_1621.png"/>: even if we compute the incremental updates <img class="formulaInl" alt="$\Delta\mathbf{u}^n$" src="form_1623.png"/> using lowest-order finite elements, then its symmetric gradient <img class="formulaInl" alt="$\varepsilon(\Delta\mathbf{u}^n)$" src="form_1624.png"/> is in general still a function that is not easy to describe. In particular, it is not a piecewise constant function, and on general meshes (with cells that are not rectangles parallel to the coordinate axes) or with non-constant stress-strain tensors <img class="formulaInl" alt="$C$" src="form_43.png"/> it is not even a bi- or trilinear function. Thus, it is a priori not clear how to store <img class="formulaInl" alt="$\sigma^n$" src="form_1621.png"/> in a computer program.</p>
<p>To decide this, we have to see where it is used. The only place where we require the stress is in the term <img class="formulaInl" alt="$(\sigma^{n-1},\varepsilon(\varphi))_{\Omega(t_{n-1})}$" src="form_1625.png"/>. In practice, we of course replace this term by numerical quadrature: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (\sigma^{n-1},\varepsilon(\varphi))_{\Omega(t_{n-1})} = \sum_{K\subset {T}} (\sigma^{n-1},\varepsilon(\varphi))_K \approx \sum_{K\subset {T}} \sum_q w_q \ \sigma^{n-1}(\mathbf{x}_q) : \varepsilon(\varphi(\mathbf{x}_q), \]" src="form_1626.png"/>
</p>
<p> where <img class="formulaInl" alt="$w_q$" src="form_173.png"/> are the quadrature weights and <img class="formulaInl" alt="$\mathbf{x}_q$" src="form_1627.png"/> the quadrature points on cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. This should make clear that what we really need is not the stress <img class="formulaInl" alt="$\sigma^{n-1}$" src="form_1620.png"/> in itself, but only the values of the stress in the quadrature points on all cells. This, however, is a simpler task: we only have to provide a data structure that is able to hold one symmetric tensor of rank 2 for each quadrature point on all cells (or, since we compute in parallel, all quadrature points of all cells that the present MPI process &ldquo;owns&rdquo;). At the end of each time step we then only have to evaluate <img class="formulaInl" alt="$\varepsilon(\Delta \mathbf{u}^n(\mathbf{x}_q))$" src="form_1628.png"/>, multiply it by the stress-strain tensor <img class="formulaInl" alt="$C$" src="form_43.png"/>, and use the result to update the stress <img class="formulaInl" alt="$\sigma^n(\mathbf{x}_q)$" src="form_1629.png"/> at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/>.</p>
<p>The second complication is not visible in our notation as chosen above. It is due to the fact that we compute <img class="formulaInl" alt="$\Delta u^n$" src="form_1630.png"/> on the domain <img class="formulaInl" alt="$\Omega(t_{n-1})$" src="form_1619.png"/>, and then use this displacement increment to both update the stress as well as move the mesh nodes around to get to <img class="formulaInl" alt="$\Omega(t_n)$" src="form_1631.png"/> on which the next increment is computed. What we have to make sure, in this context, is that moving the mesh does not only involve moving around the nodes, but also making corresponding changes to the stress variable: the updated stress is a variable that is defined with respect to the coordinate system of the material in the old domain, and has to be transferred to the new domain. The reason for this can be understood as follows: locally, the incremental deformation <img class="formulaInl" alt="$\Delta\mathbf{u}$" src="form_1632.png"/> can be decomposed into three parts, a linear translation (the constant part of the displacement increment field in the neighborhood of a point), a dilational component (that part of the gradient of the displacement field that has a nonzero divergence), and a rotation. A linear translation of the material does not affect the stresses that are frozen into it &ndash; the stress values are simply translated along. The dilational or compressional change produces a corresponding stress update. However, the rotational component does not necessarily induce a nonzero stress update (think, in 2d, for example of the situation where <img class="formulaInl" alt="$\Delta\mathbf{u}=(y, -x)^T$" src="form_1633.png"/>, with which <img class="formulaInl" alt="$\varepsilon(\Delta \mathbf{u})=0$" src="form_1634.png"/>). Nevertheless, if the the material was prestressed in a certain direction, then this direction will be rotated along with the material. To this end, we have to define a rotation matrix <img class="formulaInl" alt="$R(\Delta \mathbf{u}^n)$" src="form_1635.png"/> that describes, in each point the rotation due to the displacement increments. It is not hard to see that the actual dependence of <img class="formulaInl" alt="$R$" src="form_432.png"/> on <img class="formulaInl" alt="$\Delta \mathbf{u}^n$" src="form_1609.png"/> can only be through the curl of the displacement, rather than the displacement itself or its full gradient (as mentioned above, the constant components of the increment describe translations, its divergence the dilational modes, and the curl the rotational modes). Since the exact form of <img class="formulaInl" alt="$R$" src="form_432.png"/> is cumbersome, we only state it in the program code, and note that the correct updating formula for the stress variable is then <a class="anchor" id="step_18.stress-update+rot"></a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma^n = R(\Delta \mathbf{u}^n)^T [\sigma^{n-1} + C \varepsilon (\Delta \mathbf{u}^n)] R(\Delta \mathbf{u}^n). \qquad \qquad \textrm{[stress-update+rot]} \]" src="form_1636.png"/>
</p>
<p>Both stress update and rotation are implemented in the function <code>update_quadrature_point_history</code> of the example program.</p>
<p><a class="anchor" id="Parallelgraphicaloutput"></a></p><h3>Parallel graphical output</h3>
<p>In <a class="el" href="step_17.html">step-17</a>, the main bottleneck for parallel computations as far as run time is concerned was that only the first processor generated output for the entire domain. Since generating graphical output is expensive, this did not scale well when larger numbers of processors were involved. We will address this here. (For a definition of what it means for a program to "scale", see <a class="el" href="DEALGlossary.html#GlossParallelScaling">this glossary entry.)</a> Basically, what we need to do is let every process generate graphical output for that subset of cells that it owns, write them into separate files and have a way to display all files for a certain timestep at the same time. This way the code produces one <code>.vtu</code> file per process per time step. The two common VTK file viewers ParaView and VisIt both support opening more than one <code>.vtu</code> file at once. To simplify the process of picking the correct files and allow moving around in time, both support record files that reference all files for a given timestep. Sadly, the record files have a different format between VisIt and Paraview, so we write out both formats.</p>
<p>The code will generate the files <code>solution-TTTT.NNN.vtu</code>, where <code>TTTT</code> is the timestep number (starting from 1) and <code>NNN</code> is the process rank (starting from 0). These files contain the locally owned cells for the timestep and processor. The files <code>solution-TTTT.visit</code> is the visit record for timestep <code>TTTT</code>, while <code>solution-TTTT.pvtu</code> is the same for ParaView. (More recent versions of Visit can actually read <code>.pvtu</code> files as well, but it doesn't hurt to output both kinds of record files.) Finally, the file <code>solution.pvd</code> is a special record only supported by ParaView that references all time steps. So in ParaView, only solution.pvd needs to be opened, while one needs to select the group of all .visit files in VisIt for the same effect.</p>
<p><a class="anchor" id="Atriangulationwithautomaticpartitioning"></a></p><h3>A triangulation with automatic partitioning</h3>
<p>In <a class="el" href="step_17.html">step-17</a>, we used a regular triangulation that was simply replicated on every processor, and a corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a>. Both had no idea that they were used in a parallel context &ndash; they just existed in their entirety on every processor, and we argued that this was eventually going to be a major memory bottleneck.</p>
<p>We do not address this issue here (we will do so in <a class="el" href="step_40.html">step-40</a>) but make the situation slightly more automated. In <a class="el" href="step_17.html">step-17</a>, we created the triangulation and then manually "partitioned" it, i.e., we assigned <a class="el" href="DEALGlossary.html#GlossSubdomainId">subdomain ids</a> to every cell that indicated which <a class="el" href="DEALGlossary.html#GlossMPIProcess">MPI process</a> "owned" the cell. Here, we use a class <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> that at least does this part automatically: whenever you create or refine such a triangulation, it automatically partitions itself among all involved processes (which it knows about because you have to tell it about the <a class="el" href="DEALGlossary.html#GlossMPICommunicator">MPI communicator</a> that connects these processes upon construction of the triangulation). Otherwise, the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> looks, for all practical purposes, like a regular <a class="el" href="classTriangulation.html">Triangulation</a> object.</p>
<p>The convenience of using this class does not only result from being able to avoid the manual call to GridTools::partition(). Rather, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class now also knows that you want to use it in a parallel context, and by default automatically enumerates degrees of freedom in such a way that all DoFs owned by process zero come before all DoFs owned by process 1, etc. In other words, you can also avoid the call to <a class="el" href="namespaceDoFRenumbering.html#a442e0991d482f8d208069945d4cee508">DoFRenumbering::subdomain_wise()</a>.</p>
<p>There are other benefits. For example, because the triangulation knows that it lives in a parallel universe, it also knows that it "owns" certain cells (namely, those whose subdomain id equals its MPI rank; previously, the triangulation only stored these subdomain ids, but had no way to make sense of them). Consequently, in the assembly function, you can test whether a cell is "locally owned" (i.e., owned by the current process, see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>) when you loop over all cells using the syntax </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div></div><!-- fragment --><p> This knowledge extends to the <a class="el" href="classDoFHandler.html">DoFHandler</a> object built on such triangulations, which can then identify which degrees of freedom are locally owned (see GlossLocallyOwnedDofs) via calls such as <a class="el" href="classDoFHandler.html#aff791a67d5a9383fb2ef05ea540b71e8">DoFHandler::n_locally_owned_dofs_per_processor()</a> and <a class="el" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs()</a>. Finally, the <a class="el" href="classDataOut.html">DataOut</a> class also knows how to deal with such triangulations and will simply skip generating graphical output on cells not locally owned.</p>
<p>Of course, as has been noted numerous times in the discussion in <a class="el" href="step_17.html">step-17</a>, keeping the entire triangulation on every process will not scale: large problems may simply not fit into each process's memory any more, even if we have sufficiently many processes around to solve them in a reasonable time. In such cases, the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> is no longer a reasonable basis for computations and we will show in <a class="el" href="step_40.html">step-40</a> how the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class can be used to work around this, namely by letting each process store only a <em>part</em> of the triangulation.</p>
<p><a class="anchor" id="Overallstructureoftheprogram"></a></p><h3>Overall structure of the program</h3>
<p>The overall structure of the program can be inferred from the <code>run()</code> function that first calls <code>do_initial_timestep()</code> for the first time step, and then <code>do_timestep()</code> on all subsequent time steps. The difference between these functions is only that in the first time step we start on a coarse mesh, solve on it, refine the mesh adaptively, and then start again with a clean state on that new mesh. This procedure gives us a better starting mesh, although we should of course keep adapting the mesh as iterations proceed &ndash; this isn't done in this program, but commented on below.</p>
<p>The common part of the two functions treating time steps is the following sequence of operations on the present mesh: </p><ul>
<li>
<p class="startli"><code>assemble_system ()</code> [via <code>solve_timestep ()</code>]: This first function is also the most interesting one. It assembles the linear system corresponding to the discretized version of equation <a href="#step_18.linear-system">[linear-system]</a>. This leads to a system matrix <img class="formulaInl" alt="$A_{ij} = \sum_K A^K_{ij}$" src="form_1637.png"/> built up of local contributions on each cell <img class="formulaInl" alt="$K$" src="form_57.png"/> with entries </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A^K_{ij} = (C \varepsilon(\varphi_j), \varepsilon(\varphi_i))_K; \]" src="form_1638.png"/>
</p>
<p> In practice, <img class="formulaInl" alt="$A^K$" src="form_1639.png"/> is computed using numerical quadrature according to the formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A^K_{ij} = \sum_q w_q [\varepsilon(\varphi_i(\mathbf{x}_q)) : C : \varepsilon(\varphi_j(\mathbf{x}_q))], \]" src="form_1640.png"/>
</p>
<p> with quadrature points <img class="formulaInl" alt="$\mathbf{x}_q$" src="form_1627.png"/> and weights <img class="formulaInl" alt="$w_q$" src="form_173.png"/>. We have built these contributions before, in <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_17.html">step-17</a>, but in both of these cases we have done so rather clumsily by using knowledge of how the rank-4 tensor <img class="formulaInl" alt="$C$" src="form_43.png"/> is composed, and considering individual elements of the strain tensors <img class="formulaInl" alt="$\varepsilon(\varphi_i),\varepsilon(\varphi_j)$" src="form_1641.png"/>. This is not really convenient, in particular if we want to consider more complicated elasticity models than the isotropic case for which <img class="formulaInl" alt="$C$" src="form_43.png"/> had the convenient form <img class="formulaInl" alt="$C_{ijkl} = \lambda \delta_{ij} \delta_{kl} + \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk})$" src="form_1642.png"/>. While we in fact do not use a more complicated form than this in the present program, we nevertheless want to write it in a way that would easily allow for this. It is then natural to introduce classes that represent symmetric tensors of rank 2 (for the strains and stresses) and 4 (for the stress-strain tensor <img class="formulaInl" alt="$C$" src="form_43.png"/>). Fortunately, deal.II provides these: the <code>SymmetricTensor&lt;rank,dim&gt;</code> class template provides a full-fledged implementation of such tensors of rank <code>rank</code> (which needs to be an even number) and dimension <code>dim</code>.</p>
<p>What we then need is two things: a way to create the stress-strain rank-4 tensor <img class="formulaInl" alt="$C$" src="form_43.png"/> as well as to create a symmetric tensor of rank 2 (the strain tensor) from the gradients of a shape function <img class="formulaInl" alt="$\varphi_i$" src="form_531.png"/> at a quadrature point <img class="formulaInl" alt="$\mathbf{x}_q$" src="form_1627.png"/> on a given cell. At the top of the implementation of this example program, you will find such functions. The first one, <code>get_stress_strain_tensor</code>, takes two arguments corresponding to the Lam&eacute; constants <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> and <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> and returns the stress-strain tensor for the isotropic case corresponding to these constants (in the program, we will choose constants corresponding to steel); it would be simple to replace this function by one that computes this tensor for the anisotropic case, or taking into account crystal symmetries, for example. The second one, <code>get_strain</code> takes an object of type <code><a class="el" href="classFEValues.html">FEValues</a></code> and indices <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$q$" src="form_171.png"/> and returns the symmetric gradient, i.e. the strain, corresponding to shape function <img class="formulaInl" alt="$\varphi_i(\mathbf{x}_q)$" src="form_1644.png"/>, evaluated on the cell on which the <code><a class="el" href="classFEValues.html">FEValues</a></code> object was last reinitialized.</p>
<p>Given this, the innermost loop of <code>assemble_system</code> computes the local contributions to the matrix in the following elegant way (the variable <code>stress_strain_tensor</code>, corresponding to the tensor <img class="formulaInl" alt="$C$" src="form_43.png"/>, has previously been initialized with the result of the first function above): </p><pre class="fragment">for (unsigned int i=0; i&lt;dofs_per_cell; ++i)
  for (unsigned int j=0; j&lt;dofs_per_cell; ++j)
    for (unsigned int q_point=0; q_point&lt;n_q_points;
         ++q_point)
      {
        const SymmetricTensor&lt;2,dim&gt;
          eps_phi_i = get_strain (fe_values, i, q_point),
          eps_phi_j = get_strain (fe_values, j, q_point);

        cell_matrix(i,j)
          += (eps_phi_i * stress_strain_tensor * eps_phi_j
              *
              fe_values.JxW (q_point));
      }</pre><p> It is worth noting the expressive power of this piece of code, and to compare it with the complications we had to go through in previous examples for the elasticity problem. (To be fair, the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class template did not exist when these previous examples were written.) For simplicity, <code>operator*</code> provides for the (double summation) product between symmetric tensors of even rank here.</p>
<p>Assembling the local contributions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f^K_i &amp;=&amp; (\mathbf{f}, \varphi_i)_K -(\sigma^{n-1},\varepsilon(\varphi_i))_K \\ &amp;\approx&amp; \sum_q w_q \left\{ \mathbf{f}(\mathbf{x}_q) \cdot \varphi_i(\mathbf{x}_q) - \sigma^{n-1}_q : \varepsilon(\varphi_i(\mathbf{x}_q)) \right\} \end{eqnarray*}" src="form_1645.png"/>
</p>
<p> to the right hand side of <a href="#step_18.linear-system">[linear-system]</a> is equally straightforward (note that we do not consider any boundary tractions <img class="formulaInl" alt="$\mathbf{b}$" src="form_1646.png"/> here). Remember that we only had to store the old stress in the quadrature points of cells. In the program, we will provide a variable <code>local_quadrature_points_data</code> that allows to access the stress <img class="formulaInl" alt="$\sigma^{n-1}_q$" src="form_1647.png"/> in each quadrature point. With this the code for the right hand side looks as this, again rather elegant: </p><pre class="fragment">for (unsigned int i=0; i&lt;dofs_per_cell; ++i)
  {
    const unsigned int
      component_i = fe.system_to_component_index(i).first;

    for (unsigned int q_point=0; q_point&lt;n_q_points; ++q_point)
      {
        const SymmetricTensor&lt;2,dim&gt; &amp;old_stress
          = local_quadrature_points_data[q_point].old_stress;

        cell_rhs(i) += (body_force_values[q_point](component_i) *
                        fe_values.shape_value (i,q_point)
                        -
                        old_stress *
                        get_strain (fe_values,i,q_point))
                       *
                       fe_values.JxW (q_point);
      }
  }</pre><p> Note that in the multiplication <img class="formulaInl" alt="$\mathbf{f}(\mathbf{x}_q) \cdot \varphi_i(\mathbf{x}_q)$" src="form_1648.png"/>, we have made use of the fact that for the chosen finite element, only one vector component (namely <code>component_i</code>) of <img class="formulaInl" alt="$\varphi_i$" src="form_531.png"/> is nonzero, and that we therefore also have to consider only one component of <img class="formulaInl" alt="$\mathbf{f}(\mathbf{x}_q)$" src="form_1649.png"/>.</p>
<p>This essentially concludes the new material we present in this function. It later has to deal with boundary conditions as well as hanging node constraints, but this parallels what we had to do previously in other programs already.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>solve_linear_problem ()</code> [via <code>solve_timestep ()</code>]: Unlike the previous one, this function is not really interesting, since it does what similar functions have done in all previous tutorial programs &ndash; solving the linear system using the CG method, using an incomplete LU decomposition as a preconditioner (in the parallel case, it uses an ILU of each processor's block separately). It is virtually unchanged from <a class="el" href="step_17.html">step-17</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>update_quadrature_point_history ()</code> [via <code>solve_timestep ()</code>]: Based on the displacement field <img class="formulaInl" alt="$\Delta \mathbf{u}^n$" src="form_1609.png"/> computed before, we update the stress values in all quadrature points according to <a href="#step_18.stress-update">[stress-update]</a> and <a href="#step_18.stress-update+rot">[stress-update+rot]</a>, including the rotation of the coordinate system.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>move_mesh ()</code>: Given the solution computed before, in this function we deform the mesh by moving each vertex by the displacement vector field evaluated at this particular vertex.</p>
<p class="endli"></p>
</li>
<li>
<code>output_results ()</code>: This function simply outputs the solution based on what we have said above, i.e. every processor computes output only for its own portion of the domain. In addition to the solution, we also compute the norm of the stress averaged over all the quadrature points on each cell. </li>
</ul>
<p>With this general structure of the code, we only have to define what case we want to solve. For the present program, we have chosen to simulate the quasistatic deformation of a vertical cylinder for which the bottom boundary is fixed and the top boundary is pushed down at a prescribed vertical velocity. However, the horizontal velocity of the top boundary is left unspecified &ndash; one can imagine this situation as a well-greased plate pushing from the top onto the cylinder, the points on the top boundary of the cylinder being allowed to slide horizontally along the surface of the plate, but forced to move downward by the plate. The inner and outer boundaries of the cylinder are free and not subject to any prescribed deflection or traction. In addition, gravity acts on the body.</p>
<p>The program text will reveal more about how to implement this situation, and the results section will show what displacement pattern comes out of this simulation.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First the usual list of header files that have already been used in previous example programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/multithread_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/shared_tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div></div><!-- fragment --><p>And here the only three new things among the header files: an include file in which symmetric tensors of rank 2 and 4 are implemented, as introduced in the introduction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div></div><!-- fragment --><p>And a header that implements filters for iterators looping over all cells. We will use this when selecting only those cells for output that are owned by the present process in a parallel program:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/filtered_iterator.h&gt;</span></div></div><!-- fragment --><p>And lastly a header that contains some functions that will help us compute rotaton matrices of the local coordinate systems at specific points in the domain.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/transformations.h&gt;</span></div></div><!-- fragment --><p>This is then simply C++ again:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step18</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodePointHistorycodeclass"></a> </p><h3>The <code>PointHistory</code> class</h3>
<p>As was mentioned in the introduction, we have to store the old stress in quadrature point so that we can compute the residual forces at this point during the next time step. This alone would not warrant a structure with only one member, but in more complicated applications, we would have to store more information in quadrature points as well, such as the history variables of plasticity, etc. In essence, we have to store everything that affects the present state of the material here, which in plasticity is determined by the deformation history variables.</p>
<p>We will not give this class any meaningful functionality beyond being able to store data, i.e. there are no constructors, destructors, or other member functions. In such cases of `dumb' classes, we usually opt to declare them as <code>struct</code> rather than <code>class</code>, to indicate that they are closer to C-style structures than C++-style classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>PointHistory</div><div class="line">{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> old_stress;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Thestressstraintensor"></a> </p><h3>The stress-strain tensor</h3>
<p>Next, we define the linear relationship between the stress and the strain in elasticity. It is given by a tensor of rank 4 that is usually written in the form <img class="formulaInl" alt="$C_{ijkl} = \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}) + \lambda \delta_{ij} \delta_{kl}$" src="form_1650.png"/>. This tensor maps symmetric tensor of rank 2 to symmetric tensors of rank 2. A function implementing its creation for given values of the Lame constants <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> and <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> is straightforward:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a></div><div class="line">get_stress_strain_tensor (<span class="keyword">const</span> <span class="keywordtype">double</span> lambda, <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacemu.html">mu</a>)</div><div class="line">{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a> tmp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          tmp[i][j][k][l] = (((i==k) &amp;&amp; (j==l) ? mu : 0.0) +</div><div class="line">                             ((i==l) &amp;&amp; (j==k) ? mu : 0.0) +</div><div class="line">                             ((i==j) &amp;&amp; (k==l) ? lambda : 0.0));</div><div class="line">  <span class="keywordflow">return</span> tmp;</div><div class="line">}</div></div><!-- fragment --><p>With this function, we will define a static member variable of the main class below that will be used throughout the program as the stress-strain tensor. Note that in more elaborate programs, this will probably be a member variable of some class instead, or a function that returns the stress-strain relationship depending on other input. For example in damage theory models, the Lame constants are considered a function of the prior stress/strain history of a point. Conversely, in plasticity the form of the stress-strain tensor is modified if the material has reached the yield stress in a certain point, and possibly also depending on its prior history.</p>
<p>In the present program, however, we assume that the material is completely elastic and linear, and a constant stress-strain tensor is sufficient for our present purposes.</p>
<p><a class="anchor" id="Auxiliaryfunctions"></a> </p><h3>Auxiliary functions</h3>
<p>Before the rest of the program, here are a few functions that we need as tools. These are small functions that are called in inner loops, so we mark them as <code>inline</code>.</p>
<p>The first one computes the symmetric strain tensor for shape function <code>shape_func</code> at quadrature point <code>q_point</code> by forming the symmetric gradient of this shape function. We need that when we want to form the matrix, for example.</p>
<p>We should note that in previous examples where we have treated vector-valued problems, we have always asked the finite element object in which of the vector component the shape function is actually non-zero, and thereby avoided to compute any terms that we could prove were zero anyway. For this, we used the <code>fe.system_to_component_index</code> function that returns in which component a shape function was zero, and also that the <code>fe_values.shape_value</code> and <code>fe_values.shape_grad</code> functions only returned the value and gradient of the single non-zero component of a shape function if this is a vector-valued element.</p>
<p>This was an optimization, and if it isn't terribly time critical, we can get away with a simpler technique: just ask the <code>fe_values</code> for the value or gradient of a given component of a given shape function at a given quadrature point. This is what the <code>fe_values.shape_grad_component(shape_func,q_point,i)</code> call does: return the full gradient of the <code>i</code>th component of shape function <code>shape_func</code> at quadrature point <code>q_point</code>. If a certain component of a certain shape function is always zero, then this will simply always return zero.</p>
<p>As mentioned, using <code>fe_values.shape_grad_component</code> instead of the combination of <code>fe.system_to_component_index</code> and <code>fe_values.shape_grad</code> may be less efficient, but its implementation is optimized for such cases and shouldn't be a big slowdown. We demonstrate the technique here since it is so much simpler and straightforward.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">inline</span></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">get_strain (<span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   shape_func,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   q_point)</div><div class="line">{</div></div><!-- fragment --><p>Declare a temporary that will hold the return value:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> tmp;</div></div><!-- fragment --><p>First, fill diagonal terms which are simply the derivatives in direction <code>i</code> of the <code>i</code> component of the vector-valued shape function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">  tmp[i][i] = fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,i)[i];</div></div><!-- fragment --><p>Then fill the rest of the strain tensor. Note that since the tensor is symmetric, we only have to compute one half (here: the upper right corner) of the off-diagonal elements, and the implementation of the <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> class makes sure that at least to the outside the symmetric entries are also filled (in practice, the class of course stores only one copy). Here, we have picked the upper right half of the tensor, but the lower left one would have been just as good:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;dim; ++j)</div><div class="line">      tmp[i][j]</div><div class="line">        = (fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,i)[j] +</div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,j)[i]) / 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> tmp;</div><div class="line">}</div></div><!-- fragment --><p>The second function does something very similar (and therefore is given the same name): compute the symmetric strain tensor from the gradient of a vector-valued field. If you already have a solution field, the <code>fe_values.get_function_gradients</code> function allows you to extract the gradients of each component of your solution field at a quadrature point. It returns this as a vector of rank-1 tensors: one rank-1 tensor (gradient) per vector component of the solution. From this we have to reconstruct the (symmetric) strain tensor by transforming the data storage format and symmetrization. We do this in the same way as above, i.e. we avoid a few computations by filling first the diagonal and then only one half of the symmetric tensor (the <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> class makes sure that it is sufficient to write only one of the two symmetric components).</p>
<p>Before we do this, though, we make sure that the input has the kind of structure we expect: that is that there are <code>dim</code> vector components, i.e. one displacement component for each coordinate direction. We test this with the <code>Assert</code> macro that will simply abort our program if the condition is not met.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">inline</span></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">get_strain (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;grad)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (grad.size() == dim, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    strain[i][i] = grad[i][i];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;dim; ++j)</div><div class="line">      strain[i][j] = (grad[i][j] + grad[j][i]) / 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> strain;</div><div class="line">}</div></div><!-- fragment --><p>Finally, below we will need a function that computes the rotation matrix induced by a displacement at a given point. In fact, of course, the displacement at a single point only has a direction and a magnitude, it is the change in direction and magnitude that induces rotations. In effect, the rotation matrix can be computed from the gradients of a displacement, or, more specifically, from the curl.</p>
<p>The formulas by which the rotation matrices are determined are a little awkward, especially in 3d. For 2d, there is a simpler way, so we implement this function twice, once for 2d and once for 3d, so that we can compile and use the program in both space dimensions if so desired &ndash; after all, deal.II is all about dimension independent programming and reuse of algorithm thoroughly tested with cheap computations in 2d, for the more expensive computations in 3d. Here is one case, where we have to implement different algorithms for 2d and 3d, but then can write the rest of the program in a way that is independent of the space dimension.</p>
<p>So, without further ado to the 2d implementation:</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2,2&gt;</a></div><div class="line">get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,2&gt;</a> &gt; &amp;grad_u)</div><div class="line">{</div></div><!-- fragment --><p>First, compute the curl of the velocity field from the gradients. Note that we are in 2d, so the rotation is a scalar:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> curl = (grad_u[1][0] - grad_u[0][1]);</div></div><!-- fragment --><p>From this, compute the angle of rotation:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (curl);</div></div><!-- fragment --><p>And from this, build the antisymmetric rotation matrix. We want this rotation matrix to represent the rotation of the local coordinate system with respect to the global Cartesian basis, to we construct it with a negative angle. The rotation matrix therefore represents the rotation required to move from the local to the global coordinate system.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Transformations_1_1Rotations.html#a1282052109c63a92db123927b5a6b603">Physics::Transformations::Rotations::rotation_matrix_2d</a>(-angle);</div><div class="line">}</div></div><!-- fragment --><p>The 3d case is a little more contrived:</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a></div><div class="line">get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,3&gt;</a> &gt; &amp;grad_u)</div><div class="line">{</div></div><!-- fragment --><p>Again first compute the curl of the velocity field. This time, it is a real vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> curl (grad_u[2][1] - grad_u[1][2],</div><div class="line">                     grad_u[0][2] - grad_u[2][0],</div><div class="line">                     grad_u[1][0] - grad_u[0][1]);</div></div><!-- fragment --><p>From this vector, using its magnitude, compute the tangent of the angle of rotation, and from it the actual angle of rotation with respect to the Cartesian basis:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tan_angle = std::sqrt(curl*curl);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (tan_angle);</div></div><!-- fragment --><p>Now, here's one problem: if the angle of rotation is too small, that means that there is no rotation going on (for example a translational motion). In that case, the rotation matrix is the identity matrix.</p>
<p>The reason why we stress that is that in this case we have that <code>tan_angle==0</code>. Further down, we need to divide by that number in the computation of the axis of rotation, and we would get into trouble when dividing doing so. Therefore, let's shortcut this and simply return the identity matrix if the angle of rotation is really small:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (std::abs(angle) &lt; 1e-9)</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> rotation[3][3]</div><div class="line">    = {{ 1, 0, 0}, { 0, 1, 0 }, { 0, 0, 1 } };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a> rot(rotation);</div><div class="line">    <span class="keywordflow">return</span> rot;</div><div class="line">  }</div></div><!-- fragment --><p>Otherwise compute the real rotation matrix. For this, again we rely on a predefined function to compute the rotation matrix of the local coordinate system.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> axis = curl/tan_angle;</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Transformations_1_1Rotations.html#a37f1cae34605889569d4e56b42658f63">Physics::Transformations::Rotations::rotation_matrix_3d</a>(axis, -angle);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeTopLevelcodeclass"></a> </p><h3>The <code>TopLevel</code> class</h3>
<p>This is the main class of the program. Since the namespace already indicates what problem we are solving, let's call it by what it does: it directs the flow of the program, i.e. it is the toplevel driver.</p>
<p>The member variables of this class are essentially as before, i.e. it has to have a triangulation, a DoF handler and associated objects such as constraints, variables that describe the linear system, etc. There are a good number of more member functions now, which we will explain below.</p>
<p>The external interface of the class, however, is unchanged: it has a public constructor and desctructor, and it has a <code>run</code> function that initiated all the work.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TopLevel</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TopLevel ();</div><div class="line">  ~TopLevel ();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>The private interface is more extensive than in <a class="el" href="step_17.html">step-17</a>. First, we obviously need functions that create the initial mesh, set up the variables that describe the linear system on the present mesh (i.e. matrices and vectors), and then functions that actually assemble the system, direct what has to be solved in each time step, a function that solves the linear system that arises in each timestep (and returns the number of iterations it took), and finally output the solution vector on the correct mesh:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> create_coarse_grid ();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_system ();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> assemble_system ();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve_timestep ();</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve_linear_problem ();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div></div><!-- fragment --><p>All, except for the first two, of these functions are called in each timestep. Since the first time step is a little special, we have separate functions that describe what has to happen in a timestep: one for the first, and one for all following timesteps:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_initial_timestep ();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> do_timestep ();</div></div><!-- fragment --><p>Then we need a whole bunch of functions that do various things. The first one refines the initial grid: we start on the coarse grid with a pristine state, solve the problem, then look at it and refine the mesh accordingly, and start the same process over again, again with a pristine state. Thus, refining the initial mesh is somewhat simpler than refining a grid between two successive time steps, since it does not involve transferring data from the old to the new triangulation, in particular the history data that is stored in each quadrature point.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> refine_initial_grid ();</div></div><!-- fragment --><p>At the end of each time step, we want to move the mesh vertices around according to the incremental displacement computed in this time step. This is the function in which this is done:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> move_mesh ();</div></div><!-- fragment --><p>Next are two functions that handle the history variables stored in each quadrature point. The first one is called before the first timestep to set up a pristine state for the history variables. It only works on those quadrature points on cells that belong to the present processor:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_quadrature_point_history ();</div></div><!-- fragment --><p>The second one updates the history variables at the end of each timestep:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_quadrature_point_history ();</div></div><!-- fragment --><p>This is the new shared <a class="el" href="classTriangulation.html">Triangulation</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div></div><!-- fragment --><p>One difference of this program is that we declare the quadrature formula in the class declaration. The reason is that in all the other programs, it didn't do much harm if we had used different quadrature formulas when computing the matrix and the right hand side, for example. However, in the present case it does: we store information in the quadrature points, so we have to make sure all parts of the program agree on where they are and how many there are on each cell. Thus, let us first declare the quadrature formula that will be used throughout...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula;</div></div><!-- fragment --><p>... and then also have a vector of history objects, one per quadrature point on those cells for which we are responsible (i.e. we don't store history data for quadrature points on cells that are owned by other processors). Note that, instead of storing and managing this data ourself, we could use the <a class="el" href="classCellDataStorage.html">CellDataStorage</a> class like is done in <a class="el" href="step_44.html">step-44</a>. However, for the purpose of demonstration, in this case we manage the storage manually.</p>
<div class="fragment"><div class="line">std::vector&lt;PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div></div><!-- fragment --><p>The way this object is accessed is through a <code>user pointer</code> that each cell, face, or edge holds: it is a <code>void*</code> pointer that can be used by application programs to associate arbitrary data to cells, faces, or edges. What the program actually does with this data is within its own responsibility, the library just allocates some space for these pointers, and application programs can set and read the pointers for each of these objects.</p>
<p>Further: we need the objects of linear systems to be solved, i.e. matrix, right hand side vector, and the solution vector. Since we anticipate solving big problems, we use the same types as in <a class="el" href="step_17.html">step-17</a>, i.e. distributed parallel matrices and vectors built on top of the PETSc library. Conveniently, they can also be used when running on only a single machine, in which case this machine happens to be the only one in our parallel universe.</p>
<p>However, as a difference to <a class="el" href="step_17.html">step-17</a>, we do not store the solution vector &ndash; which here is the incremental displacements computed in each time step &ndash; in a distributed fashion. I.e., of course it must be a distributed vector when computing it, but immediately after that we make sure each processor has a complete copy. The reason is that we had already seen in <a class="el" href="step_17.html">step-17</a> that many functions needed a complete copy. While it is not hard to get it, this requires communication on the network, and is thus slow. In addition, these were repeatedly the same operations, which is certainly undesirable unless the gains of not always having to store the entire vector outweighs it. When writing this program, it turned out that we need a complete copy of the solution in so many places that it did not seem worthwhile to only get it when necessary. Instead, we opted to obtain the complete copy once and for all, and instead get rid of the distributed copy immediately. Thus, note that the declaration of <code>incremental_displacement</code> does not denote a distribute vector as would be indicated by the middle namespace <code>MPI</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       system_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   incremental_displacement;</div></div><!-- fragment --><p>The next block of variables is then related to the time dependent nature of the problem: they denote the length of the time interval which we want to simulate, the present time and number of time step, and length of present timestep:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>       present_time;</div><div class="line"><span class="keywordtype">double</span>       present_timestep;</div><div class="line"><span class="keywordtype">double</span>       end_time;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_no;</div></div><!-- fragment --><p>Then a few variables that have to do with parallel processing: first, a variable denoting the MPI communicator we use, and then two numbers telling us how many participating processors there are, and where in this world we are. Finally, a stream object that makes sure only one processor is actually generating output to the console. This is all the same as in <a class="el" href="step_17.html">step-17</a>:</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">n_mpi_processes</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>;</div><div class="line"></div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>Here is a vector where each entry denotes the numbers of degrees of freedom that are stored on the processor with that particular number:</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dofs_per_process;</div></div><!-- fragment --><p>We are storing the locally owned and the locally relevant indices:</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div></div><!-- fragment --><p>In the same direction, also cache how many cells the present processor owns. Note that the cells that belong to a processor are not necessarily contiguously numbered (when iterating over them using <code>active_cell_iterator</code>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_local_cells;</div></div><!-- fragment --><p>Finally, we have a static variable that denotes the linear relationship between the stress and strain. Since it is a constant object that does not depend on any input (at least not in this program), we make it a static variable and will initialize it in the same place where we define the constructor of this class:</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a> stress_strain_tensor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBodyForcecodeclass"></a> </p><h3>The <code>BodyForce</code> class</h3>
<p>Before we go on to the main functionality of this program, we have to define what forces will act on the body whose deformation we want to study. These may either be body forces or boundary forces. Body forces are generally mediated by one of the four basic physical types of forces: gravity, strong and weak interaction, and electromagnetism. Unless one wants to consider subatomic objects (for which quasistatic deformation is irrelevant and an inappropriate description anyway), only gravity and electromagnetic forces need to be considered. Let us, for simplicity assume that our body has a certain mass density, but is either non-magnetic and not electrically conducting or that there are no significant electromagnetic fields around. In that case, the body forces are simply <code>rho g</code>, where <code>rho</code> is the material density and <code>g</code> is a vector in negative z-direction with magnitude 9.81 m/s^2. Both the density and <code>g</code> are defined in the function, and we take as the density 7700 kg/m^3, a value commonly assumed for steel.</p>
<p>To be a little more general and to be able to do computations in 2d as well, we realize that the body force is always a function returning a <code>dim</code> dimensional vector. We assume that gravity acts along the negative direction of the last, i.e. <code>dim-1</code>th coordinate. The rest of the implementation of this function should be mostly self-explanatory given similar definitions in previous example programs. Note that the body force is independent of the location; to avoid compiler warnings about unused function arguments, we therefore comment out the name of the first argument of the <code>vector_value</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce ();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BodyForce&lt;dim&gt;::BodyForce ()</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">inline</span></div><div class="line"><span class="keywordtype">void</span></div><div class="line">BodyForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;/ *p* /,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> g   = 9.81;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rho = 7700;</div><div class="line"></div><div class="line">  values = 0;</div><div class="line">  values(dim-1) = -rho * g;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BodyForce&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    BodyForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">                                  value_list[p]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeIncrementalBoundaryValuecodeclass"></a> </p><h3>The <code>IncrementalBoundaryValue</code> class</h3>
<p>In addition to body forces, movement can be induced by boundary forces and forced boundary displacement. The latter case is equivalent to forces being chosen in such a way that they induce certain displacement.</p>
<p>For quasistatic displacement, typical boundary forces would be pressure on a body, or tangential friction against another body. We chose a somewhat simpler case here: we prescribe a certain movement of (parts of) the boundary, or at least of certain components of the displacement vector. We describe this by another vector-valued function that, for a given point on the boundary, returns the prescribed displacement.</p>
<p>Since we have a time-dependent problem, the displacement increment of the boundary equals the displacement accumulated during the length of the timestep. The class therefore has to know both the present time and the length of the present time step, and can then approximate the incremental displacement as the present velocity times the present timestep.</p>
<p>For the purposes of this program, we choose a simple form of boundary displacement: we displace the top boundary with constant velocity downwards. The rest of the boundary is either going to be fixed (and is then described using an object of type <code><a class="el" href="classZeroFunction.html">ZeroFunction</a></code>) or free (Neumann-type, in which case nothing special has to be done). The implementation of the class describing the constant downward motion should then be obvious using the knowledge we gained through all the previous example programs:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> velocity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep)</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">  velocity (.08),</div><div class="line">  present_time (present_time),</div><div class="line">  present_timestep (present_timestep)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;/ *p* /,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  values = 0;</div><div class="line">  values(2) = -present_timestep * velocity;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">                                                  value_list[p]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeTopLevelcodeclass"></a> </p><h3>Implementation of the <code>TopLevel</code> class</h3>
<p>Now for the implementation of the main class. First, we initialize the stress-strain tensor, which we have declared as a static const variable. We chose Lame constants that are appropriate for steel:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a></div><div class="line">TopLevel&lt;dim&gt;::stress_strain_tensor</div><div class="line">  = get_stress_strain_tensor&lt;dim&gt; (/ *lambda = * / 9.695e10,</div><div class="line">                                                 / *mu     = * / 7.617e10);</div></div><!-- fragment --><p><a class="anchor" id="Thepublicinterface"></a> </p><h4>The public interface</h4>
<p>The next step is the definition of constructors and destructors. There are no surprises here: we choose linear and continuous finite elements for each of the <code>dim</code> vector components of the solution, and a Gaussian quadrature formula with 2 points in each coordinate direction. The destructor should be obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TopLevel&lt;dim&gt;::TopLevel ()</div><div class="line">  :</div><div class="line">  triangulation(MPI_COMM_WORLD),</div><div class="line">  fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  quadrature_formula (2),</div><div class="line">  present_time (0.0),</div><div class="line">  present_timestep (1.0),</div><div class="line">  end_time (10.0),</div><div class="line">  timestep_no (0),</div><div class="line">  mpi_communicator (MPI_COMM_WORLD),</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">n_mpi_processes</a> (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">n_mpi_processes</a>(mpi_communicator)),</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator)),</div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> == 0),</div><div class="line">  n_local_cells (<a class="code" href="namespacenumbers.html">numbers</a>::invalid_unsigned_int)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TopLevel&lt;dim&gt;::~TopLevel ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">}</div></div><!-- fragment --><p>The last of the public functions is the one that directs all the work, <code>run()</code>. It initializes the variables that describe where in time we presently are, then runs the first time step, then loops over all the other time steps. Note that for simplicity we use a fixed time step, whereas a more sophisticated program would of course have to choose it in some more reasonable way adaptively:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  do_initial_timestep ();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (present_time &lt; end_time)</div><div class="line">    do_timestep ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelcreate_coarse_grid"></a> </p><h4>TopLevel::create_coarse_grid</h4>
<p>The next function in the order in which they were declared above is the one that creates the coarse grid from which we start. For this example program, we want to compute the deformation of a cylinder under axial compression. The first step therefore is to generate a mesh for a cylinder of length 3 and with inner and outer radii of 0.8 and 1, respectively. Fortunately, there is a library function for such a mesh.</p>
<p>In a second step, we have to associated boundary conditions with the upper and lower faces of the cylinder. We choose a boundary indicator of 0 for the boundary faces that are characterized by their midpoints having z-coordinates of either 0 (bottom face), an indicator of 1 for z=3 (top face); finally, we use boundary indicator 2 for all faces on the inside of the cylinder shell, and 3 for the outside.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::create_coarse_grid ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.8,</div><div class="line">               outer_radius = 1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">GridGenerator::cylinder_shell</a> (triangulation,</div><div class="line">                                 3, inner_radius, outer_radius);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell=triangulation.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell!=triangulation.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> face_center = cell-&gt;face(f)-&gt;center();</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (face_center[2] == 0)</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id (0);</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face_center[2] == 3)</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id (1);</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::sqrt(face_center[0]*face_center[0] +</div><div class="line">                             face_center[1]*face_center[1])</div><div class="line">                   &lt;</div><div class="line">                   (inner_radius + outer_radius) / 2)</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id (2);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id (3);</div><div class="line">        }</div></div><!-- fragment --><p>In order to make sure that new vertices are placed correctly on mesh refinement, we have to associate objects describing those parts of the boundary that do not consist of straight parts. Corresponding to the cylinder shell generator function used above, there are classes that can be used to describe the geometry of cylinders. The library implements both boundary classes as well as manifold classes, where also the interior part of mesh is refined according to the geometrical description. For this example, we use a single cylindrical manifold both for the interior part and for the boundary parts. Note that the manifold object need to live as long as the triangulation does; we can achieve this by making the objects static, which means that they live as long as the program runs:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;dim&gt;</a> cylindrical_manifold (2);</div></div><!-- fragment --><p>We tell the triangulation to reset all its manifold indicators to 0, and then attach the cylindrical manifold to it:</p>
<div class="fragment"><div class="line">triangulation.set_all_manifold_ids(0);</div><div class="line">triangulation.set_manifold (0, cylindrical_manifold);</div></div><!-- fragment --><p>Once all this is done, we can refine the mesh once globally:</p>
<div class="fragment"><div class="line">triangulation.refine_global (1);</div></div><!-- fragment --><p>As the final step, we need to set up a clean state of the data that we store in the quadrature points on all cells that are treated on the present processor.</p>
<div class="fragment"><div class="line">  setup_quadrature_point_history ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelsetup_system"></a> </p><h4>TopLevel::setup_system</h4>
<p>The next function is the one that sets up the data structures for a given mesh. This is done in most the same way as in <a class="el" href="step_17.html">step-17</a>: distribute the degrees of freedom, then sort these degrees of freedom in such a way that each processor gets a contiguous chunk of them. Note that subdivisions into chunks for each processor is handled in the functions that create or refine grids, unlike in the previous example program (the point where this happens is mostly a matter of taste; here, we chose to do it when grids are created since in the <code>do_initial_timestep</code> and <code>do_timestep</code> functions we want to output the number of cells on each processor at a point where we haven't called the present function yet).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler,locally_relevant_dofs);</div></div><!-- fragment --><p>The next thing is to store some information for later use on how many cells or degrees of freedom the present processor, or any of the processors has to work on. First the cells local to this processor...</p>
<div class="fragment"><div class="line">n_local_cells</div><div class="line">  = <a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a> (triangulation,</div><div class="line">                                                       triangulation.locally_owned_subdomain ());</div><div class="line"></div><div class="line">local_dofs_per_process = dof_handler.<a class="code" href="classDoFHandler.html#aff791a67d5a9383fb2ef05ea540b71e8">n_locally_owned_dofs_per_processor</a>();</div></div><!-- fragment --><p>The next step is to set up constraints due to hanging nodes. This has been handled many times before:</p>
<div class="fragment"><div class="line">hanging_node_constraints.clear ();</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                         hanging_node_constraints);</div><div class="line">hanging_node_constraints.close ();</div></div><!-- fragment --><p>And then we have to set up the matrix. Here we deviate from <a class="el" href="step_17.html">step-17</a>, in which we simply used PETSc's ability to just know about the size of the matrix and later allocate those nonzero elements that are being written to. While this works just fine from a correctness viewpoint, it is not at all efficient: if we don't give PETSc a clue as to which elements are written to, it is (at least at the time of this writing) unbearably slow when we set the elements in the matrix for the first time (i.e. in the first timestep). Later on, when the elements have been allocated, everything is much faster. In experiments we made, the first timestep can be accelerated by almost two orders of magnitude if we instruct PETSc which elements will be used and which are not.</p>
<p>To do so, we first generate the sparsity pattern of the matrix we are going to work with, and make sure that the condensation of hanging node constraints add the necessary additional entries in the sparsity pattern:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> sparsity_pattern (locally_relevant_dofs);</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div><div class="line">                                 hanging_node_constraints, / *keep constrained dofs* / <span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a> (sparsity_pattern,</div><div class="line">                                            local_dofs_per_process,</div><div class="line">                                            mpi_communicator,</div><div class="line">                                            locally_relevant_dofs);</div></div><!-- fragment --><p>Note that we have used the <code><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></code> class here that was already introduced in <a class="el" href="step_11.html">step-11</a>, rather than the <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code> class that we have used in all other cases. The reason for this is that for the latter class to work we have to give an initial upper bound for the number of entries in each row, a task that is traditionally done by <code><a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs()</a></code>. However, this function suffers from a serious problem: it has to compute an upper bound to the number of nonzero entries in each row, and this is a rather complicated task, in particular in 3d. In effect, while it is quite accurate in 2d, it often comes up with much too large a number in 3d, and in that case the <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code> allocates much too much memory at first, often several 100 MBs. This is later corrected when <code><a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a></code> is called and we realize that we don't need all that much memory, but at time it is already too late: for large problems, the temporary allocation of too much memory can lead to out-of-memory situations.</p>
<p>In order to avoid this, we resort to the <code><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></code> class that is slower but does not require any up-front estimate on the number of nonzero entries per row. It therefore only ever allocates as much memory as it needs at any given time, and we can build it even for large 3d problems.</p>
<p>It is also worth noting that due to the specifics of <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, the sparsity pattern we construct is global, i.e. comprises all degrees of freedom whether they will be owned by the processor we are on or another one (in case this program is run in parallel via MPI). This of course is not optimal &ndash; it limits the size of the problems we can solve, since storing the entire sparsity pattern (even if only for a short time) on each processor does not scale well. However, there are several more places in the program in which we do this, for example we always keep the global triangulation and DoF handler objects around, even if we only work on part of them. At present, deal.II does not have the necessary facilities to completely distribute these objects (a task that, indeed, is very hard to achieve with adaptive meshes, since well-balanced subdivisions of a domain tend to become unbalanced as the mesh is adaptively refined).</p>
<p>With this data structure, we can then go to the PETSc sparse matrix and tell it to preallocate all the entries we will later want to write to:</p>
<div class="fragment"><div class="line">system_matrix.reinit (locally_owned_dofs,</div><div class="line">                      locally_owned_dofs,</div><div class="line">                      sparsity_pattern,</div><div class="line">                      mpi_communicator);</div></div><!-- fragment --><p>After this point, no further explicit knowledge of the sparsity pattern is required any more and we can let the <code>sparsity_pattern</code> variable go out of scope without any problem.</p>
<p>The last task in this function is then only to reset the right hand side vector as well as the solution vector to its correct size; remember that the solution vector is a local one, unlike the right hand side that is a distributed parallel one and therefore needs to know the MPI communicator over which it is supposed to transmit messages:</p>
<div class="fragment"><div class="line">  system_rhs.reinit(locally_owned_dofs,mpi_communicator);</div><div class="line">  incremental_displacement.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelassemble_system"></a> </p><h4>TopLevel::assemble_system</h4>
<p>Again, assembling the system matrix and right hand side follows the same structure as in many example programs before. In particular, it is mostly equivalent to <a class="el" href="step_17.html">step-17</a>, except for the different right hand side that now only has to take into account internal stresses. In addition, assembling the matrix is made significantly more transparent by using the <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> class: note the elegance of forming the scalar products of symmetric tensors of rank 2 and 4. The implementation is also more general since it is independent of the fact that we may or may not be using an isotropic elasticity tensor.</p>
<p>The first part of the assembly routine is as always:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  system_rhs = 0;</div><div class="line">  system_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  BodyForce&lt;dim&gt;      body_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; body_force_values (n_q_points,</div><div class="line">                                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div></div><!-- fragment --><p>As in <a class="el" href="step_17.html">step-17</a>, we only need to loop over all cells that belong to the present processor:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a> = 0;</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div></div><!-- fragment --><p>Then loop over all indices i,j and quadrature points and assemble the system matrix contributions from this cell. Note how we extract the symmetric gradients (strains) of the shape functions at a given quadrature point from the <code><a class="el" href="classFEValues.html">FEValues</a></code> object, and the elegance with which we form the triple contraction <code>eps_phi_i : C : eps_phi_j</code>; the latter needs to be compared to the clumsy computations needed in <a class="el" href="step_17.html">step-17</a>, both in the introduction as well as in the respective place in the program:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points;</div><div class="line">         ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">        eps_phi_i = get_strain (fe_values, i, q_point),</div><div class="line">        eps_phi_j = get_strain (fe_values, j, q_point);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a>(i,j)</div><div class="line">        += (eps_phi_i * stress_strain_tensor * eps_phi_j</div><div class="line">            *</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line">      }</div></div><!-- fragment --><p>Then also assemble the local right hand side contributions. For this, we need to access the prior stress value in this quadrature point. To get it, we use the user pointer of this cell that points into the global array to the quadrature point data corresponding to the first quadrature point of the present cell, and then add an offset corresponding to the index of the quadrature point we presently consider:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> PointHistory&lt;dim&gt; *local_quadrature_points_data</div><div class="line">  = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div></div><!-- fragment --><p>In addition, we need the values of the external body forces at the quadrature points on this cell:</p>
<div class="fragment"><div class="line">body_force.vector_value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              body_force_values);</div></div><!-- fragment --><p>Then we can loop over all degrees of freedom on this cell and compute local contributions to the right hand side:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    component_i = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &amp;old_stress</div><div class="line">          = local_quadrature_points_data[q_point].old_stress;</div><div class="line"></div><div class="line">        cell_rhs(i) += (body_force_values[q_point](component_i) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i,q_point)</div><div class="line">                        -</div><div class="line">                        old_stress *</div><div class="line">                        get_strain (fe_values,i,q_point))</div><div class="line">                       *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Now that we have the local contributions to the linear system, we need to transfer it into the global objects. This is done exactly as in <a class="el" href="step_17.html">step-17</a>:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">  hanging_node_constraints</div><div class="line">  .distribute_local_to_global (cell_matrix, cell_rhs,</div><div class="line">                               local_dof_indices,</div><div class="line">                               system_matrix, system_rhs);</div><div class="line">}</div></div><!-- fragment --><p>Now compress the vector and the system matrix:</p>
<div class="fragment"><div class="line">system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>The last step is to again fix up boundary values, just as we already did in previous programs. A slight complication is that the <code>apply_boundary_values</code> function wants to have a solution vector compatible with the matrix and right hand side (i.e. here a distributed parallel vector, rather than the sequential vector we use in this program) in order to preset the entries of the solution vector with the correct boundary values. We provide such a compatible vector in the form of a temporary vector which we then copy into the sequential one.</p>
<p>We make up for this complication by showing how boundary values can be used flexibly: following the way we create the triangulation, there are three distinct boundary indicators used to describe the domain, corresponding to the bottom and top faces, as well as the inner/outer surfaces. We would like to impose boundary conditions of the following type: The inner and outer cylinder surfaces are free of external forces, a fact that corresponds to natural (Neumann-type) boundary conditions for which we don't have to do anything. At the bottom, we want no movement at all, corresponding to the cylinder being clamped or cemented in at this part of the boundary. At the top, however, we want a prescribed vertical downward motion compressing the cylinder; in addition, we only want to restrict the vertical movement, but not the horizontal ones &ndash; one can think of this situation as a well-greased plate sitting on top of the cylinder pushing it downwards: the atoms of the cylinder are forced to move downward, but they are free to slide horizontally along the plate.</p>
<p>The way to describe this is as follows: for boundary indicator zero (bottom face) we use a dim-dimensional zero function representing no motion in any coordinate direction. For the boundary with indicator 1 (top surface), we use the <code>IncrementalBoundaryValues</code> class, but we specify an additional argument to the <code><a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a></code> function denoting which vector components it should apply to; this is a vector of bools for each vector component and because we only want to restrict vertical motion, it has only its last component set:</p>
<div class="fragment"><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> z_component (dim-1);</div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::</a></div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">  interpolate_boundary_values</a> (dof_handler,</div><div class="line">                               0,</div><div class="line">                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a> (dim),</div><div class="line">                               boundary_values);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::</a></div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">  interpolate_boundary_values</a> (dof_handler,</div><div class="line">                               1,</div><div class="line">                               IncrementalBoundaryValues&lt;dim&gt;(present_time,</div><div class="line">                                                              present_timestep),</div><div class="line">                               boundary_values,</div><div class="line">                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_component));</div><div class="line"></div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> tmp (locally_owned_dofs,mpi_communicator);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix, tmp,</div><div class="line">                                      system_rhs, <span class="keyword">false</span>);</div><div class="line">  incremental_displacement = tmp;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelsolve_timestep"></a> </p><h4>TopLevel::solve_timestep</h4>
<p>The next function is the one that controls what all has to happen within a timestep. The order of things should be relatively self-explanatory from the function names:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::solve_timestep ()</div><div class="line">{</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Assembling system...&quot;</span> &lt;&lt; std::flush;</div><div class="line">  assemble_system ();</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot; norm of rhs is &quot;</span> &lt;&lt; system_rhs.l2_norm()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve_linear_problem ();</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Solver converged in &quot;</span> &lt;&lt; n_iterations</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Updating quadrature point data...&quot;</span> &lt;&lt; std::flush;</div><div class="line">  update_quadrature_point_history ();</div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelsolve_linear_problem"></a> </p><h4>TopLevel::solve_linear_problem</h4>
<p>Solving the linear system again works mostly as before. The only difference is that we want to only keep a complete local copy of the solution vector instead of the distributed one that we get as output from PETSc's solver routines. To this end, we declare a local temporary variable for the distributed vector and initialize it with the contents of the local variable (remember that the <code>apply_boundary_values</code> function called in <code>assemble_system</code> preset the values of boundary nodes in this vector), solve with it, and at the end of the function copy it again into the complete local vector that we declared as a member variable. Hanging node constraints are then distributed only on the local copy, i.e. independently of each other on each of the processors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TopLevel&lt;dim&gt;::solve_linear_problem ()</div><div class="line">{</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div><div class="line">  distributed_incremental_displacement (locally_owned_dofs,mpi_communicator);</div><div class="line">  distributed_incremental_displacement = incremental_displacement;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-16*system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> cg (solver_control,</div><div class="line">                              mpi_communicator);</div><div class="line"></div><div class="line">  <a class="code" href="classPETScWrappers_1_1PreconditionBlockJacobi.html">PETScWrappers::PreconditionBlockJacobi</a> preconditioner(system_matrix);</div><div class="line"></div><div class="line">  cg.solve (system_matrix, distributed_incremental_displacement, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">  incremental_displacement = distributed_incremental_displacement;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute (incremental_displacement);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLeveloutput_results"></a> </p><h4>TopLevel::output_results</h4>
<p>This function generates the graphical output in .vtu format as explained in the introduction. Each process will only work on the cells it owns, and then write the result into a file of its own. Additionally, processor 0 will write the record files the reference all the .vtu files.</p>
<p>The crucial part of this function is to give the <code><a class="el" href="classDataOut.html">DataOut</a></code> class a way to only work on the cells that the present process owns.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div></div><!-- fragment --><p>Then, just as in <a class="el" href="step_17.html">step-17</a>, define the names of solution variables (which here are the displacement increments) and queue the solution vector for output. Note in the following switch how we make sure that if the space dimension should be unhandled that we throw an exception saying that we haven't implemented this case yet (another case of defensive programming):</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line"><span class="keywordflow">switch</span> (dim)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> 1:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 2:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_y&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 3:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_y&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;delta_z&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (incremental_displacement,</div><div class="line">                          solution_names);</div></div><!-- fragment --><p>The next thing is that we wanted to output something like the average norm of the stresses that we have stored in each cell. This may seem complicated, since on the present processor we only store the stresses in quadrature points on those cells that actually belong to the present process. In other words, it seems as if we can't compute the average stresses for all cells. However, remember that our class derived from <code><a class="el" href="classDataOut.html">DataOut</a></code> only iterates over those cells that actually do belong to the present processor, i.e. we don't have to compute anything for all the other cells as this information would not be touched. The following little loop does this. We enclose the entire block into a pair of braces to make sure that the iterator variables do not remain accidentally visible beyond the end of the block in which they are used:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> norm_of_stress (triangulation.n_active_cells());</div><div class="line">{</div></div><!-- fragment --><p>Loop over all the cells...</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = triangulation.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = triangulation.end();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div></div><!-- fragment --><p>On these cells, add up the stresses over all quadrature points...</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> accumulated_stress;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0;</div><div class="line">     q&lt;quadrature_formula.size();</div><div class="line">     ++q)</div><div class="line">  accumulated_stress +=</div><div class="line">    <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer())[q]</div><div class="line">    .old_stress;</div></div><!-- fragment --><p>...then write the norm of the average to their destination:</p>
<div class="fragment"><div class="line">  norm_of_stress(cell-&gt;active_cell_index())</div><div class="line">    = (accumulated_stress /</div><div class="line">       quadrature_formula.size()).norm();</div><div class="line">}</div></div><!-- fragment --><p>And on the cells that we are not interested in, set the respective value in the vector to a bogus value (norms must be positive, and a large negative value should catch your eye) in order to make sure that if we were somehow wrong about our assumption that these elements would not appear in the output file, that we would find out by looking at the graphical output:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">else</span></div><div class="line">      norm_of_stress(cell-&gt;active_cell_index()) = -1e+20;</div><div class="line">}</div></div><!-- fragment --><p>Finally attach this vector as well to be treated for output:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (norm_of_stress, <span class="stringliteral">&quot;norm_of_stress&quot;</span>);</div></div><!-- fragment --><p>As a last piece of data, let us also add the partitioning of the domain into subdomains associated with the processors if this is a parallel job. This works in the exact same way as in the <a class="el" href="step_17.html">step-17</a> program:</p>
<div class="fragment"><div class="line">std::vector&lt;types::subdomain_id&gt; partition_int (triangulation.n_active_cells());</div><div class="line"><a class="code" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">GridTools::get_subdomain_association</a> (triangulation, partition_int);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> partitioning(partition_int.begin(),</div><div class="line">                                  partition_int.end());</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (partitioning, <span class="stringliteral">&quot;partitioning&quot;</span>);</div></div><!-- fragment --><p>Finally, with all this data, we can instruct deal.II to munge the information and produce some intermediate data structures that contain all these solution and other data vectors:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div></div><!-- fragment --><p>Let us determine the name of the file we will want to write it to. We compose it of the prefix <code>solution-</code>, followed by the time step number, and finally the processor id (encoded as a three digit number):</p>
<div class="fragment"><div class="line">std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4)</div><div class="line">                       + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(this_mpi_process,3)</div><div class="line">                       + <span class="stringliteral">&quot;.vtu&quot;</span>;</div></div><!-- fragment --><p>The following assertion makes sure that there are less than 1000 processes (a very conservative check, but worth having anyway) as our scheme of generating process numbers would overflow if there were 1000 processes or more. Note that we choose to use <code>AssertThrow</code> rather than <code>Assert</code> since the number of processes is a variable that depends on input files or the way the process is started, rather than static assumptions in the program code. Therefore, it is inappropriate to use <code>Assert</code> that is optimized away in optimized mode, whereas here we actually can assume that users will run the largest computations with the most processors in optimized mode, and we should check our assumptions in this particular case, and not only when running in debug mode:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (n_mpi_processes &lt; 1000, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>With the so-completed filename, let us open a file and write the data we have generated into it:</p>
<div class="fragment"><div class="line">std::ofstream output (filename.c_str());</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div></div><!-- fragment --><p>The record files must be written only once and not by each processor, so we do this on processor 0:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (this_mpi_process==0)</div><div class="line">  {</div></div><!-- fragment --><p>Here we collect all filenames of the current timestep (same format as above)</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; filenames;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">n_mpi_processes</a>; ++i)</div><div class="line">  filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4)</div><div class="line">                       + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i,3)</div><div class="line">                       + <span class="stringliteral">&quot;.vtu&quot;</span>);</div></div><!-- fragment --><p>Now we write the .visit file. The naming is similar to the .vtu files, only that the file obviously doesn't contain a processor id.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string</div><div class="line">visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4) +</div><div class="line">                         <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line"><a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div></div><!-- fragment --><p>Similarly, we write the paraview .pvtu:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string</div><div class="line">pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4) +</div><div class="line">                        <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (pvtu_master, filenames);</div></div><!-- fragment --><p>Finally, we write the paraview record, that references all .pvtu files and their respective time. Note that the variable times_and_names is declared static, so it will retain the entries from the pervious timesteps.</p>
<div class="fragment"><div class="line">      <span class="keyword">static</span> std::vector&lt;std::pair&lt;double,std::string&gt; &gt; times_and_names;</div><div class="line">      times_and_names.push_back (std::pair&lt;double,std::string&gt; (present_time, pvtu_master_filename));</div><div class="line">      std::ofstream pvd_output (<span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#a9bcaee76160be3f2cee5c15ca7976a26">DataOutBase::write_pvd_record</a> (pvd_output, times_and_names);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLeveldo_initial_timestep"></a> </p><h4>TopLevel::do_initial_timestep</h4>
<p>This and the next function handle the overall structure of the first and following timesteps, respectively. The first timestep is slightly more involved because we want to compute it multiple times on successively refined meshes, each time starting from a clean state. At the end of these computations, in which we compute the incremental displacements each time, we use the last results obtained for the incremental displacements to compute the resulting stress updates and move the mesh accordingly. On this new mesh, we then output the solution and any additional data we consider important.</p>
<p>All this is interspersed by generating output to the console to update the person watching the screen on what is going on. As in <a class="el" href="step_17.html">step-17</a>, the use of <code>pcout</code> instead of <code>std::cout</code> makes sure that only one of the parallel processes is actually writing to the console, without having to explicitly code an if-statement in each place where we generate output:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::do_initial_timestep ()</div><div class="line">{</div><div class="line">  present_time += present_timestep;</div><div class="line">  ++timestep_no;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_no &lt;&lt; <span class="stringliteral">&quot; at time &quot;</span> &lt;&lt; present_time</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;2; ++cycle)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        create_coarse_grid ();</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        refine_initial_grid ();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;    Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.n_active_cells()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div><div class="line">        pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div><div class="line">              &lt;&lt; (<a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::</a></div><div class="line"><a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">                  count_cells_with_subdomain_association</a> (triangulation,p));</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system ();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;    Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div><div class="line">        pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div><div class="line">              &lt;&lt; (<a class="code" href="namespaceDoFTools.html#a2dde9ded6d7cbc9962547356f37e5f72">DoFTools::</a></div><div class="line"><a class="code" href="namespaceDoFTools.html#a2dde9ded6d7cbc9962547356f37e5f72">                  count_dofs_with_subdomain_association</a> (dof_handler,p));</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      solve_timestep ();</div><div class="line">    }</div><div class="line"></div><div class="line">  move_mesh ();</div><div class="line">  output_results ();</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLeveldo_timestep"></a> </p><h4>TopLevel::do_timestep</h4>
<p>Subsequent timesteps are simpler, and probably do not require any more documentation given the explanations for the previous function above:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::do_timestep ()</div><div class="line">{</div><div class="line">  present_time += present_timestep;</div><div class="line">  ++timestep_no;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_no &lt;&lt; <span class="stringliteral">&quot; at time &quot;</span> &lt;&lt; present_time</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (present_time &gt; end_time)</div><div class="line">    {</div><div class="line">      present_timestep -= (present_time - end_time);</div><div class="line">      present_time = end_time;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  solve_timestep ();</div><div class="line"></div><div class="line">  move_mesh ();</div><div class="line">  output_results ();</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelrefine_initial_grid"></a> </p><h4>TopLevel::refine_initial_grid</h4>
<p>The following function is called when solving the first time step on successively refined meshes. After each iteration, it computes a refinement criterion, refines the mesh, and sets up the history variables in each quadrature point again to a clean state.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::refine_initial_grid ()</div><div class="line">{</div></div><!-- fragment --><p>First, let each process compute error indicators for the cells it owns:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell (triangulation.n_active_cells());</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(2),</div><div class="line">                                    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                    incremental_displacement,</div><div class="line">                                    error_per_cell,</div><div class="line">                                    <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                    <span class="keyword">nullptr</span>,</div><div class="line">                                    <a class="code" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(),</div><div class="line">                                    this_mpi_process);</div></div><!-- fragment --><p>Then set up a global vector into which we merge the local indicators from each of the parallel processes:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_cells = triangulation.n_locally_owned_active_cells ();</div><div class="line"></div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div><div class="line">distributed_error_per_cell (mpi_communicator,</div><div class="line">                            triangulation.n_active_cells(),</div><div class="line">                            n_local_cells);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;error_per_cell.size(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (error_per_cell(i) != 0)</div><div class="line">    distributed_error_per_cell(i) = error_per_cell(i);</div><div class="line">distributed_error_per_cell.compress (<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div></div><!-- fragment --><p>Once we have that, copy it back into local copies on all processors and refine the mesh accordingly:</p>
<div class="fragment"><div class="line">error_per_cell = distributed_error_per_cell;</div><div class="line"><a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                 error_per_cell,</div><div class="line">                                                 0.35, 0.03);</div><div class="line">triangulation.execute_coarsening_and_refinement ();</div></div><!-- fragment --><p>Finally, set up quadrature point data again on the new mesh, and only on those cells that we have determined to be ours:</p>
<div class="fragment"><div class="line">  setup_quadrature_point_history ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelmove_mesh"></a> </p><h4>TopLevel::move_mesh</h4>
<p>At the end of each time step, we move the nodes of the mesh according to the incremental displacements computed in this time step. To do this, we keep a vector of flags that indicate for each vertex whether we have already moved it around, and then loop over all cells and move those vertices of the cell that have not been moved yet. It is worth noting that it does not matter from which of the cells adjacent to a vertex we move this vertex: since we compute the displacement using a continuous finite element, the displacement field is continuous as well and we can compute the displacement of a given vertex from each of the adjacent cells. We only have to make sure that we move each node exactly once, which is why we keep the vector of flags.</p>
<p>There are two noteworthy things in this function. First, how we get the displacement field at a given vertex using the <code>cell-&gt;vertex_dof_index(v,d)</code> function that returns the index of the <code>d</code>th degree of freedom at vertex <code>v</code> of the given cell. In the present case, displacement in the k-th coordinate direction corresponds to the k-th component of the finite element. Using a function like this bears a certain risk, because it uses knowledge of the order of elements that we have taken together for this program in the <code><a class="el" href="classFESystem.html">FESystem</a></code> element. If we decided to add an additional variable, for example a pressure variable for stabilization, and happened to insert it as the first variable of the element, then the computation below will start to produce nonsensical results. In addition, this computation rests on other assumptions: first, that the element we use has, indeed, degrees of freedom that are associated with vertices. This is indeed the case for the present Q1 element, as would be for all Qp elements of polynomial order <code>p</code>. However, it would not hold for discontinuous elements, or elements for mixed formulations. Secondly, it also rests on the assumption that the displacement at a vertex is determined solely by the value of the degree of freedom associated with this vertex; in other words, all shape functions corresponding to other degrees of freedom are zero at this particular vertex. Again, this is the case for the present element, but is not so for all elements that are presently available in deal.II. Despite its risks, we choose to use this way in order to present a way to query individual degrees of freedom associated with vertices.</p>
<p>In this context, it is instructive to point out what a more general way would be. For general finite elements, the way to go would be to take a quadrature formula with the quadrature points in the vertices of a cell. The <code><a class="el" href="classQTrapez.html">QTrapez</a></code> formula for the trapezoidal rule does exactly this. With this quadrature formula, we would then initialize an <code><a class="el" href="classFEValues.html">FEValues</a></code> object in each cell, and use the <code><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a></code> function to obtain the values of the solution function in the quadrature points, i.e. the vertices of the cell. These are the only values that we really need, i.e. we are not at all interested in the weights (or the <code>JxW</code> values) associated with this particular quadrature formula, and this can be specified as the last argument in the constructor to <code><a class="el" href="classFEValues.html">FEValues</a></code>. The only point of minor inconvenience in this scheme is that we have to figure out which quadrature point corresponds to the vertex we consider at present, as they may or may not be ordered in the same order.</p>
<p>This inconvenience could be avoided if finite elements have support points on vertices (which the one here has; for the concept of support points, see <a class="el" href="DEALGlossary.html#GlossSupport">support points</a>). For such a case, one could construct a custom quadrature rule using <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a>. The first <code><a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_cell*fe.dofs_per_vertex</code> quadrature points will then correspond to the vertices of the cell and are ordered consistent with <code>cell-&gt;vertex(i)</code>, taking into account that support points for vector elements will be duplicated <code>fe.dofs_per_vertex</code> times.</p>
<p>Another point worth explaining about this short function is the way in which the triangulation class exports information about its vertices: through the <code><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices</a></code> function, it advertises how many vertices there are in the triangulation. Not all of them are actually in use all the time &ndash; some are left-overs from cells that have been coarsened previously and remain in existence since deal.II never changes the number of a vertex once it has come into existence, even if vertices with lower number go away. Secondly, the location returned by <code>cell-&gt;vertex(v)</code> is not only a read-only object of type <code><a class="el" href="classPoint.html">Point</a>&lt;dim&gt;</code>, but in fact a reference that can be written to. This allows to move around the nodes of a mesh with relative ease, but it is worth pointing out that it is the responsibility of an application program using this feature to make sure that the resulting cells are still useful, i.e. are not distorted so much that the cell is degenerated (indicated, for example, by negative Jacobians). Note that we do not have any provisions in this function to actually ensure this, we just have faith.</p>
<p>After this lengthy introduction, here are the full 20 or so lines of code:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::move_mesh ()</div><div class="line">{</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Moving mesh...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;bool&gt; vertex_touched (triangulation.n_vertices(),</div><div class="line">                                    <span class="keyword">false</span>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a> ();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">      <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">          <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            vertex_displacement[d]</div><div class="line">              = incremental_displacement(cell-&gt;vertex_dof_index(v,d));</div><div class="line"></div><div class="line">          cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelsetup_quadrature_point_history"></a> </p><h4>TopLevel::setup_quadrature_point_history</h4>
<p>At the beginning of our computations, we needed to set up initial values of the history variables, such as the existing stresses in the material, that we store in each quadrature point. As mentioned above, we use the <code>user_pointer</code> for this that is available in each cell.</p>
<p>To put this into larger perspective, we note that if we had previously available stresses in our model (which we assume do not exist for the purpose of this program), then we would need to interpolate the field of preexisting stresses to the quadrature points. Likewise, if we were to simulate elasto-plastic materials with hardening/softening, then we would have to store additional history variables like the present yield stress of the accumulated plastic strains in each quadrature points. Pre-existing hardening or weakening would then be implemented by interpolating these variables in the present function as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::setup_quadrature_point_history ()</div><div class="line">{</div></div><!-- fragment --><p>What we need to do here is to first count how many quadrature points are within the responsibility of this processor. This, of course, equals the number of cells that belong to this processor times the number of quadrature points our quadrature formula has on each cell.</p>
<p>For good measure, we also set all user pointers of all cells, whether ours of not, to the null pointer. This way, if we ever access the user pointer of a cell which we should not have accessed, a segmentation fault will let us know that this should not have happened:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> our_cells = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    ++our_cells;</div><div class="line"></div><div class="line">triangulation.clear_user_data();</div></div><!-- fragment --><p>Next, allocate as many quadrature objects as we need. Since the <code>resize</code> function does not actually shrink the amount of allocated memory if the requested new size is smaller than the old size, we resort to a trick to first free all memory, and then reallocate it: we declare an empty vector as a temporary variable and then swap the contents of the old vector and this temporary variable. This makes sure that the <code>quadrature_point_history</code> is now really empty, and we can let the temporary variable that now holds the previous contents of the vector go out of scope and be destroyed. In the next step. we can then re-allocate as many elements as we need, with the vector default-initializing the <code>PointHistory</code> objects, which includes setting the stress variables to zero.</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;PointHistory&lt;dim&gt; &gt; tmp;</div><div class="line">  tmp.swap (quadrature_point_history);</div><div class="line">}</div><div class="line">quadrature_point_history.resize (our_cells *</div><div class="line">                                 quadrature_formula.size());</div></div><!-- fragment --><p>Finally loop over all cells again and set the user pointers from the cells that belong to the present processor to point to the first quadrature point objects corresponding to this cell in the vector of such objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> history_index = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      cell-&gt;set_user_pointer (&amp;quadrature_point_history[history_index]);</div><div class="line">      history_index += quadrature_formula.size();</div><div class="line">    }</div></div><!-- fragment --><p>At the end, for good measure make sure that our count of elements was correct and that we have both used up all objects we allocated previously, and not point to any objects beyond the end of the vector. Such defensive programming strategies are always good checks to avoid accidental errors and to guard against future changes to this function that forget to update all uses of a variable at the same time. Recall that constructs using the <code>Assert</code> macro are optimized away in optimized mode, so do not affect the run time of optimized runs:</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (history_index == quadrature_point_history.size(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TopLevelupdate_quadrature_point_history"></a> </p><h4>TopLevel::update_quadrature_point_history</h4>
<p>At the end of each time step, we should have computed an incremental displacement update so that the material in its new configuration accommodates for the difference between the external body and boundary forces applied during this time step minus the forces exerted through preexisting internal stresses. In order to have the preexisting stresses available at the next time step, we therefore have to update the preexisting stresses with the stresses due to the incremental displacement computed during the present time step. Ideally, the resulting sum of internal stresses would exactly counter all external forces. Indeed, a simple experiment can make sure that this is so: if we choose boundary conditions and body forces to be time independent, then the forcing terms (the sum of external forces and internal stresses) should be exactly zero. If you make this experiment, you will realize from the output of the norm of the right hand side in each time step that this is almost the case: it is not exactly zero, since in the first time step the incremental displacement and stress updates were computed relative to the undeformed mesh, which was then deformed. In the second time step, we again compute displacement and stress updates, but this time in the deformed mesh &ndash; there, the resulting updates are very small but not quite zero. This can be iterated, and in each such iteration the residual, i.e. the norm of the right hand side vector, is reduced; if one makes this little experiment, one realizes that the norm of this residual decays exponentially with the number of iterations, and after an initial very rapid decline is reduced by roughly a factor of about 3.5 in each iteration (for one testcase I looked at, other testcases, and other numbers of unknowns change the factor, but not the exponential decay).</p>
<p>In a sense, this can then be considered as a quasi-timestepping scheme to resolve the nonlinear problem of solving large-deformation elasticity on a mesh that is moved along in a Lagrangian manner.</p>
<p>Another complication is that the existing (old) stresses are defined on the old mesh, which we will move around after updating the stresses. If this mesh update involves rotations of the cell, then we need to also rotate the updated stress, since it was computed relative to the coordinate system of the old cell.</p>
<p>Thus, what we need is the following: on each cell which the present processor owns, we need to extract the old stress from the data stored with each quadrature point, compute the stress update, add the two together, and then rotate the result together with the incremental rotation computed from the incremental displacement at the present quadrature point. We will detail these steps below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TopLevel&lt;dim&gt;::update_quadrature_point_history ()</div><div class="line">{</div></div><!-- fragment --><p>First, set up an <code><a class="el" href="classFEValues.html">FEValues</a></code> object by which we will evaluate the incremental displacements and the gradients thereof at the quadrature points, together with a vector that will hold this information:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt;</div><div class="line">displacement_increment_grads (quadrature_formula.size(),</div><div class="line">                              std::vector&lt;Tensor&lt;1,dim&gt; &gt;(dim));</div></div><!-- fragment --><p>Then loop over all cells and do the job in the cells that belong to our subdomain:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div></div><!-- fragment --><p>Next, get a pointer to the quadrature point history data local to the present cell, and, as a defensive measure, make sure that this pointer is within the bounds of the global array:</p>
<div class="fragment"><div class="line">PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">  = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">        &amp;quadrature_point_history.front(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">        &amp;quadrature_point_history.back(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then initialize the <code><a class="el" href="classFEValues.html">FEValues</a></code> object on the present cell, and extract the gradients of the displacement at the quadrature points for later computation of the strains</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a> (incremental_displacement,</div><div class="line">                                  displacement_increment_grads);</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.size(); ++q)</div><div class="line">  {</div></div><!-- fragment --><p>On each quadrature point, compute the strain increment from the gradients, and multiply it by the stress-strain tensor to get the stress update. Then add this update to the already existing strain at this point:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> new_stress</div><div class="line">  = (local_quadrature_points_history[q].old_stress</div><div class="line">     +</div><div class="line">     (stress_strain_tensor *</div><div class="line">      get_strain (displacement_increment_grads[q])));</div></div><!-- fragment --><p>Finally, we have to rotate the result. For this, we first have to compute a rotation matrix at the present quadrature point from the incremental displacements. In fact, it can be computed from the gradients, and we already have a function for that purpose:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> rotation</div><div class="line">  = get_rotation_matrix (displacement_increment_grads[q]);</div></div><!-- fragment --><p>Note that the result, a rotation matrix, is in general an antisymmetric tensor of rank 2, so we must store it as a full tensor.</p>
<p>With this rotation matrix, we can compute the rotated tensor by contraction from the left and right, after we expand the symmetric tensor <code>new_stress</code> into a full tensor:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> rotated_new_stress</div><div class="line">  = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(<a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(rotation) *</div><div class="line">               <span class="keyword">static_cast&lt;</span><a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> <span class="keyword">&gt;</span>(new_stress) *</div><div class="line">               rotation);</div></div><!-- fragment --><p>Note that while the result of the multiplication of these three matrices should be symmetric, it is not due to floating point round off: we get an asymmetry on the order of 1e-16 of the off-diagonal elements of the result. When assigning the result to a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code>, the constructor of that class checks the symmetry and realizes that it isn't exactly symmetric; it will then raise an exception. To avoid that, we explicitly symmetrize the result to make it exactly symmetric.</p>
<p>The result of all these operations is then written back into the original place:</p>
<div class="fragment"><div class="line">            local_quadrature_points_history[q].old_stress</div><div class="line">              = rotated_new_stress;</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p>This ends the project specific namespace <code>Step18</code>. The rest is as usual and as already shown in <a class="el" href="step_17.html">step-17</a>: A <code>main()</code> function that initializes and terminates PETSc, calls the classes that do the actual work, and makes sure that we catch all exceptions that propagate up to this point:</p>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step18;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      TopLevel&lt;3&gt; elastic_problem;</div><div class="line">      elastic_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program takes a good while if one uses debug mode; it takes about eleven minutes on my i7 desktop. Fortunately, the version compiled with optimizations is much faster; the program only takes about a minute and a half after recompiling with the command <code>make release</code> on the same machine, a much more reasonable time.</p>
<p>If run, the program prints the following output, explaining what it is doing during all that time: </p><pre class="fragment">$ time make run
[ 66%] Built target step-18
[100%] Run step-18 with Release configuration
Timestep 1 at time 1
  Cycle 0:
    Number of active cells:       3712 (by partition: 3712)
    Number of degrees of freedom: 17226 (by partition: 17226)
    Assembling system... norm of rhs is 1.88062e+10
    Solver converged in 103 iterations.
    Updating quadrature point data...
  Cycle 1:
    Number of active cells:       12812 (by partition: 12812)
    Number of degrees of freedom: 51738 (by partition: 51738)
    Assembling system... norm of rhs is 1.86145e+10
    Solver converged in 121 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 2 at time 2
    Assembling system... norm of rhs is 1.84169e+10
    Solver converged in 122 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 3 at time 3
    Assembling system... norm of rhs is 1.82355e+10
    Solver converged in 122 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 4 at time 4
    Assembling system... norm of rhs is 1.80728e+10
    Solver converged in 117 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 5 at time 5
    Assembling system... norm of rhs is 1.79318e+10
    Solver converged in 116 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 6 at time 6
    Assembling system... norm of rhs is 1.78171e+10
    Solver converged in 115 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 7 at time 7
    Assembling system... norm of rhs is 1.7737e+10
    Solver converged in 112 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 8 at time 8
    Assembling system... norm of rhs is 1.77127e+10
    Solver converged in 111 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 9 at time 9
    Assembling system... norm of rhs is 1.78207e+10
    Solver converged in 113 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 10 at time 10
    Assembling system... norm of rhs is 1.83544e+10
    Solver converged in 115 iterations.
    Updating quadrature point data...
    Moving mesh...

[100%] Built target run
make run  176.82s user 0.15s system 198% cpu 1:28.94 total
</pre><p> In other words, it is computing on 12,000 cells and with some 52,000 unknowns. Not a whole lot, but enough for a coupled three-dimensional problem to keep a computer busy for a while. At the end of the day, this is what we have for output: </p><pre class="fragment">$ ls -l *vtu *visit
-rw-r--r-- 1 drwells users 1706059 Feb 13 19:36 solution-0010.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:36 solution-0010.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:36 solution-0010.visit
-rw-r--r-- 1 drwells users 1707907 Feb 13 19:36 solution-0009.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:36 solution-0009.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:36 solution-0009.visit
-rw-r--r-- 1 drwells users 1703771 Feb 13 19:35 solution-0008.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0008.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0008.visit
-rw-r--r-- 1 drwells users 1693671 Feb 13 19:35 solution-0007.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0007.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0007.visit
-rw-r--r-- 1 drwells users 1681847 Feb 13 19:35 solution-0006.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0006.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0006.visit
-rw-r--r-- 1 drwells users 1670115 Feb 13 19:35 solution-0005.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0005.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0005.visit
-rw-r--r-- 1 drwells users 1658559 Feb 13 19:35 solution-0004.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0004.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0004.visit
-rw-r--r-- 1 drwells users 1639983 Feb 13 19:35 solution-0003.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0003.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0003.visit
-rw-r--r-- 1 drwells users 1625851 Feb 13 19:35 solution-0002.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:35 solution-0002.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:35 solution-0002.visit
-rw-r--r-- 1 drwells users 1616035 Feb 13 19:34 solution-0001.000.vtu
-rw-r--r-- 1 drwells users     761 Feb 13 19:34 solution-0001.pvtu
-rw-r--r-- 1 drwells users      33 Feb 13 19:34 solution-0001.visit
</pre><p>If we visualize these files with VisIt or Paraview, we get to see the full picture of the disaster our forced compression wreaks on the cylinder (colors in the images encode the norm of the stress in the material):</p>
<table width="100%">
<tr width="100%">
<td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0002.0000.png"/>
</div>
<p> Time = 2 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0005.0000.png"/>
</div>
<p> Time = 5 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0007.0000.png"/>
</div>
<p> Time = 7  </p>
<p class="endtd"></p>
</td></tr>
<tr width="100%">
<td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0008.0000.png"/>
</div>
<p> Time = 8 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0009.0000.png"/>
</div>
<p> Time = 9 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.sequential-0010.0000.png"/>
</div>
 Time = 10   </td></tr>
</table>
<p>As is clearly visible, as we keep compressing the cylinder, it starts to bow out near the fully constrained bottom surface and, after about eight time units, buckle in an azimuthally symmetric manner.</p>
<p>Although the result appears plausible for the symmetric geometry and loading, it is yet to be established whether or not the computation is fully converged. In order to see whether it is, we ran the program again with one more global refinement at the beginning and with the time step halved. This would have taken a very long time on a single machine, so we used a proper workstation and ran it on 16 processors in parallel. The beginning of the output now looks like this: </p><pre class="fragment">Timestep 1 at time 0.5
  Cycle 0:
    Number of active cells:       29696 (by partition: 1808+1802+1894+1881+1870+1840+1884+1810+1876+1818+1870+1884+1854+1903+1816+1886)
    Number of degrees of freedom: 113100 (by partition: 6936+6930+7305+7116+7326+6869+7331+6786+7193+6829+7093+7162+6920+7280+6843+7181)
    Assembling system... norm of rhs is 1.10765e+10
    Solver converged in 209 iterations.
    Updating quadrature point data...
  Cycle 1:
    Number of active cells:       102034 (by partition: 6387+6202+6421+6341+6408+6201+6428+6428+6385+6294+6506+6244+6417+6527+6299+6546)
    Number of degrees of freedom: 359337 (by partition: 23255+21308+24774+24019+22304+21415+22430+22184+22298+21796+22396+21592+22325+22553+21977+22711)
    Assembling system... norm of rhs is 1.35759e+10
    Solver converged in 268 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 2 at time 1
    Assembling system... norm of rhs is 1.34674e+10
    Solver converged in 267 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 3 at time 1.5
    Assembling system... norm of rhs is 1.33607e+10
    Solver converged in 265 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 4 at time 2
    Assembling system... norm of rhs is 1.32558e+10
    Solver converged in 263 iterations.
    Updating quadrature point data...
    Moving mesh...

[...]

Timestep 20 at time 10
    Assembling system... norm of rhs is 1.47755e+10
    Solver converged in 425 iterations.
    Updating quadrature point data...
    Moving mesh...
</pre><p> That's quite a good number of unknowns, given that we are in 3d. The output of this program are 16 files for each time step: </p><pre class="fragment">$ ls -l solution-0001*
-rw-r--r-- 1 wellsd2 user 761065 Feb 13 21:09 solution-0001.000.vtu
-rw-r--r-- 1 wellsd2 user 759277 Feb 13 21:09 solution-0001.001.vtu
-rw-r--r-- 1 wellsd2 user 761217 Feb 13 21:09 solution-0001.002.vtu
-rw-r--r-- 1 wellsd2 user 761605 Feb 13 21:09 solution-0001.003.vtu
-rw-r--r-- 1 wellsd2 user 756917 Feb 13 21:09 solution-0001.004.vtu
-rw-r--r-- 1 wellsd2 user 752669 Feb 13 21:09 solution-0001.005.vtu
-rw-r--r-- 1 wellsd2 user 735217 Feb 13 21:09 solution-0001.006.vtu
-rw-r--r-- 1 wellsd2 user 750065 Feb 13 21:09 solution-0001.007.vtu
-rw-r--r-- 1 wellsd2 user 760273 Feb 13 21:09 solution-0001.008.vtu
-rw-r--r-- 1 wellsd2 user 777265 Feb 13 21:09 solution-0001.009.vtu
-rw-r--r-- 1 wellsd2 user 772469 Feb 13 21:09 solution-0001.010.vtu
-rw-r--r-- 1 wellsd2 user 760833 Feb 13 21:09 solution-0001.011.vtu
-rw-r--r-- 1 wellsd2 user 782241 Feb 13 21:09 solution-0001.012.vtu
-rw-r--r-- 1 wellsd2 user 748905 Feb 13 21:09 solution-0001.013.vtu
-rw-r--r-- 1 wellsd2 user 738413 Feb 13 21:09 solution-0001.014.vtu
-rw-r--r-- 1 wellsd2 user 762133 Feb 13 21:09 solution-0001.015.vtu
-rw-r--r-- 1 wellsd2 user   1421 Feb 13 21:09 solution-0001.pvtu
-rw-r--r-- 1 wellsd2 user    364 Feb 13 21:09 solution-0001.visit
</pre><p>Here are first the mesh on which we compute as well as the partitioning for the 16 processors:</p>
<table width="100%">
<tr width="100%">
<td width="49%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-000mesh.png"/>
</div>
 <p class="endtd"></p>
</td><td width="49%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0002.p.png"/>
</div>
   </td></tr>
</table>
<p>Finally, here is the same output as we have shown before for the much smaller sequential case:</p>
<table width="100%">
<tr width="100%">
<td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0002.s.png"/>
</div>
<p> Time = 2 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0005.s.png"/>
</div>
<p> Time = 5 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0007.s.png"/>
</div>
<p> Time = 7  </p>
<p class="endtd"></p>
</td></tr>
<tr width="100%">
<td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0008.s.png"/>
</div>
<p> Time = 8 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0009.s.png"/>
</div>
<p> Time = 9 </p>
<p class="endtd"></p>
</td><td width="33%"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-18.parallel-0010.s.png"/>
</div>
 Time = 10   </td></tr>
</table>
<p>As before, we observe that at high axial compression the cylinder begins to buckle, but this time ultimately collapses on itself. In contrast to our first run, towards the end of the simulation the deflection pattern becomes nonsymmetric (the central bulge deflects laterally). The model clearly does not provide for this (all our forces and boundary deflections are symmetric) but the effect is probably physically correct anyway: in reality, small inhomogeneities in the body's material properties would lead it to buckle to one side to evade the forcing; in numerical simulations, small perturbations such as numerical round-off or an inexact solution of a linear system by an iterative solver could have the same effect. Another typical source for asymmetries in adaptive computations is that only a certain fraction of cells is refined in each step, which may lead to asymmetric meshes even if the original coarse mesh was symmetric.</p>
<p>If one compares this with the previous run, the results both qualitatively and quantitatively different. The previous computation was therefore certainly not converged, though we can't say for sure anything about the present one. One would need an even finer computation to find out. However, the point may be moot: looking at the last picture in detail, it is pretty obvious that not only is the linear small deformation model we chose completely inadequate, but for a realistic simulation we would also need to make sure that the body does not intersect itself during deformation (if we continued compressing the cylinder we would observe some self-intersection). Without such a formulation we cannot expect anything to make physical sense, even if it produces nice pictures!</p>
<p><a class="anchor" id="Possibledirectionsforextensions"></a></p><h3>Possible directions for extensions</h3>
<p>The program as is does not really solve an equation that has many applications in practice: quasi-static material deformation based on a purely elastic law is almost boring. However, the program may serve as the starting point for more interesting experiments, and that indeed was the initial motivation for writing it. Here are some suggestions of what the program is missing and in what direction it may be extended:</p>
<p><a class="anchor" id="Plasticitymodels"></a></p><h5>Plasticity models</h5>
<p>The most obvious extension is to use a more realistic material model for large-scale quasistatic deformation. The natural choice for this would be plasticity, in which a nonlinear relationship between stress and strain replaces equation <a href="#step_18.stress-strain">[stress-strain]</a>. Plasticity models are usually rather complicated to program since the stress-strain dependence is generally non-smooth. The material can be thought of being able to withstand only a maximal stress (the yield stress) after which it starts to &ldquo;flow&rdquo;. A mathematical description to this can be given in the form of a variational inequality, which alternatively can be treated as minimizing the elastic energy </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E(\mathbf{u}) = (\varepsilon(\mathbf{u}), C\varepsilon(\mathbf{u}))_{\Omega} - (\mathbf{f}, \mathbf{u})_{\Omega} - (\mathbf{b}, \mathbf{u})_{\Gamma_N}, \]" src="form_1651.png"/>
</p>
<p> subject to the constraint </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(\sigma(\mathbf{u})) \le 0 \]" src="form_1652.png"/>
</p>
<p> on the stress. This extension makes the problem to be solved in each time step nonlinear, so we need another loop within each time step.</p>
<p>Without going into further details of this model, we refer to the excellent book by Simo and Hughes on &ldquo;Computational Inelasticity&rdquo; for a comprehensive overview of computational strategies for solving plastic models. Alternatively, a brief but concise description of an algorithm for plasticity is given in an article by S. Commend, A. Truty, and Th. Zimmermann, titled &ldquo;Stabilized finite elements applied to elastoplasticity: I. Mixed displacement-pressure formulation&rdquo; (Computer Methods in Applied Mechanics and Engineering, vol. 193, pp. 3559-3586, 2004).</p>
<p><a class="anchor" id="Stabilizationissues"></a></p><h5>Stabilization issues</h5>
<p>The formulation we have chosen, i.e. using piecewise (bi-, tri-)linear elements for all components of the displacement vector, and treating the stress as a variable dependent on the displacement is appropriate for most materials. However, this so-called displacement-based formulation becomes unstable and exhibits spurious modes for incompressible or nearly-incompressible materials. While fluids are usually not elastic (in most cases, the stress depends on velocity gradients, not displacement gradients, although there are exceptions such as electro-rheologic fluids), there are a few solids that are nearly incompressible, for example rubber. Another case is that many plasticity models ultimately let the material become incompressible, although this is outside the scope of the present program.</p>
<p>Incompressibility is characterized by Poisson's ratio </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nu = \frac{\lambda}{2(\lambda+\mu)}, \]" src="form_1653.png"/>
</p>
<p> where <img class="formulaInl" alt="$\lambda,\mu$" src="form_222.png"/> are the Lam\'e constants of the material. Physical constraints indicate that <img class="formulaInl" alt="$-1\le \nu\le \frac 12$" src="form_1654.png"/> (the condition also follows from mathematical stability considerations). If <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> approaches <img class="formulaInl" alt="$\frac 12$" src="form_1656.png"/>, then the material becomes incompressible. In that case, pure displacement-based formulations are no longer appropriate for the solution of such problems, and stabilization techniques have to be employed for a stable and accurate solution. The book and paper cited above give indications as to how to do this, but there is also a large volume of literature on this subject; a good start to get an overview of the topic can be found in the references of the paper by H.-Y. Duan and Q. Lin on &ldquo;Mixed finite elements of least-squares type for elasticity&rdquo; (Computer Methods in Applied Mechanics and Engineering, vol. 194, pp. 1093-1112, 2005).</p>
<p><a class="anchor" id="Refinementduringtimesteps"></a></p><h5>Refinement during timesteps</h5>
<p>In the present form, the program only refines the initial mesh a number of times, but then never again. For any kind of realistic simulation, one would want to extend this so that the mesh is refined and coarsened every few time steps instead. This is not hard to do, in fact, but has been left for future tutorial programs or as an exercise, if you wish.</p>
<p>The main complication one has to overcome is that one has to transfer the data that is stored in the quadrature points of the cells of the old mesh to the new mesh, preferably by some sort of projection scheme. The general approach to this would go like this:</p>
<ul>
<li>At the beginning, the data is only available in the quadrature points of individual cells, not as a finite element field that is defined everywhere.</li>
<li>So let us find a finite element field that <em>is</em> defined everywhere so that we can later interpolate it to the quadrature points of the new mesh. In general, it will be difficult to find a continuous finite element field that matches the values in the quadrature points exactly because the number of degrees of freedom of these fields does not match the number of quadrature points there are, and the nodal values of this global field will either be over- or underdetermined. But it is usually not very difficult to find a discontinuous field that matches the values in the quadrature points; for example, if you have a <a class="el" href="classQGauss.html">QGauss(2)</a> quadrature formula (i.e. 4 points per cell in 2d, 8 points in 3d), then one would use a finite element of kind <a class="el" href="classFE__DGQ.html">FE_DGQ(1)</a>, i.e. bi-/tri-linear functions as these have 4 degrees of freedom per cell in 2d and 8 in 3d.</li>
<li>There are functions that can make this conversion from individual points to a global field simpler. The following piece of pseudo-code should help if you use a <a class="el" href="classQGauss.html">QGauss(2)</a> quadrature formula. Note that the multiplication by the projection matrix below takes a vector of scalar components, i.e., we can only convert one set of scalars at a time from the quadrature points to the degrees of freedom and vice versa. So we need to store each component of stress separately, which requires <code>dim*dim</code> vectors. We'll store this set of vectors in a 2D array to make it easier to read off components in the same way you would the stress tensor. Thus, we'll loop over the components of stress on each cell and store these values in the global history field. (The prefix <code>history_</code> indicates that we work with quantities related to the history variables defined in the quadrature points.) <div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>     history_fe (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> history_dof_handler (triangulation);</div><div class="line">history_dof_handler.distribute_dofs (history_fe);</div><div class="line"></div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">             history_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">             local_history_values_at_qpoints (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">             local_history_fe_values (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">  {</div><div class="line">    history_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">    local_history_values_at_qpoints[i][j].reinit(quadrature.size());</div><div class="line">    local_history_fe_values[i][j].reinit(history_fe.dofs_per_cell);</div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> qpoint_to_dof_matrix (history_fe.dofs_per_cell,</div><div class="line">                                         quadrature.size());</div><div class="line"><a class="code" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a></div><div class="line">          (history_fe,</div><div class="line">           quadrature, quadrature,</div><div class="line">           qpoint_to_dof_matrix);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                               endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                               dg_cell = history_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell)</div><div class="line">  {</div><div class="line"></div><div class="line">    PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">           = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">                &amp;quadrature_point_history.front(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">                &amp;quadrature_point_history.back(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature.size(); ++q)</div><div class="line">          local_history_values_at_qpoints[i][j](q)</div><div class="line">                   = local_quadrature_points_history[q].old_stress[i][j];</div><div class="line"></div><div class="line">        qpoint_to_dof_matrix.vmult (local_history_fe_values[i][j],</div><div class="line">                                    local_history_values_at_qpoints[i][j]);</div><div class="line"></div><div class="line">        dg_cell-&gt;set_dof_values (local_history_fe_values[i][j],</div><div class="line">                                 history_field[i][j]);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --></li>
<li>Now that we have a global field, we can refine the mesh and transfer the history_field vector as usual using the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class. This will interpolate everything from the old to the new mesh.</li>
<li>In a final step, we have to get the data back from the now interpolated global field to the quadrature points on the new mesh. The following code will do that: <div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dof_to_qpoint_matrix (quadrature.size(),</div><div class="line">                                         history_fe.dofs_per_cell);</div><div class="line"><a class="code" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></div><div class="line">          (history_fe,</div><div class="line">           quadrature,</div><div class="line">           dof_to_qpoint_matrix);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                               endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                               dg_cell = history_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++dg_cell)</div><div class="line">{</div><div class="line">  PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">         = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">              &amp;quadrature_point_history.front(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">              &amp;quadrature_point_history.back(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      dg_cell-&gt;get_dof_values (history_field[i][j],</div><div class="line">                               local_history_fe_values[i][j]);</div><div class="line"></div><div class="line">      dof_to_qpoint_matrix.vmult (local_history_values_at_qpoints[i][j],</div><div class="line">                                  local_history_fe_values[i][j]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature.size(); ++q)</div><div class="line">        local_quadrature_points_history[q].old_stress[i][j]</div><div class="line">                   = local_history_values_at_qpoints[i][j](q);</div><div class="line">  }</div></div><!-- fragment --></li>
</ul>
<p>It becomes a bit more complicated once we run the program in parallel, since then each process only stores this data for the cells it owned on the old mesh. That said, using a parallel vector for <code>history_field</code> will do the trick if you put a call to <code>compress</code> after the transfer from quadrature points into the global vector.</p>
<p><a class="anchor" id="Ensuringmeshregularity"></a></p><h5>Ensuring mesh regularity</h5>
<p>At present, the program makes no attempt to make sure that a cell, after moving its vertices at the end of the time step, still has a valid geometry (i.e. that its Jacobian determinant is positive and bounded away from zero everywhere). It is, in fact, not very hard to set boundary values and forcing terms in such a way that one gets distorted and inverted cells rather quickly. Certainly, in some cases of large deformation, this is unavoidable with a mesh of finite mesh size, but in some other cases this should be preventable by appropriate mesh refinement and/or a reduction of the time step size. The program does not do that, but a more sophisticated version definitely should employ some sort of heuristic defining what amount of deformation of cells is acceptable, and what isn't. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2000 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004, 2005,</span></div><div class="line"><span class="comment"> * Timo Heister, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/multithread_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/shared_tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/filtered_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/transformations.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step18</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>PointHistory</div><div class="line">  {</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> old_stress;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a></div><div class="line">  get_stress_strain_tensor (<span class="keyword">const</span> <span class="keywordtype">double</span> lambda, <span class="keyword">const</span> <span class="keywordtype">double</span> mu)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a> tmp;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; ++j)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dim; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">            tmp[i][j][k][l] = (((i==k) &amp;&amp; (j==l) ? mu : 0.0) +</div><div class="line">                               ((i==l) &amp;&amp; (j==k) ? mu : 0.0) +</div><div class="line">                               ((i==j) &amp;&amp; (k==l) ? lambda : 0.0));</div><div class="line">    <span class="keywordflow">return</span> tmp;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">inline</span></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">  get_strain (<span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   shape_func,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   q_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> tmp;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      tmp[i][i] = fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,i)[i];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;dim; ++j)</div><div class="line">        tmp[i][j]</div><div class="line">          = (fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,i)[j] +</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (shape_func,q_point,j)[i]) / 2;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> tmp;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">inline</span></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">  get_strain (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;grad)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (grad.size() == dim, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      strain[i][i] = grad[i][i];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;dim; ++j)</div><div class="line">        strain[i][j] = (grad[i][j] + grad[j][i]) / 2;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> strain;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2,2&gt;</a></div><div class="line">  get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,2&gt;</a> &gt; &amp;grad_u)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> curl = (grad_u[1][0] - grad_u[0][1]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (curl);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Transformations_1_1Rotations.html#a1282052109c63a92db123927b5a6b603">Physics::Transformations::Rotations::rotation_matrix_2d</a>(-angle);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a></div><div class="line">  get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,3&gt;</a> &gt; &amp;grad_u)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> curl (grad_u[2][1] - grad_u[1][2],</div><div class="line">                         grad_u[0][2] - grad_u[2][0],</div><div class="line">                         grad_u[1][0] - grad_u[0][1]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tan_angle = std::sqrt(curl*curl);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (tan_angle);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (std::abs(angle) &lt; 1e-9)</div><div class="line">      {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> rotation[3][3]</div><div class="line">        = {{ 1, 0, 0}, { 0, 1, 0 }, { 0, 0, 1 } };</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a> rot(rotation);</div><div class="line">        <span class="keywordflow">return</span> rot;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> axis = curl/tan_angle;</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Transformations_1_1Rotations.html#a37f1cae34605889569d4e56b42658f63">Physics::Transformations::Rotations::rotation_matrix_3d</a>(axis, -angle);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TopLevel</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TopLevel ();</div><div class="line">    ~TopLevel ();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> create_coarse_grid ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve_timestep ();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve_linear_problem ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> do_initial_timestep ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> do_timestep ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_initial_grid ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> move_mesh ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_quadrature_point_history ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> update_quadrature_point_history ();</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     hanging_node_constraints;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula;</div><div class="line"></div><div class="line">    std::vector&lt;PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>       system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                   incremental_displacement;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       present_time;</div><div class="line">    <span class="keywordtype">double</span>       present_timestep;</div><div class="line">    <span class="keywordtype">double</span>       end_time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_no;</div><div class="line"></div><div class="line">    MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_mpi_processes;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dofs_per_process;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_local_cells;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a> stress_strain_tensor;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BodyForce ();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                       std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BodyForce&lt;dim&gt;::BodyForce ()</div><div class="line">    :</div><div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">inline</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BodyForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> g   = 9.81;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> rho = 7700;</div><div class="line"></div><div class="line">    values = 0;</div><div class="line">    values(dim-1) = -rho * g;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BodyForce&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">      BodyForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">                                    value_list[p]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                       std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> velocity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> present_time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep)</div><div class="line">    :</div><div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">    velocity (.08),</div><div class="line">    present_time (present_time),</div><div class="line">    present_timestep (present_timestep)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">  vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<span class="comment">/*p*/</span>,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">    values = 0;</div><div class="line">    values(2) = -present_timestep * velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">  vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">      IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">                                                    value_list[p]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a></div><div class="line">  TopLevel&lt;dim&gt;::stress_strain_tensor</div><div class="line">    = get_stress_strain_tensor&lt;dim&gt; (<span class="comment">/*lambda = */</span> 9.695e10,</div><div class="line">                                                   <span class="comment">/*mu     = */</span> 7.617e10);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TopLevel&lt;dim&gt;::TopLevel ()</div><div class="line">    :</div><div class="line">    triangulation(MPI_COMM_WORLD),</div><div class="line">    fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    quadrature_formula (2),</div><div class="line">    present_time (0.0),</div><div class="line">    present_timestep (1.0),</div><div class="line">    end_time (10.0),</div><div class="line">    timestep_no (0),</div><div class="line">    mpi_communicator (MPI_COMM_WORLD),</div><div class="line">    n_mpi_processes (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::n_mpi_processes(mpi_communicator)),</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator)),</div><div class="line">    pcout (<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> == 0),</div><div class="line">    n_local_cells (<a class="code" href="namespacenumbers.html">numbers</a>::invalid_unsigned_int)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TopLevel&lt;dim&gt;::~TopLevel ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    do_initial_timestep ();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (present_time &lt; end_time)</div><div class="line">      do_timestep ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::create_coarse_grid ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.8,</div><div class="line">                 outer_radius = 1;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">GridGenerator::cylinder_shell</a> (triangulation,</div><div class="line">                                   3, inner_radius, outer_radius);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell=triangulation.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell!=triangulation.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> face_center = cell-&gt;face(f)-&gt;center();</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face_center[2] == 0)</div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id (0);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face_center[2] == 3)</div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id (1);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::sqrt(face_center[0]*face_center[0] +</div><div class="line">                               face_center[1]*face_center[1])</div><div class="line">                     &lt;</div><div class="line">                     (inner_radius + outer_radius) / 2)</div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id (2);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id (3);</div><div class="line">          }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;dim&gt;</a> cylindrical_manifold (2);</div><div class="line"></div><div class="line">    triangulation.set_all_manifold_ids(0);</div><div class="line">    triangulation.set_manifold (0, cylindrical_manifold);</div><div class="line"></div><div class="line">    triangulation.refine_global (1);</div><div class="line"></div><div class="line"></div><div class="line">    setup_quadrature_point_history ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">    locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">    <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler,locally_relevant_dofs);</div><div class="line"></div><div class="line">    n_local_cells</div><div class="line">      = <a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a> (triangulation,</div><div class="line">                                                           triangulation.locally_owned_subdomain ());</div><div class="line"></div><div class="line">    local_dofs_per_process = dof_handler.<a class="code" href="classDoFHandler.html#aff791a67d5a9383fb2ef05ea540b71e8">n_locally_owned_dofs_per_processor</a>();</div><div class="line"></div><div class="line">    hanging_node_constraints.clear ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> sparsity_pattern (locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div><div class="line">                                     hanging_node_constraints, <span class="comment">/*keep constrained dofs*/</span> <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a> (sparsity_pattern,</div><div class="line">                                                local_dofs_per_process,</div><div class="line">                                                mpi_communicator,</div><div class="line">                                                locally_relevant_dofs);</div><div class="line">    system_matrix.reinit (locally_owned_dofs,</div><div class="line">                          locally_owned_dofs,</div><div class="line">                          sparsity_pattern,</div><div class="line">                          mpi_communicator);</div><div class="line"></div><div class="line">    system_rhs.reinit(locally_owned_dofs,mpi_communicator);</div><div class="line">    incremental_displacement.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    system_rhs = 0;</div><div class="line">    system_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    BodyForce&lt;dim&gt;      body_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; body_force_values (n_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a> = 0;</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></div><div class="line">                  eps_phi_i = get_strain (fe_values, i, q_point),</div><div class="line">                  eps_phi_j = get_strain (fe_values, j, q_point);</div><div class="line"></div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a>(i,j)</div><div class="line">                  += (eps_phi_i * stress_strain_tensor * eps_phi_j</div><div class="line">                      *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keyword">const</span> PointHistory&lt;dim&gt; *local_quadrature_points_data</div><div class="line">            = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">          body_force.vector_value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                        body_force_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">              component_i = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &amp;old_stress</div><div class="line">                    = local_quadrature_points_data[q_point].old_stress;</div><div class="line"></div><div class="line">                  cell_rhs(i) += (body_force_values[q_point](component_i) *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i,q_point)</div><div class="line">                                  -</div><div class="line">                                  old_stress *</div><div class="line">                                  get_strain (fe_values,i,q_point))</div><div class="line">                                 *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">          hanging_node_constraints</div><div class="line">          .distribute_local_to_global (cell_matrix, cell_rhs,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       system_matrix, system_rhs);</div><div class="line">        }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> z_component (dim-1);</div><div class="line">    std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::</a></div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">    interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                 0,</div><div class="line">                                 <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a> (dim),</div><div class="line">                                 boundary_values);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::</a></div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">    interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                 1,</div><div class="line">                                 IncrementalBoundaryValues&lt;dim&gt;(present_time,</div><div class="line">                                                                present_timestep),</div><div class="line">                                 boundary_values,</div><div class="line">                                 fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_component));</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> tmp (locally_owned_dofs,mpi_communicator);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                        system_matrix, tmp,</div><div class="line">                                        system_rhs, <span class="keyword">false</span>);</div><div class="line">    incremental_displacement = tmp;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::solve_timestep ()</div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Assembling system...&quot;</span> &lt;&lt; std::flush;</div><div class="line">    assemble_system ();</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot; norm of rhs is &quot;</span> &lt;&lt; system_rhs.l2_norm()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve_linear_problem ();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Solver converged in &quot;</span> &lt;&lt; n_iterations</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Updating quadrature point data...&quot;</span> &lt;&lt; std::flush;</div><div class="line">    update_quadrature_point_history ();</div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TopLevel&lt;dim&gt;::solve_linear_problem ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div><div class="line">    distributed_incremental_displacement (locally_owned_dofs,mpi_communicator);</div><div class="line">    distributed_incremental_displacement = incremental_displacement;</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                            1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-16*system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> cg (solver_control,</div><div class="line">                                mpi_communicator);</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1PreconditionBlockJacobi.html">PETScWrappers::PreconditionBlockJacobi</a> preconditioner(system_matrix);</div><div class="line"></div><div class="line">    cg.solve (system_matrix, distributed_incremental_displacement, system_rhs,</div><div class="line">              preconditioner);</div><div class="line"></div><div class="line">    incremental_displacement = distributed_incremental_displacement;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute (incremental_displacement);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 1:</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_y&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_x&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_y&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;delta_z&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (incremental_displacement,</div><div class="line">                              solution_names);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> norm_of_stress (triangulation.n_active_cells());</div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = triangulation.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = triangulation.end();</div><div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> accumulated_stress;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0;</div><div class="line">                 q&lt;quadrature_formula.size();</div><div class="line">                 ++q)</div><div class="line">              accumulated_stress +=</div><div class="line">                <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer())[q]</div><div class="line">                .old_stress;</div><div class="line"></div><div class="line">            norm_of_stress(cell-&gt;active_cell_index())</div><div class="line">              = (accumulated_stress /</div><div class="line">                 quadrature_formula.size()).norm();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          norm_of_stress(cell-&gt;active_cell_index()) = -1e+20;</div><div class="line">    }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (norm_of_stress, <span class="stringliteral">&quot;norm_of_stress&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;types::subdomain_id&gt; partition_int (triangulation.n_active_cells());</div><div class="line">    <a class="code" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">GridTools::get_subdomain_association</a> (triangulation, partition_int);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> partitioning(partition_int.begin(),</div><div class="line">                                      partition_int.end());</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (partitioning, <span class="stringliteral">&quot;partitioning&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line"></div><div class="line">    std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4)</div><div class="line">                           + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(this_mpi_process,3)</div><div class="line">                           + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (n_mpi_processes &lt; 1000, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (this_mpi_process==0)</div><div class="line">      {</div><div class="line">        std::vector&lt;std::string&gt; filenames;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_mpi_processes; ++i)</div><div class="line">          filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4)</div><div class="line">                               + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i,3)</div><div class="line">                               + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4) +</div><div class="line">                                 <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">        std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line">        <a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no,4) +</div><div class="line">                                <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">        std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (pvtu_master, filenames);</div><div class="line"></div><div class="line">        <span class="keyword">static</span> std::vector&lt;std::pair&lt;double,std::string&gt; &gt; times_and_names;</div><div class="line">        times_and_names.push_back (std::pair&lt;double,std::string&gt; (present_time, pvtu_master_filename));</div><div class="line">        std::ofstream pvd_output (<span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">        <a class="code" href="namespaceDataOutBase.html#a9bcaee76160be3f2cee5c15ca7976a26">DataOutBase::write_pvd_record</a> (pvd_output, times_and_names);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::do_initial_timestep ()</div><div class="line">  {</div><div class="line">    present_time += present_timestep;</div><div class="line">    ++timestep_no;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_no &lt;&lt; <span class="stringliteral">&quot; at time &quot;</span> &lt;&lt; present_time</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;2; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          create_coarse_grid ();</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_initial_grid ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;    Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.n_active_cells()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div><div class="line">          pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div><div class="line">                &lt;&lt; (<a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::</a></div><div class="line"><a class="code" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">                    count_cells_with_subdomain_association</a> (triangulation,p));</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;    Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by partition:&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_mpi_processes; ++p)</div><div class="line">          pcout &lt;&lt; (p==0 ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;+&#39;</span>)</div><div class="line">                &lt;&lt; (<a class="code" href="namespaceDoFTools.html#a2dde9ded6d7cbc9962547356f37e5f72">DoFTools::</a></div><div class="line"><a class="code" href="namespaceDoFTools.html#a2dde9ded6d7cbc9962547356f37e5f72">                    count_dofs_with_subdomain_association</a> (dof_handler,p));</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve_timestep ();</div><div class="line">      }</div><div class="line"></div><div class="line">    move_mesh ();</div><div class="line">    output_results ();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::do_timestep ()</div><div class="line">  {</div><div class="line">    present_time += present_timestep;</div><div class="line">    ++timestep_no;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_no &lt;&lt; <span class="stringliteral">&quot; at time &quot;</span> &lt;&lt; present_time</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">if</span> (present_time &gt; end_time)</div><div class="line">      {</div><div class="line">        present_timestep -= (present_time - end_time);</div><div class="line">        present_time = end_time;</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    solve_timestep ();</div><div class="line"></div><div class="line">    move_mesh ();</div><div class="line">    output_results ();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::refine_initial_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell (triangulation.n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(2),</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        incremental_displacement,</div><div class="line">                                        error_per_cell,</div><div class="line">                                        <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                        <span class="keyword">nullptr</span>,</div><div class="line">                                        <a class="code" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(),</div><div class="line">                                        this_mpi_process);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_cells = triangulation.n_locally_owned_active_cells ();</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></div><div class="line">    distributed_error_per_cell (mpi_communicator,</div><div class="line">                                triangulation.n_active_cells(),</div><div class="line">                                n_local_cells);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;error_per_cell.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (error_per_cell(i) != 0)</div><div class="line">        distributed_error_per_cell(i) = error_per_cell(i);</div><div class="line">    distributed_error_per_cell.compress (<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    error_per_cell = distributed_error_per_cell;</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                     error_per_cell,</div><div class="line">                                                     0.35, 0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement ();</div><div class="line"></div><div class="line">    setup_quadrature_point_history ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::move_mesh ()</div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Moving mesh...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::vector&lt;bool&gt; vertex_touched (triangulation.n_vertices(),</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a> ();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              vertex_displacement[d]</div><div class="line">                = incremental_displacement(cell-&gt;vertex_dof_index(v,d));</div><div class="line"></div><div class="line">            cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">          }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::setup_quadrature_point_history ()</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> our_cells = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        ++our_cells;</div><div class="line"></div><div class="line">    triangulation.clear_user_data();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;PointHistory&lt;dim&gt; &gt; tmp;</div><div class="line">      tmp.swap (quadrature_point_history);</div><div class="line">    }</div><div class="line">    quadrature_point_history.resize (our_cells *</div><div class="line">                                     quadrature_formula.size());</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> history_index = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell-&gt;set_user_pointer (&amp;quadrature_point_history[history_index]);</div><div class="line">          history_index += quadrature_formula.size();</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (history_index == quadrature_point_history.size(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TopLevel&lt;dim&gt;::update_quadrature_point_history ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt;</div><div class="line">    displacement_increment_grads (quadrature_formula.size(),</div><div class="line">                                  std::vector&lt;Tensor&lt;1,dim&gt; &gt;(dim));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">            = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">                  &amp;quadrature_point_history.front(),</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">                  &amp;quadrature_point_history.back(),</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a> (incremental_displacement,</div><div class="line">                                            displacement_increment_grads);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.size(); ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> new_stress</div><div class="line">                = (local_quadrature_points_history[q].old_stress</div><div class="line">                   +</div><div class="line">                   (stress_strain_tensor *</div><div class="line">                    get_strain (displacement_increment_grads[q])));</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> rotation</div><div class="line">                = get_rotation_matrix (displacement_increment_grads[q]);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> rotated_new_stress</div><div class="line">                = symmetrize(transpose(rotation) *</div><div class="line">                             <span class="keyword">static_cast&lt;</span><a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> <span class="keyword">&gt;</span>(new_stress) *</div><div class="line">                             rotation);</div><div class="line"></div><div class="line">              local_quadrature_points_history[q].old_stress</div><div class="line">                = rotated_new_stress;</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step18;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      TopLevel&lt;3&gt; elastic_problem;</div><div class="line">      elastic_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
