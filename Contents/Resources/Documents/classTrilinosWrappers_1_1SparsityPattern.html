<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::SparsityPattern Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparsityPattern-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparsityPattern Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Sparsity.html">Sparsity patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparsity__pattern_8h_source.html">deal.II/lac/trilinos_sparsity_pattern.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparsityPattern:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparsityPattern__inherit__graph.svg" width="188" height="123"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a542f2dcccaf8d7ae0f54fa9b7a2ce445"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a></td></tr>
<tr class="separator:a542f2dcccaf8d7ae0f54fa9b7a2ce445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb98ca501c1a85dcd1ef7e3800d5a0f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a></td></tr>
<tr class="separator:adb98ca501c1a85dcd1ef7e3800d5a0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic constructors and initialization.</div></td></tr>
<tr class="memitem:a1e3d417090f12ad51343a170d11e1841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a1e3d417090f12ad51343a170d11e1841">SparsityPattern</a> ()</td></tr>
<tr class="separator:a1e3d417090f12ad51343a170d11e1841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3646f098f0c942f72da148212a1819"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ace3646f098f0c942f72da148212a1819">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ace3646f098f0c942f72da148212a1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11df72241b9b3e9c690270dec120df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae11df72241b9b3e9c690270dec120df5">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:ae11df72241b9b3e9c690270dec120df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e1e19863631ed6dc013a5f627f8e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a0f3e1e19863631ed6dc013a5f627f8e6">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a0f3e1e19863631ed6dc013a5f627f8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19303ae44a75144319b2bfeafa6e3dd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac19303ae44a75144319b2bfeafa6e3dd">~SparsityPattern</a> ()</td></tr>
<tr class="separator:ac19303ae44a75144319b2bfeafa6e3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc653a77d0c78d0f7905b3a8f5cb7ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc653a77d0c78d0f7905b3a8f5cb7ac4">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:afc653a77d0c78d0f7905b3a8f5cb7ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee2428b936269e24b12a23c81c2971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac1ee2428b936269e24b12a23c81c2971">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:ac1ee2428b936269e24b12a23c81c2971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852f4ac014717dda54daca42e8c0309d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a852f4ac014717dda54daca42e8c0309d">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a852f4ac014717dda54daca42e8c0309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e71032d26253157b73afac0750b022"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:aa5e71032d26253157b73afac0750b022"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa5e71032d26253157b73afac0750b022">copy_from</a> (const SparsityPatternType &amp;nontrilinos_sparsity_pattern)</td></tr>
<tr class="separator:aa5e71032d26253157b73afac0750b022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83efc6edec53e1104b1a18b4852dd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af83efc6edec53e1104b1a18b4852dd78">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:af83efc6edec53e1104b1a18b4852dd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1799ef4b2431ad7ece54fd1766810dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a1799ef4b2431ad7ece54fd1766810dea">clear</a> ()</td></tr>
<tr class="separator:a1799ef4b2431ad7ece54fd1766810dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15d36e4bfe7c97b55d155541e723284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a> ()</td></tr>
<tr class="separator:ad15d36e4bfe7c97b55d155541e723284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an Epetra_Map description</div></td></tr>
<tr class="memitem:a2e42f33938306de284d61ebf9d56c15b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2e42f33938306de284d61ebf9d56c15b">SparsityPattern</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0) 1</td></tr>
<tr class="separator:a2e42f33938306de284d61ebf9d56c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add642d8e58eb69869ce4fda4c749c086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#add642d8e58eb69869ce4fda4c749c086">SparsityPattern</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:add642d8e58eb69869ce4fda4c749c086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbba9197fa7ef7438f9153c0286b86da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adbba9197fa7ef7438f9153c0286b86da">SparsityPattern</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0) 1</td></tr>
<tr class="separator:adbba9197fa7ef7438f9153c0286b86da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b3393964e8582e5dda075201ce6b7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a27b3393964e8582e5dda075201ce6b7a">SparsityPattern</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:a27b3393964e8582e5dda075201ce6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55156556c6f3d095edb2b921a9f7c75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a55156556c6f3d095edb2b921a9f7c75d">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0) 1</td></tr>
<tr class="separator:a55156556c6f3d095edb2b921a9f7c75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09db47b30d2a04ecb6d4cb152d9b8de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a09db47b30d2a04ecb6d4cb152d9b8de5">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:a09db47b30d2a04ecb6d4cb152d9b8de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4198b271759bc57a42dafb0af5f8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9a4198b271759bc57a42dafb0af5f8dc">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0) 1</td></tr>
<tr class="separator:a9a4198b271759bc57a42dafb0af5f8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e6eb691b507e8cd2f5baa122bec867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad7e6eb691b507e8cd2f5baa122bec867">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:ad7e6eb691b507e8cd2f5baa122bec867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e7f6cfacf41c22da5c6e9d4ec842e4"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a08e7f6cfacf41c22da5c6e9d4ec842e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a08e7f6cfacf41c22da5c6e9d4ec842e4">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const bool exchange_data=false) 1</td></tr>
<tr class="separator:a08e7f6cfacf41c22da5c6e9d4ec842e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e4464bd06035eb21e261ff1f31e4b"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ad94e4464bd06035eb21e261ff1f31e4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad94e4464bd06035eb21e261ff1f31e4b">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const bool exchange_data=false) 1</td></tr>
<tr class="separator:ad94e4464bd06035eb21e261ff1f31e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:ac71f2bb0b9377af30a419a56d9775f31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac71f2bb0b9377af30a419a56d9775f31">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ac71f2bb0b9377af30a419a56d9775f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac67dd2dc9f638aee4848fc00a5ae12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#acac67dd2dc9f638aee4848fc00a5ae12">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:acac67dd2dc9f638aee4848fc00a5ae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb99b2ea1f6f184ccbef7009bf3c2a13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#acb99b2ea1f6f184ccbef7009bf3c2a13">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:acb99b2ea1f6f184ccbef7009bf3c2a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44e5e388d2b9a42a9e968de746461f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2c44e5e388d2b9a42a9e968de746461f">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a2c44e5e388d2b9a42a9e968de746461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae126b94fc7b75f938ad9c750d1352184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae126b94fc7b75f938ad9c750d1352184">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;writable_rows, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ae126b94fc7b75f938ad9c750d1352184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07258537f85162c220bd08cc0d45e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab07258537f85162c220bd08cc0d45e09">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ab07258537f85162c220bd08cc0d45e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa500755e481b287781bd6b6f8aad64cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa500755e481b287781bd6b6f8aad64cd">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:aa500755e481b287781bd6b6f8aad64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13406ea8005028cb9ae4329f995c2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad13406ea8005028cb9ae4329f995c2c8">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ad13406ea8005028cb9ae4329f995c2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb08788778df9dbe75b448fdcabc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a15eb08788778df9dbe75b448fdcabc69">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;writeable_rows, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a15eb08788778df9dbe75b448fdcabc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb9b09f4fcb1a13fefee40e9f95bed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aacb9b09f4fcb1a13fefee40e9f95bed5">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:aacb9b09f4fcb1a13fefee40e9f95bed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c95633efce73ce7736c8f810ff5f1"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ada9c95633efce73ce7736c8f810ff5f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ada9c95633efce73ce7736c8f810ff5f1">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const bool exchange_data=false)</td></tr>
<tr class="separator:ada9c95633efce73ce7736c8f810ff5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb92eb9a8f88aac094818586e6dd3026"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:adb92eb9a8f88aac094818586e6dd3026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb92eb9a8f88aac094818586e6dd3026">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const bool exchange_data=false)</td></tr>
<tr class="separator:adb92eb9a8f88aac094818586e6dd3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the sparsity pattern</div></td></tr>
<tr class="memitem:a935abd1908d1ed387625143f305daa2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a935abd1908d1ed387625143f305daa2b">is_compressed</a> () const</td></tr>
<tr class="separator:a935abd1908d1ed387625143f305daa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee9e81898214ced961dd7f83039c26"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4cee9e81898214ced961dd7f83039c26">max_entries_per_row</a> () const</td></tr>
<tr class="separator:a4cee9e81898214ced961dd7f83039c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8bac57fd30db178feb6dc022b6cd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows</a> () const</td></tr>
<tr class="separator:aca8bac57fd30db178feb6dc022b6cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e1e9696ac8ebf46e111471c06f2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7a9e1e9696ac8ebf46e111471c06f2b1">n_cols</a> () const</td></tr>
<tr class="separator:a7a9e1e9696ac8ebf46e111471c06f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942b99f5b3d361dff7e53fc64b70ba4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9942b99f5b3d361dff7e53fc64b70ba4">local_size</a> () const</td></tr>
<tr class="separator:a9942b99f5b3d361dff7e53fc64b70ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea819a20d1ed86f583ae0ded100e924"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range</a> () const</td></tr>
<tr class="separator:a7ea819a20d1ed86f583ae0ded100e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf60d4968439ee59816e3b7b55bd3ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adbf60d4968439ee59816e3b7b55bd3ed">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> index) const</td></tr>
<tr class="separator:adbf60d4968439ee59816e3b7b55bd3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867d59927f51777f5420e290f755105c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a867d59927f51777f5420e290f755105c">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a867d59927f51777f5420e290f755105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2993cee1717e5ed363efc93667a995ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2993cee1717e5ed363efc93667a995ff">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> row) const</td></tr>
<tr class="separator:a2993cee1717e5ed363efc93667a995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de65b796c44a6dcc51c6cd8af7cb9f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4de65b796c44a6dcc51c6cd8af7cb9f9">bandwidth</a> () const</td></tr>
<tr class="separator:a4de65b796c44a6dcc51c6cd8af7cb9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add300e272c6507cd021dfa0cc9919420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#add300e272c6507cd021dfa0cc9919420">empty</a> () const</td></tr>
<tr class="separator:add300e272c6507cd021dfa0cc9919420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793339eeff73a74d317a08cdd0c8c4ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a793339eeff73a74d317a08cdd0c8c4ff">exists</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> j) const</td></tr>
<tr class="separator:a793339eeff73a74d317a08cdd0c8c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32a20c0a31a67133750ecd45f8a498c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af32a20c0a31a67133750ecd45f8a498c">memory_consumption</a> () const</td></tr>
<tr class="separator:af32a20c0a31a67133750ecd45f8a498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding entries</div></td></tr>
<tr class="memitem:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> j)</td></tr>
<tr class="separator:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a90cfaf7a56fb9c2c012e0cf692f57e41">add_entries</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> row, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac265d5f0b47e509bb072f5b510843374">begin</a>, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5cb8a213b7d941e0c2bcef057187fa62">end</a>, const bool indices_are_sorted=false)</td></tr>
<tr class="separator:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access of underlying Trilinos data</div></td></tr>
<tr class="memitem:aea54c88d353d85742ff7b1555e2a18b6"><td class="memItemLeft" align="right" valign="top">const Epetra_FECrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aea54c88d353d85742ff7b1555e2a18b6">trilinos_sparsity_pattern</a> () const</td></tr>
<tr class="separator:aea54c88d353d85742ff7b1555e2a18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b61288c21fb51093087a4621b2e681"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a65b61288c21fb51093087a4621b2e681">domain_partitioner</a> () const 1</td></tr>
<tr class="separator:a65b61288c21fb51093087a4621b2e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d4c402a95daf15d8cd7528082cedad"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a33d4c402a95daf15d8cd7528082cedad">range_partitioner</a> () const 1</td></tr>
<tr class="separator:a33d4c402a95daf15d8cd7528082cedad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e30b3f07f1b7047ac60ffefa46f794d"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6e30b3f07f1b7047ac60ffefa46f794d">row_partitioner</a> () const 1</td></tr>
<tr class="separator:a6e30b3f07f1b7047ac60ffefa46f794d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ef4ef4c36932d4cc9588760d0ae0aa"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab1ef4ef4c36932d4cc9588760d0ae0aa">col_partitioner</a> () const 1</td></tr>
<tr class="separator:ab1ef4ef4c36932d4cc9588760d0ae0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e73437db69a6b654065255fb65990e"><td class="memItemLeft" align="right" valign="top">const Epetra_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a31e73437db69a6b654065255fb65990e">trilinos_communicator</a> () const 1</td></tr>
<tr class="separator:a31e73437db69a6b654065255fb65990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1fc61827040cef34f1168e9b85654"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5fc1fc61827040cef34f1168e9b85654">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a5fc1fc61827040cef34f1168e9b85654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitioners</div></td></tr>
<tr class="memitem:a160d8f260208908009d31833a40b1740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a160d8f260208908009d31833a40b1740">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:a160d8f260208908009d31833a40b1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04337c1541b42be7a838f05e109f890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa04337c1541b42be7a838f05e109f890">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:aa04337c1541b42be7a838f05e109f890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:ac265d5f0b47e509bb072f5b510843374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac265d5f0b47e509bb072f5b510843374">begin</a> () const</td></tr>
<tr class="separator:ac265d5f0b47e509bb072f5b510843374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb8a213b7d941e0c2bcef057187fa62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5cb8a213b7d941e0c2bcef057187fa62">end</a> () const</td></tr>
<tr class="separator:a5cb8a213b7d941e0c2bcef057187fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e070b5ada89c9bbb3d09ea8a854b857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6e070b5ada89c9bbb3d09ea8a854b857">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> r) const</td></tr>
<tr class="separator:a6e070b5ada89c9bbb3d09ea8a854b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac292d5930f1a30b8710e47ef8d2190d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac292d5930f1a30b8710e47ef8d2190d5">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> r) const</td></tr>
<tr class="separator:ac292d5930f1a30b8710e47ef8d2190d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:a6c6fcea474532b8163853c37d4baa8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6c6fcea474532b8163853c37d4baa8fc">write_ascii</a> ()</td></tr>
<tr class="separator:a6c6fcea474532b8163853c37d4baa8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8e9afc389934b74ad9de0232e3e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4bc8e9afc389934b74ad9de0232e3e34">print</a> (std::ostream &amp;out, const bool write_extended_trilinos_info=false) const</td></tr>
<tr class="separator:a4bc8e9afc389934b74ad9de0232e3e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536d0aed80f9dbbdc3c852a55a339027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a536d0aed80f9dbbdc3c852a55a339027">print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a536d0aed80f9dbbdc3c852a55a339027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga23285e3d83dc3080af284b52b06283f7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga23285e3d83dc3080af284b52b06283f7">ExcTrilinosError</a> (int arg1)</td></tr>
<tr class="separator:ga23285e3d83dc3080af284b52b06283f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ce8a113d6a82c2adaf91518572829a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99ce8a113d6a82c2adaf91518572829a">ExcInvalidIndex</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg2)</td></tr>
<tr class="separator:ga99ce8a113d6a82c2adaf91518572829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e7d450dad90efe8b1f56f526c94ca0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga89e7d450dad90efe8b1f56f526c94ca0">ExcSourceEqualsDestination</a> ()</td></tr>
<tr class="separator:ga89e7d450dad90efe8b1f56f526c94ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c75164a9be288f84a40844baa4a872"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga19c75164a9be288f84a40844baa4a872">ExcAccessToNonLocalElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg2, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg3, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg4)</td></tr>
<tr class="separator:ga19c75164a9be288f84a40844baa4a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a1f5cbf2d462ded59a999c0f14c55f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga37a1f5cbf2d462ded59a999c0f14c55f">ExcAccessToNonPresentElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> arg2)</td></tr>
<tr class="separator:ga37a1f5cbf2d462ded59a999c0f14c55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac116e66cb1c4689d6e0acaddd8cc49f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac116e66cb1c4689d6e0acaddd8cc49f8">column_space_map</a></td></tr>
<tr class="separator:ac116e66cb1c4689d6e0acaddd8cc49f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ee20e551f8f10db17caf9c00fbebd7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_FECrsGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a52ee20e551f8f10db17caf9c00fbebd7">graph</a></td></tr>
<tr class="separator:a52ee20e551f8f10db17caf9c00fbebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0823a3fd9b4b22aafc40d8c301bd692"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_CrsGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac0823a3fd9b4b22aafc40d8c301bd692">nonlocal_graph</a></td></tr>
<tr class="separator:ac0823a3fd9b4b22aafc40d8c301bd692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adc95297e71ae389ccc2eae891fa6874b"><td class="memItemLeft" align="right" valign="top"><a id="adc95297e71ae389ccc2eae891fa6874b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TrilinosWrappers::SparseMatrix</b></td></tr>
<tr class="separator:adc95297e71ae389ccc2eae891fa6874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memItemLeft" align="right" valign="top"><a id="ab1f9cdd2797ea0f1ebbec7878d2cd1be"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SparsityPatternIterators::Accessor</b></td></tr>
<tr class="separator:ab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788687eb290f58f6accdff6098d5f492"><td class="memItemLeft" align="right" valign="top"><a id="a788687eb290f58f6accdff6098d5f492"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SparsityPatternIterators::Iterator</b></td></tr>
<tr class="separator:a788687eb290f58f6accdff6098d5f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper class to use the Trilinos distributed sparsity pattern class Epetra_FECrsGraph. This class is designed to be used for construction of parallel Trilinos matrices. The functionality of this class is modeled after the existing sparsity pattern classes, with the difference that this class can work fully in parallel according to a partitioning of the sparsity pattern rows.</p>
<p>This class has many similarities to the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, since it can dynamically add elements to the pattern without any memory being previously reserved for it. However, it also has a method <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a>, that finalizes the pattern and enables its use with Trilinos sparse matrices.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Kronbichler, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00266">266</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a542f2dcccaf8d7ae0f54fa9b7a2ce445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542f2dcccaf8d7ae0f54fa9b7a2ce445">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">TrilinosWrappers::SparsityPattern::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00273">273</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="adb98ca501c1a85dcd1ef7e3800d5a0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb98ca501c1a85dcd1ef7e3800d5a0f5">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a> <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">TrilinosWrappers::SparsityPattern::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00278">278</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e3d417090f12ad51343a170d11e1841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3d417090f12ad51343a170d11e1841">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00160">160</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ace3646f098f0c942f72da148212a1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3646f098f0c942f72da148212a1819">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_253.png"/> rows and <img class="formulaInl" alt="$n$" src="form_73.png"/> columns. The resulting matrix will be completely stored locally, too.</p>
<p>It is possible to specify the number of columns entries per row using the optional <code>n_entries_per_row</code> argument. However, this value does not need to be accurate or even given at all, since one does usually not have this kind of information before building the sparsity pattern (the usual case when the function <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern()</a> is called). The entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> classes. However, a good estimate will reduce the setup time of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00207">207</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ae11df72241b9b3e9c690270dec120df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11df72241b9b3e9c690270dec120df5">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_253.png"/> rows and <img class="formulaInl" alt="$n$" src="form_73.png"/> columns. The resulting matrix will be completely stored locally, too.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row (an information usually not available, though). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00216">216</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a0f3e1e19863631ed6dc013a5f627f8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e1e19863631ed6dc013a5f627f8e6">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00226">226</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ac19303ae44a75144319b2bfeafa6e3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19303ae44a75144319b2bfeafa6e3dd">&#9670;&nbsp;</a></span>~SparsityPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::~SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00300">300</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a2e42f33938306de284d61ebf9d56c15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e42f33938306de284d61ebf9d56c15b">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square sparsity pattern using an Epetra_map for the description of the parallel partitioning. Moreover, the number of nonzero entries in the rows of the sparsity pattern can be specified. Note that this number does not need to be exact, and it is allowed that the actual sparsity structure has more nonzero entries than specified in the constructor (the usual case when the function <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern()</a> is called). However it is still advantageous to provide good estimates here since a good value will avoid repeated allocation of memory, which considerably increases the performance when creating the sparsity pattern.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00173">173</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="add642d8e58eb69869ce4fda4c749c086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add642d8e58eb69869ce4fda4c749c086">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes the creation process by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc653a77d0c78d0f7905b3a8f5cb7ac4">SparsityPattern::reinit</a> call considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00181">181</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="adbba9197fa7ef7438f9153c0286b86da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbba9197fa7ef7438f9153c0286b86da">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one map describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for specifying the correct domain space when performing matrix-vector products with vectors based on the same column map.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00189">189</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a27b3393964e8582e5dda075201ce6b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b3393964e8582e5dda075201ce6b7a">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00198">198</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ac71f2bb0b9377af30a419a56d9775f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71f2bb0b9377af30a419a56d9775f31">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning. Moreover, the number of nonzero entries in the rows of the sparsity pattern can be specified. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since a good value will avoid repeated allocation of memory, which considerably increases the performance when creating the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00244">244</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="acac67dd2dc9f638aee4848fc00a5ae12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac67dd2dc9f638aee4848fc00a5ae12">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes the creation process by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc653a77d0c78d0f7905b3a8f5cb7ac4">SparsityPattern::reinit</a> call considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00254">254</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="acb99b2ea1f6f184ccbef7009bf3c2a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb99b2ea1f6f184ccbef7009bf3c2a13">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets to describe the parallel partitioning of rows and columns. This interface is meant to be used for generating rectangular sparsity pattern. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on that column map.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00264">264</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a2c44e5e388d2b9a42a9e968de746461f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c44e5e388d2b9a42a9e968de746461f">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00276">276</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ae126b94fc7b75f938ad9c750d1352184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae126b94fc7b75f938ad9c750d1352184">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>writable_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor constructs general sparsity patterns, possible non- square ones. Constructing a sparsity pattern this way allows the user to explicitly specify the rows into which we are going to add elements. This set is required to be a superset of the first index set <code>row_parallel_partitioning</code> that includes also rows that are owned by another processor (ghost rows). Note that elements can only be added to rows specified by <code>writable_rows</code>.</p>
<p>This method is beneficial when the rows to which a processor is going to write can be determined before actually inserting elements into the matrix. For the typical <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class used in deal.II, we know that a processor only will add row elements for what we call the locally relevant dofs (see <a class="el" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>). The other constructors methods use general Trilinos facilities that allow to add elements to arbitrary rows (as done by all the other reinit functions). However, this flexibility come at a cost, the most prominent being that adding elements into the same matrix from multiple threads in shared memory is not safe whenever <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> is used. For these settings, the current method is the one to choose: It will store the off-processor data as an additional sparsity pattern (that is then passed to the Trilinos matrix via the reinit mehtod) which can be organized in such a way that thread-safety can be ensured (as long as the user makes sure to never write into the same matrix row simultaneously, of course). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00288">288</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc653a77d0c78d0f7905b3a8f5cb7ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc653a77d0c78d0f7905b3a8f5cb7ac4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_253.png"/> rows and <img class="formulaInl" alt="$n$" src="form_73.png"/> columns. The resulting matrix will be completely stored locally.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. This does not need to be an accurate number since the entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> classes, but a good estimate will reduce the setup time of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00306">306</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ac1ee2428b936269e24b12a23c81c2971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ee2428b936269e24b12a23c81c2971">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having <img class="formulaInl" alt="$m$" src="form_253.png"/> rows and <img class="formulaInl" alt="$n$" src="form_73.png"/> columns. The resulting matrix will be completely stored locally.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00317">317</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a852f4ac014717dda54daca42e8c0309d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852f4ac014717dda54daca42e8c0309d">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

</div>
</div>
<a id="aa5e71032d26253157b73afac0750b022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e71032d26253157b73afac0750b022">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function from one of the deal.II sparsity patterns. If used in parallel, this function uses an ad-hoc partitioning of the rows and columns. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00735">735</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="af83efc6edec53e1104b1a18b4852dd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83efc6edec53e1104b1a18b4852dd78">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp; SparsityPattern::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. This operation is only allowed for empty objects, to avoid potentially very costly operations automatically synthesized by the compiler. Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a852f4ac014717dda54daca42e8c0309d">copy_from()</a> instead if you know that you really want to copy a sparsity pattern with non-trivial content. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00725">725</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a1799ef4b2431ad7ece54fd1766810dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1799ef4b2431ad7ece54fd1766810dea">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00749">749</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad15d36e4bfe7c97b55d155541e723284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15d36e4bfe7c97b55d155541e723284">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In analogy to our own <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting pattern to be used for actually generating a (Trilinos-based) matrix. This function also exchanges non-local data that might have accumulated during the addition of new elements. This function must therefore be called once the structure is fixed. This is a collective operation, i.e., it needs to be run on all processors when used in parallel. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00767">767</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a55156556c6f3d095edb2b921a9f7c75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55156556c6f3d095edb2b921a9f7c75d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialization function for generating a square sparsity pattern using an Epetra_Map for the description of the parallel partitioning and the number of nonzero entries in the rows of the sparsity pattern. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance when creating the sparsity pattern.</p>
<p>This function does not create any entries by itself, but provides the correct data structures that can be used by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add()</a> function.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00530">530</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a09db47b30d2a04ecb6d4cb152d9b8de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09db47b30d2a04ecb6d4cb152d9b8de5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes process of adding entries to the sparsity pattern considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00551">551</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a9a4198b271759bc57a42dafb0af5f8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4198b271759bc57a42dafb0af5f8dc">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one map describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on that column map.</p>
<p>The number of columns entries per row is specified by the argument <code>n_entries_per_row</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00540">540</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad7e6eb691b507e8cd2f5baa122bec867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e6eb691b507e8cd2f5baa122bec867">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00561">561</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a08e7f6cfacf41c22da5c6e9d4ec842e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e7f6cfacf41c22da5c6e9d4ec842e4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00711">711</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad94e4464bd06035eb21e261ff1f31e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e4464bd06035eb21e261ff1f31e4b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00699">699</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ab07258537f85162c220bd08cc0d45e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07258537f85162c220bd08cc0d45e09">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialization function for generating a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning and the number of nonzero entries in the rows of the sparsity pattern. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance when creating the sparsity pattern.</p>
<p>This function does not create any entries by itself, but provides the correct data structures that can be used by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00572">572</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aa500755e481b287781bd6b6f8aad64cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa500755e481b287781bd6b6f8aad64cd">&#9670;&nbsp;</a></span>reinit() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes process of adding entries to the sparsity pattern considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00584">584</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad13406ea8005028cb9ae4329f995c2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13406ea8005028cb9ae4329f995c2c8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one index set describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second <a class="el" href="classIndexSet.html">IndexSet</a> is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on an EpetraMap based on that <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>The number of columns entries per row is specified by the argument <code>n_entries_per_row</code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00596">596</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a15eb08788778df9dbe75b448fdcabc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb08788778df9dbe75b448fdcabc69">&#9670;&nbsp;</a></span>reinit() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>writeable_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is used to specify general matrices, possibly non- square ones. In addition to the arguments of the other reinit method above, it allows the user to explicitly specify the rows into which we are going to add elements. This set is a superset of the first index set <code>row_parallel_partitioning</code> that includes also rows that are owned by another processor (ghost rows).</p>
<p>This method is beneficial when the rows to which a processor is going to write can be determined before actually inserting elements into the matrix. For the typical <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class used in deal.II, we know that a processor only will add row elements for what we call the locally relevant dofs (see <a class="el" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>). Trilinos matrices allow to add elements to arbitrary rows (as done by all the other reinit functions) and this is what all the other reinit methods do, too. However, this flexibility come at a cost, the most prominent being that adding elements into the same matrix from multiple threads in shared memory is not safe whenever <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> is used. For these settings, the current method is the one to choose: It will store the off-processor data as an additional sparsity pattern (that is then passed to the Trilinos matrix via the reinit method) which can be organized in such a way that thread-safety can be ensured (as long as the user makes sure to never write into the same matrix row simultaneously, of course). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00628">628</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aacb9b09f4fcb1a13fefee40e9f95bed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb9b09f4fcb1a13fefee40e9f95bed5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now using a vector <code>n_entries_per_row</code> for specifying the number of entries in each row of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00612">612</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ada9c95633efce73ce7736c8f810ff5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c95633efce73ce7736c8f810ff5f1">&#9670;&nbsp;</a></span>reinit() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and the parallel partitioning of the rows and columns specified by two index sets and a parallel communicator for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00666">666</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="adb92eb9a8f88aac094818586e6dd3026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb92eb9a8f88aac094818586e6dd3026">&#9670;&nbsp;</a></span>reinit() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00684">684</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a935abd1908d1ed387625143f305daa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935abd1908d1ed387625143f305daa2b">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparsityPattern::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the state of the sparsity pattern, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress()</a> needs to be called after an operation requiring data exchange. </p>

</div>
</div>
<a id="a4cee9e81898214ced961dd7f83039c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cee9e81898214ced961dd7f83039c26">&#9670;&nbsp;</a></span>max_entries_per_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SparsityPattern::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the maximum number of entries per row on the current processor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00975">975</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aca8bac57fd30db178feb6dc022b6cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8bac57fd30db178feb6dc022b6cd49">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> SparsityPattern::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00920">920</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a7a9e1e9696ac8ebf46e111471c06f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e1e9696ac8ebf46e111471c06f2b1">&#9670;&nbsp;</a></span>n_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> SparsityPattern::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00929">929</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a9942b99f5b3d361dff7e53fc64b70ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9942b99f5b3d361dff7e53fc64b70ba4">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SparsityPattern::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the sparsity pattern, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. In the sequential case, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range()</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00943">943</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a7ea819a20d1ed86f583ae0ded100e924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea819a20d1ed86f583ae0ded100e924">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> &gt; SparsityPattern::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this sparsity pattern are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9942b99f5b3d361dff7e53fc64b70ba4">local_size()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00953">953</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="adbf60d4968439ee59816e3b7b55bd3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf60d4968439ee59816e3b7b55bd3ed">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparsityPattern::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range()</a>. </p>

</div>
</div>
<a id="a867d59927f51777f5420e290f755105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867d59927f51777f5420e290f755105c">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> SparsityPattern::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00965">965</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a2993cee1717e5ed363efc93667a995ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2993cee1717e5ed363efc93667a995ff">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> SparsityPattern::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00985">985</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a4de65b796c44a6dcc51c6cd8af7cb9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de65b796c44a6dcc51c6cd8af7cb9f9">&#9670;&nbsp;</a></span>bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">SparsityPattern::size_type</a> SparsityPattern::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of <img class="formulaInl" alt="$|i-j|$" src="form_993.png"/> for which the index pair <img class="formulaInl" alt="$(i,j)$" src="form_739.png"/> represents a nonzero entry of the matrix. Consequently, the maximum bandwidth a <img class="formulaInl" alt="$n\times m$" src="form_994.png"/> matrix can have is <img class="formulaInl" alt="$\max\{n-1,m-1\}$" src="form_995.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00898">898</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="add300e272c6507cd021dfa0cc9919420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add300e272c6507cd021dfa0cc9919420">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparsityPattern::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as when both dimensions are zero. </p>

</div>
</div>
<a id="a793339eeff73a74d317a08cdd0c8c4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793339eeff73a74d317a08cdd0c8c4ff">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SparsityPattern::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the index (<em>i,j</em>) exists in the sparsity pattern (i.e., it may be non-zero) or not. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00808">808</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="af32a20c0a31a67133750ecd45f8a498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32a20c0a31a67133750ecd45f8a498c">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SparsityPattern::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Currently not implemented for this class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01128">1128</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a4a411ae74d053f5ab1b85e885d637cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a411ae74d053f5ab1b85e885d637cd2">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the element (<em>i,j</em>) to the sparsity pattern. </p>

</div>
</div>
<a id="a90cfaf7a56fb9c2c012e0cf692f57e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cfaf7a56fb9c2c012e0cf692f57e41">&#9670;&nbsp;</a></span>add_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add several elements in one row to the sparsity pattern. </p>

</div>
</div>
<a id="aea54c88d353d85742ff7b1555e2a18b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea54c88d353d85742ff7b1555e2a18b6">&#9670;&nbsp;</a></span>trilinos_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_FECrsGraph&amp; TrilinosWrappers::SparsityPattern::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern. </p>

</div>
</div>
<a id="a65b61288c21fb51093087a4621b2e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b61288c21fb51093087a4621b2e681">&#9670;&nbsp;</a></span>domain_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::domain_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the parallel partitioning of the domain space of this sparsity pattern, i.e., the partitioning of the vectors matrices based on this sparsity pattern are multiplied with.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000089">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a160d8f260208908009d31833a40b1740">locally_owned_domain_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01007">1007</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a33d4c402a95daf15d8cd7528082cedad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d4c402a95daf15d8cd7528082cedad">&#9670;&nbsp;</a></span>range_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::range_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the range space of this sparsity pattern, i.e., the partitioning of the vectors that are result from matrix- vector products.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000090">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa04337c1541b42be7a838f05e109f890">locally_owned_range_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01015">1015</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a6e30b3f07f1b7047ac60ffefa46f794d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e30b3f07f1b7047ac60ffefa46f794d">&#9670;&nbsp;</a></span>row_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::row_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the sparsity pattern rows. Equal to the partitioning of the range.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa04337c1541b42be7a838f05e109f890">locally_owned_range_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01023">1023</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ab1ef4ef4c36932d4cc9588760d0ae0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ef4ef4c36932d4cc9588760d0ae0aa">&#9670;&nbsp;</a></span>col_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::col_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the sparsity pattern columns. This is in general not equal to the partitioner Epetra_Map for the domain because of overlap in the matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>Usually not necessary. If desired, access via the Epetra_FECrsGraph. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01031">1031</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a31e73437db69a6b654065255fb65990e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e73437db69a6b654065255fb65990e">&#9670;&nbsp;</a></span>trilinos_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Comm &amp; SparsityPattern::trilinos_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the communicator used for this object.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>Use get_mpi_communicator instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01039">1039</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a5fc1fc61827040cef34f1168e9b85654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc1fc61827040cef34f1168e9b85654">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm SparsityPattern::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01047">1047</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a160d8f260208908009d31833a40b1740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d8f260208908009d31833a40b1740">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparsityPattern::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the domain space of this pattern, i.e., the partitioning of the vectors a matrix based on this sparsity pattern has to be multiplied with. </p>

</div>
</div>
<a id="aa04337c1541b42be7a838f05e109f890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04337c1541b42be7a838f05e109f890">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparsityPattern::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the range space of this pattern, i.e., the partitioning of the vectors that are the result from matrix-vector products from a matrix based on this pattern. </p>

</div>
</div>
<a id="ac265d5f0b47e509bb072f5b510843374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac265d5f0b47e509bb072f5b510843374">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. </p>

</div>
</div>
<a id="a5cb8a213b7d941e0c2bcef057187fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb8a213b7d941e0c2bcef057187fa62">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="a6e070b5ada89c9bbb3d09ea8a854b857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e070b5ada89c9bbb3d09ea8a854b857">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a id="ac292d5930f1a30b8710e47ef8d2190d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac292d5930f1a30b8710e47ef8d2190d5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb98ca501c1a85dcd1ef7e3800d5a0f5">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a542f2dcccaf8d7ae0f54fa9b7a2ce445">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="a6c6fcea474532b8163853c37d4baa8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6fcea474532b8163853c37d4baa8fc">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract Trilinos object that helps view in ASCII other Trilinos objects. Currently this function is not implemented. TODO: Not implemented. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01067">1067</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a4bc8e9afc389934b74ad9de0232e3e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8e9afc389934b74ad9de0232e3e34">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print (the locally owned part of) the sparsity pattern to the given stream, using the format <code>(line,col)</code>. The optional flag outputs the sparsity pattern in Trilinos style, where even the according processor number is printed to the stream, as well as a summary before actually writing the entries. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01078">1078</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a536d0aed80f9dbbdc3c852a55a339027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536d0aed80f9dbbdc3c852a55a339027">&#9670;&nbsp;</a></span>print_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::print_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the sparsity of the matrix in a format that <code>gnuplot</code> understands and which can be used to plot the sparsity pattern in a graphical way. The format consists of pairs <code>i j</code> of nonzero elements, each representing one entry of this matrix, one per line of the output file. Indices are counted from zero on, as usual. Since sparsity patterns are printed in the same way as matrices are displayed, we print the negative of the column index, which means that the <code>(0,0)</code> element is in the top left rather than in the bottom left corner.</p>
<p>Print the sparsity pattern in gnuplot by setting the data style to dots or points and use the <code>plot</code> command. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01104">1104</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac116e66cb1c4689d6e0acaddd8cc49f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac116e66cb1c4689d6e0acaddd8cc49f8">&#9670;&nbsp;</a></span>column_space_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparsityPattern::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the user-supplied Epetra Trilinos mapping of the matrix columns that assigns parts of the matrix to the individual processes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01145">1145</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="a52ee20e551f8f10db17caf9c00fbebd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ee20e551f8f10db17caf9c00fbebd7">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_FECrsGraph&gt; TrilinosWrappers::SparsityPattern::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparsity pattern object in Trilinos to be used for finite element based problems which allows for adding non-local elements to the pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01152">1152</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ac0823a3fd9b4b22aafc40d8c301bd692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0823a3fd9b4b22aafc40d8c301bd692">&#9670;&nbsp;</a></span>nonlocal_graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_CrsGraph&gt; TrilinosWrappers::SparsityPattern::nonlocal_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparsity pattern object for the non-local part of the sparsity pattern that is going to be sent to the owning processor. Only used when the particular constructor or reinit method with writable_rows argument is set </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l01160">1160</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/lac/<a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/lac/<a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
