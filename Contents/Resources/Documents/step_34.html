<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-34 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-34 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Irrotationalflow"> Irrotational flow </a>
        <li><a href="#Thenumericalapproximation">The numerical approximation</a>
        <li><a href="#Collocationboundaryelementmethod"> Collocation boundary element method </a>
        <li><a href="#Treatingthesingularintegrals"> Treating the singular integrals. </a>
        <li><a href="#Implementation">Implementation</a>
        <li><a href="#Testcase">Testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Singleanddoublelayeroperatorkernels">Single and double layer operator kernels</a>
        <li><a href="#TheBEMProblemclass">The BEMProblem class</a>
      <ul>
        <li><a href="#BEMProblemBEMProblemandBEMProblemread_parameters">BEMProblem::BEMProblem and BEMProblem::read_parameters</a>
        <li><a href="#BEMProblemread_domain">BEMProblem::read_domain</a>
        <li><a href="#BEMProblemrefine_and_resize">BEMProblem::refine_and_resize</a>
        <li><a href="#BEMProblemassemble_system">BEMProblem::assemble_system</a>
        <li><a href="#BEMProblemsolve_system">BEMProblem::solve_system</a>
        <li><a href="#BEMProblemcompute_errors">BEMProblem::compute_errors</a>
        <li><a href="#BEMProblemcompute_exterior_solution">BEMProblem::compute_exterior_solution</a>
        <li><a href="#BEMProblemoutput_results">BEMProblem::output_results</a>
        <li><a href="#BEMProblemrun">BEMProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Luca Heltai (thanks to Michael Gratton for pointing out what the exact solution should have been in the three dimensional case). </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.495473"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.495473.svg" alt="10.5281/zenodo.495473"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Irrotationalflow"></a></p><h3>Irrotational flow </h3>
<p>The incompressible motion of an inviscid fluid past a body (for example air past an airplane wing, or air or water past a propeller) is usually modeled by the Euler equations of fluid dynamics:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{\partial }{\partial t}\mathbf{v} + (\mathbf{v}\cdot\nabla)\mathbf{v} &amp;= -\frac{1}{\rho}\nabla p + \mathbf{g} \qquad &amp;\text{in } \mathbb{R}^n \backslash \Omega \\ \nabla \cdot \mathbf{v}&amp;=0 &amp;\text{in } \mathbb{R}^n\backslash\Omega \end{align*}" src="form_2923.png"/>
</p>
<p> where the fluid density <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> and the acceleration <img class="formulaInl" alt="$\mathbf{g}$" src="form_2924.png"/> due to external forces are given and the velocity <img class="formulaInl" alt="$\mathbf{v}$" src="form_2925.png"/> and the pressure <img class="formulaInl" alt="$p$" src="form_202.png"/> are the unknowns. Here <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> is a closed bounded region representing the body around which the fluid moves.</p>
<p>The above equations can be derived from Navier-Stokes equations assuming that the effects due to viscosity are negligible compared to those due to the pressure gradient, inertial forces and the external forces. This is the opposite case of the Stokes equations discussed in <a class="el" href="step_22.html">step-22</a> which are the limit case of dominant viscosity, i.e. where the velocity is so small that inertia forces can be neglected. On the other hand, owing to the assumed incompressibility, the equations are not suited for very high speed gas flows where compressibility and the equation of state of the gas have to be taken into account, leading to the Euler equations of gas dynamics, a hyperbolic system.</p>
<p>For the purpose of this tutorial program, we will consider only stationary flow without external forces: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\mathbf{v}\cdot\nabla)\mathbf{v} &amp;= -\frac{1}{\rho}\nabla p \qquad &amp;\text{in } \mathbb{R}^n \backslash \Omega \\ \nabla \cdot \mathbf{v}&amp;=0 &amp;\text{in } \mathbb{R}^n\backslash\Omega \end{align*}" src="form_2926.png"/>
</p>
<p>Uniqueness of the solution of the Euler equations is ensured by adding the boundary conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \label{eq:boundary-conditions} \begin{aligned} \mathbf{n}\cdot\mathbf{v}&amp; = 0 \qquad &amp;&amp; \text{ on } \partial\Omega \\ \mathbf{v}&amp; = \mathbf{v}_\infty &amp;&amp; \text{ when } |\mathbf{x}| \to \infty, \end{aligned} \]" src="form_2927.png"/>
</p>
<p>which is to say that the body is at rest in our coordinate systems and is not permeable, and that the fluid has (constant) velocity <img class="formulaInl" alt="$\mathbf{v}_\infty$" src="form_2928.png"/> at infinity. An alternative viewpoint is that our coordinate system moves along with the body whereas the background fluid is at rest at infinity. Notice that we define the normal <img class="formulaInl" alt="$\mathbf{n}$" src="form_1349.png"/> as the <em>outer</em> normal to the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, which is the opposite of the outer normal to the integration domain.</p>
<p>For both stationary and non stationary flow, the solution process starts by solving for the velocity in the second equation and substituting in the first equation in order to find the pressure. The solution of the stationary Euler equations is typically performed in order to understand the behavior of the given (possibly complex) geometry when a prescribed motion is enforced on the system.</p>
<p>The first step in this process is to change the frame of reference from a coordinate system moving along with the body to one in which the body moves through a fluid that is at rest at infinity. This can be expressed by introducing a new velocity <img class="formulaInl" alt="$\mathbf{\tilde{v}}=\mathbf{v}-\mathbf{v}_\infty$" src="form_2929.png"/> for which we find that the same equations hold (because <img class="formulaInl" alt="$\nabla\cdot \mathbf{v}_\infty=0$" src="form_2930.png"/>) and we have boundary conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \label{eq:boundary-conditions-tilde} \begin{aligned} \mathbf{n}\cdot\mathbf{\tilde{v}}&amp; = -\mathbf{n}\cdot\mathbf{v}_\infty \qquad &amp;&amp; \text{ on } \partial\Omega \\ \mathbf{\tilde{v}}&amp; = 0 &amp;&amp; \text{ when } |\mathbf{x}| \to \infty, \end{aligned} \]" src="form_2931.png"/>
</p>
<p>If we assume that the fluid is irrotational, i.e., <img class="formulaInl" alt="$\nabla \times \mathbf{v}=0$" src="form_2932.png"/> in <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/>, we can represent the velocity, and consequently also the perturbation velocity, as the gradient of a scalar function: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{\tilde{v}}=\nabla\phi, \]" src="form_2934.png"/>
</p>
<p> and so the second part of Euler equations above can be rewritten as the homogeneous Laplace equation for the unknown <img class="formulaInl" alt="$\phi$" src="form_643.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \label{laplace} \Delta\phi &amp;= 0 \qquad &amp;&amp;\text{in}\ \mathbb{R}^n\backslash\Omega, \\ \mathbf{n}\cdot\nabla\phi &amp;= -\mathbf{n}\cdot\mathbf{v}_\infty &amp;&amp; \text{on}\ \partial\Omega \end{align*}" src="form_2935.png"/>
</p>
<p> while the momentum equation reduces to Bernoulli's equation that expresses the pressure <img class="formulaInl" alt="$p$" src="form_202.png"/> as a function of the potential <img class="formulaInl" alt="$\phi$" src="form_643.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{p}{\rho} +\frac{1}{2} | \nabla \phi |^2 = 0 \in \Omega. \]" src="form_2936.png"/>
</p>
<p>So we can solve the problem by solving the Laplace equation for the potential. We recall that the following functions, called fundamental solutions of the Laplace equation,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \label{eq:3} G(\mathbf{y}-\mathbf{x}) = &amp; -\frac{1}{2\pi}\ln|\mathbf{y}-\mathbf{x}| \qquad &amp;&amp; \text{for } n=2 \\ G(\mathbf{y}-\mathbf{x}) = &amp; \frac{1}{4\pi}\frac{1}{|\mathbf{y}-\mathbf{x}|}&amp;&amp; \text{for } n=3, \end{aligned} \]" src="form_2937.png"/>
</p>
<p>satisfy in a distributional sense the equation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\Delta_y G(\mathbf{y}-\mathbf{x}) = \delta(\mathbf{y}-\mathbf{x}), \]" src="form_2938.png"/>
</p>
<p>where the derivative is done in the variable <img class="formulaInl" alt="$\mathbf{y}$" src="form_2939.png"/>. By using the usual Green identities, our problem can be written on the boundary <img class="formulaInl" alt="$\partial\Omega = \Gamma$" src="form_2940.png"/> only. We recall the general definition of the second Green identity:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\label{green} \int_{\omega} (-\Delta u)v\,dx + \int_{\partial\omega} \frac{\partial u}{\partial \tilde{\mathbf{n}} }v \,ds = \int_{\omega} (-\Delta v)u\,dx + \int_{\partial\omega} u\frac{\partial v}{\partial \tilde{\mathbf{n}}} \,ds, \]" src="form_2941.png"/>
</p>
<p>where <img class="formulaInl" alt="$\tilde{\mathbf{n}}$" src="form_2942.png"/> is the normal to the surface of <img class="formulaInl" alt="$\omega$" src="form_2410.png"/> pointing outwards from the domain of integration <img class="formulaInl" alt="$\omega$" src="form_2410.png"/>.</p>
<p>In our case the domain of integration is the domain <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/>, whose boundary is <img class="formulaInl" alt="$ \Gamma_\infty \cup \Gamma$" src="form_2943.png"/>, where the "boundary" at infinity is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_\infty := \lim_{r\to\infty} \partial B_r(0). \]" src="form_2944.png"/>
</p>
<p>In our program the normals are defined as <em>outer</em> to the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, that is, they are in fact <em>inner</em> to the integration domain, and some care is required in defining the various integrals with the correct signs for the normals, i.e. replacing <img class="formulaInl" alt="$\tilde{\mathbf{n}}$" src="form_2942.png"/> by <img class="formulaInl" alt="$-\mathbf{n}$" src="form_2945.png"/>.</p>
<p>If we substitute <img class="formulaInl" alt="$u$" src="form_256.png"/> and <img class="formulaInl" alt="$v$" src="form_987.png"/> in the Green identity with the solution <img class="formulaInl" alt="$\phi$" src="form_643.png"/> and with the fundamental solution of the Laplace equation respectively, as long as <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/> is chosen in the region <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/>, we obtain: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi(\mathbf{x}) - \int_{\Gamma\cup\Gamma_\infty}\frac{\partial G(\mathbf{y}-\mathbf{x})}{\partial \mathbf{n}_y}\phi(\mathbf{y})\,ds_y = -\int_{\Gamma\cup\Gamma_\infty}G(\mathbf{y}-\mathbf{x})\frac{\partial \phi}{\partial \mathbf{n}_y}(\mathbf{y})\,ds_y \qquad \forall\mathbf{x}\in \mathbb{R}^n\backslash\Omega \]" src="form_2946.png"/>
</p>
<p>where the normals are now pointing <em>inward</em> the domain of integration.</p>
<p>Notice that in the above equation, we also have the integrals on the portion of the boundary at <img class="formulaInl" alt="$\Gamma_\infty$" src="form_2947.png"/>. Using the boundary conditions of our problem, we have that <img class="formulaInl" alt="$\nabla \phi$" src="form_2948.png"/> is zero at infinity (which simplifies the integral on <img class="formulaInl" alt="$\Gamma_\infty$" src="form_2947.png"/> on the right hand side).</p>
<p>The integral on <img class="formulaInl" alt="$\Gamma_\infty$" src="form_2947.png"/> that appears on the left hand side can be treated by observing that <img class="formulaInl" alt="$\nabla\phi=0$" src="form_2949.png"/> implies that <img class="formulaInl" alt="$\phi$" src="form_643.png"/> at infinity is necessarily constant. We define its value to be <img class="formulaInl" alt="$\phi_\infty$" src="form_2950.png"/>. It is an easy exercise to prove that</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\int_{\Gamma_\infty} \frac{\partial G(\mathbf{y}-\mathbf{x})} {\partial \mathbf{n}_y}\phi_\infty \,ds_y = \lim_{r\to\infty} \int_{\partial B_r(0)} \frac{\mathbf{r}}{r} \cdot \nabla G(\mathbf{y}-\mathbf{x}) \phi_\infty \,ds_y = -\phi_\infty. \]" src="form_2951.png"/>
</p>
<p>Using this result, we can reduce the above equation only on the boundary <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/> using the so-called Single and Double Layer Potential operators:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\label{integral} \phi(\mathbf{x}) - (D\phi)(\mathbf{x}) = \phi_\infty -\left(S \frac{\partial \phi}{\partial n_y}\right)(\mathbf{x}) \qquad \forall\mathbf{x}\in \mathbb{R}^n\backslash\Omega. \]" src="form_2952.png"/>
</p>
<p>(The name of these operators comes from the fact that they describe the electric potential in <img class="formulaInl" alt="$\mathbb{R}^n$" src="form_2953.png"/> due to a single thin sheet of charges along a surface, and due to a double sheet of charges and anti-charges along the surface, respectively.)</p>
<p>In our case, we know the Neumann values of <img class="formulaInl" alt="$\phi$" src="form_643.png"/> on the boundary: <img class="formulaInl" alt="$\mathbf{n}\cdot\nabla\phi = -\mathbf{n}\cdot\mathbf{v}_\infty$" src="form_2954.png"/>. Consequently, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi(\mathbf{x}) - (D\phi)(\mathbf{x}) = \phi_\infty + \left(S[\mathbf{n}\cdot\mathbf{v}_\infty]\right)(\mathbf{x}) \qquad \forall\mathbf{x} \in \mathbb{R}^n\backslash\Omega. \]" src="form_2955.png"/>
</p>
<p> If we take the limit for <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/> tending to <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/> of the above equation, using well known properties of the single and double layer operators, we obtain an equation for <img class="formulaInl" alt="$\phi$" src="form_643.png"/> just on the boundary <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/> of <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\label{SD} \alpha(\mathbf{x})\phi(\mathbf{x}) - (D\phi)(\mathbf{x}) = \phi_\infty + \left(S [\mathbf{n}\cdot\mathbf{v}_\infty]\right)(\mathbf{x}) \quad \mathbf{x}\in \partial\Omega, \]" src="form_2956.png"/>
</p>
<p>which is the Boundary Integral Equation (BIE) we were looking for, where the quantity <img class="formulaInl" alt="$\alpha(\mathbf{x})$" src="form_2957.png"/> is the fraction of angle or solid angle by which the point <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/> sees the domain of integration <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/>.</p>
<p>In particular, at points <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/> where the boundary <img class="formulaInl" alt="$\partial\Omega$" src="form_1757.png"/> is differentiable (i.e. smooth) we have <img class="formulaInl" alt="$\alpha(\mathbf{x})=\frac 12$" src="form_2958.png"/>, but the value may be smaller or larger at points where the boundary has a corner or an edge.</p>
<p>Substituting the single and double layer operators we get: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \alpha(\mathbf{x}) \phi(\mathbf{x}) + \frac{1}{2\pi}\int_{\partial \Omega} \frac{ (\mathbf{y}-\mathbf{x})\cdot\mathbf{n}_y }{ |\mathbf{y}-\mathbf{x}|^2 } \phi(\mathbf{y}) \,ds_y = \phi_\infty -\frac{1}{2\pi}\int_{\partial \Omega} \ln|\mathbf{y}-\mathbf{x}| \, \mathbf{n}\cdot\mathbf{v_\infty}\,ds_y \]" src="form_2959.png"/>
</p>
<p> for two dimensional flows and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \alpha(\mathbf{x}) \phi(\mathbf{x}) + \frac{1}{4\pi}\int_{\partial \Omega} \frac{ (\mathbf{y}-\mathbf{x})\cdot\mathbf{n}_y }{ |\mathbf{y}-\mathbf{x}|^3 }\phi(\mathbf{y})\,ds_y = \phi_\infty + \frac{1}{4\pi}\int_{\partial \Omega} \frac{1}{|\mathbf{y}-\mathbf{x}|} \, \mathbf{n}\cdot\mathbf{v_\infty}\,ds_y \]" src="form_2960.png"/>
</p>
<p> for three dimensional flows, where the normal derivatives of the fundamental solutions have been written in a form that makes computation easier. In either case, <img class="formulaInl" alt="$\phi$" src="form_643.png"/> is the solution of an integral equation posed entirely on the boundary since both <img class="formulaInl" alt="$\mathbf{x},\mathbf{y}\in\partial\Omega$" src="form_2961.png"/>.</p>
<p>Notice that the fraction of angle (in 2d) or solid angle (in 3d) <img class="formulaInl" alt="$\alpha(\mathbf{x})$" src="form_2957.png"/> by which the point <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/> sees the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> can be defined using the double layer potential itself: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \alpha(\mathbf{x}) := 1 - \frac{1}{2(n-1)\pi}\int_{\partial \Omega} \frac{ (\mathbf{y}-\mathbf{x})\cdot\mathbf{n}_y } { |\mathbf{y}-\mathbf{x}|^{n} }\phi(\mathbf{y})\,ds_y = 1+ \int_{\partial \Omega} \frac{ \partial G(\mathbf{y}-\mathbf{x}) }{\partial \mathbf{n}_y} \, ds_y. \]" src="form_2962.png"/>
</p>
<p>The reason why this is possible can be understood if we consider the fact that the solution of a pure Neumann problem is known up to an arbitrary constant <img class="formulaInl" alt="$c$" src="form_257.png"/>, which means that, if we set the Neumann data to be zero, then any constant <img class="formulaInl" alt="$\phi = \phi_\infty$" src="form_2963.png"/> will be a solution. Inserting the constant solution and the Neumann boundary condition in the boundary integral equation, we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \alpha\left(\mathbf{x}\right)\phi\left(\mathbf{x}\right) &amp;=\int_{\Omega}\phi\left(\mathbf{y}\right)\delta\left(\mathbf{y}-\mathbf{x}\right)\, dy\\ \Rightarrow \alpha\left(\mathbf{x}\right)\phi_\infty &amp;=\phi_\infty\int_{\Gamma\cup\Gamma_\infty}\frac{ \partial G(\mathbf{y}-\mathbf{x}) }{\partial \mathbf{n}_y} \, ds_y =\phi_\infty\left[\int_{\Gamma_\infty}\frac{ \partial G(\mathbf{y}-\mathbf{x}) }{\partial \mathbf{n}_y} \, ds_y +\int_{\Gamma}\frac{ \partial G(\mathbf{y}-\mathbf{x}) }{\partial \mathbf{n}_y} \, ds_y \right] \end{align*}" src="form_2964.png"/>
</p>
<p> The integral on <img class="formulaInl" alt="$\Gamma_\infty$" src="form_2947.png"/> is unity, see above, so division by the constant <img class="formulaInl" alt="$\phi_\infty$" src="form_2950.png"/> gives us the explicit expression above for <img class="formulaInl" alt="$\alpha(\mathbf{x})$" src="form_2957.png"/>.</p>
<p>While this example program is really only focused on the solution of the boundary integral equation, in a realistic setup one would still need to solve for the velocities. To this end, note that we have just computed <img class="formulaInl" alt="$\phi(\mathbf{x})$" src="form_2965.png"/> for all <img class="formulaInl" alt="$\mathbf{x}\in\partial\Omega$" src="form_2966.png"/>. In the next step, we can compute (analytically, if we want) the solution <img class="formulaInl" alt="$\phi(\mathbf{x})$" src="form_2965.png"/> in all of <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/>. To this end, recall that we had </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi(\mathbf{x}) = \phi_\infty + (D\phi)(\mathbf{x}) + \left(S[\mathbf{n}\cdot\mathbf{v}_\infty]\right)(\mathbf{x}) \qquad \forall\mathbf{x}\in \mathbb{R}^n\backslash\Omega. \]" src="form_2967.png"/>
</p>
<p> where now we have everything that is on the right hand side ( <img class="formulaInl" alt="$S$" src="form_731.png"/> and <img class="formulaInl" alt="$D$" src="form_1015.png"/> are integrals we can evaluate, the normal velocity on the boundary is given, and <img class="formulaInl" alt="$\phi$" src="form_643.png"/> on the boundary we have just computed). Finally, we can then recover the velocity as <img class="formulaInl" alt="$\mathbf{\tilde v}=\nabla \phi$" src="form_2968.png"/>.</p>
<p>Notice that the evaluation of the above formula for <img class="formulaInl" alt="$\mathbf{x} \in \Omega$" src="form_2969.png"/> should yield zero as a result, since the integration of the the Dirac delta <img class="formulaInl" alt="$\delta(\mathbf{x})$" src="form_2970.png"/> in the domain <img class="formulaInl" alt="$\mathbb{R}^n\backslash\Omega$" src="form_2933.png"/> is always zero by definition.</p>
<p>As a final test, let us verify that this velocity indeed satisfies the momentum balance equation for a stationary flow field, i.e., whether <img class="formulaInl" alt="$\mathbf{v}\cdot\nabla\mathbf{v} = -\frac 1\rho \nabla p$" src="form_2971.png"/> where <img class="formulaInl" alt="$\mathbf{v}=\mathbf{\tilde v}+\mathbf{v}_\infty=\nabla\phi+\mathbf{v}_\infty$" src="form_2972.png"/> for some (unknown) pressure <img class="formulaInl" alt="$p$" src="form_202.png"/> and a given constant <img class="formulaInl" alt="$\rho$" src="form_1591.png"/>. In other words, we would like to verify that Bernoulli's law as stated above indeed holds. To show this, we use that the left hand side of this equation equates to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf{v}\cdot\nabla\mathbf{v} &amp;= [(\nabla\phi+\mathbf{v}_\infty)\cdot\nabla] (\nabla\phi+\mathbf{v}_\infty) \\ &amp;= [(\nabla\phi+\mathbf{v}_\infty)\cdot\nabla] (\nabla\phi) \end{align*}" src="form_2973.png"/>
</p>
<p> where we have used that <img class="formulaInl" alt="$\mathbf{v}_\infty$" src="form_2928.png"/> is constant. We would like to write this expression as the gradient of something (remember that <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> is a constant). The next step is more convenient if we consider the components of the equation individually (summation over indices that appear twice is implied): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} [\mathbf{v}\cdot\nabla\mathbf{v}]_i &amp;= (\partial_j\phi+v_{\infty,j}) \partial_j \partial_i\phi \\ &amp;= \partial_j [(\partial_j\phi+v_{\infty,j}) \partial_i\phi] - \partial_j [(\partial_j\phi+v_{\infty,j})] \partial_i\phi \\ &amp;= \partial_j [(\partial_j\phi+v_{\infty,j}) \partial_i\phi] \end{align*}" src="form_2974.png"/>
</p>
<p> because <img class="formulaInl" alt="$\partial_j \partial_j\phi = \Delta \phi = 0$" src="form_2975.png"/> and <img class="formulaInl" alt="$\textrm{div} \ \mathbf{v}_\infty=0$" src="form_2976.png"/>. Next, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} [\mathbf{v}\cdot\nabla\mathbf{v}]_i &amp;= \partial_j [(\partial_j\phi+v_{\infty,j}) \partial_i\phi] \\ &amp;= \partial_j [(\partial_j\phi) (\partial_i\phi)] + \partial_j [v_{\infty,j} \partial_i\phi] \\ &amp;= \partial_j [(\partial_j\phi) (\partial_i\phi)] + \partial_j [v_{\infty,j}] \partial_i\phi + v_{\infty,j} \partial_j \partial_i\phi \\ &amp;= \partial_j [(\partial_j\phi) (\partial_i\phi)] + v_{\infty,j} \partial_j \partial_i\phi \\ &amp;= \partial_i \partial_j [(\partial_j\phi) \phi] - \partial_j [\partial_i (\partial_j\phi) \phi] + \partial_i [v_{\infty,j} \partial_j \phi] - \partial_i [v_{\infty,j}] \partial_j \phi \end{align*}" src="form_2977.png"/>
</p>
<p> Again, the last term disappears because <img class="formulaInl" alt="$\mathbf{v}_\infty$" src="form_2928.png"/> is constant and we can merge the first and third term into one: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} [\mathbf{v}\cdot\nabla\mathbf{v}]_i &amp;= \partial_i (\partial_j [(\partial_j\phi) \phi + v_{\infty,j} \partial_j \phi]) - \partial_j [\partial_i (\partial_j\phi) \phi] \\ &amp;= \partial_i [(\partial_j\phi)(\partial_j \phi) + v_{\infty,j} \partial_j \phi] - \partial_j [\partial_i (\partial_j\phi) \phi] \end{align*}" src="form_2978.png"/>
</p>
<p>We now only need to massage that last term a bit more. Using the product rule, we get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \partial_j [\partial_i (\partial_j\phi) \phi] &amp;= \partial_i [\partial_j \partial_j\phi] \phi + \partial_i [\partial_j \phi] (\partial_j \phi). \end{align*}" src="form_2979.png"/>
</p>
<p> The first of these terms is zero (because, again, the summation over <img class="formulaInl" alt="$j$" src="form_513.png"/> gives <img class="formulaInl" alt="$\Delta\phi$" src="form_2980.png"/>, which is zero). The last term can be written as <img class="formulaInl" alt="$\frac 12 \partial_i [(\partial_j\phi)(\partial_j\phi)]$" src="form_2981.png"/> which is in the desired gradient form. As a consequence, we can now finally state that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} [\mathbf{v}\cdot\nabla\mathbf{v}]_i &amp;= \partial_i (\partial_j [(\partial_j\phi) \phi + v_{\infty,j} \partial_j \phi]) - \partial_j [\partial_i (\partial_j\phi) \phi] \\ &amp;= \partial_i \left[ (\partial_j\phi)(\partial_j \phi) + v_{\infty,j} \partial_j \phi - \frac 12 (\partial_j\phi)(\partial_j\phi) \right], \\ &amp;= \partial_i \left[ \frac 12 (\partial_j\phi)(\partial_j \phi) + v_{\infty,j} \partial_j \phi \right], \end{align*}" src="form_2982.png"/>
</p>
<p> or in vector form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{v}\cdot\nabla\mathbf{v} = \nabla \left[ \frac 12 \mathbf{\tilde v}^2 + \mathbf{v}_{\infty} \cdot \mathbf{\tilde v} \right], \]" src="form_2983.png"/>
</p>
<p> or in other words: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p = -\rho \left[ \frac 12 \mathbf{\tilde v}^2 + \mathbf{v}_{\infty} \cdot \mathbf{\tilde v} \right] = -\rho \left[ \frac 12 \mathbf{v}^2 - \frac 12 \mathbf{v}_{\infty}^2 \right] . \]" src="form_2984.png"/>
</p>
<p> Because the pressure is only determined up to a constant (it appears only with a gradient in the equations), an equally valid definition is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p = -\frac 12 \rho \mathbf{v}^2 . \]" src="form_2985.png"/>
</p>
<p> This is exactly Bernoulli's law mentioned above.</p>
<p><a class="anchor" id="Thenumericalapproximation"></a></p><h3>The numerical approximation</h3>
<p>Numerical approximations of Boundary Integral Equations (BIE) are commonly referred to as the boundary element method or panel method (the latter expression being used mostly in the computational fluid dynamics community). The goal of the following test problem is to solve the integral formulation of the Laplace equation with Neumann boundary conditions, using a circle and a sphere respectively in two and three space dimensions, illustrating along the way the features that allow one to treat boundary element problems almost as easily as finite element problems using the deal.II library.</p>
<p>To this end, let <img class="formulaInl" alt="$\mathcal{T}_h = \bigcup_i K_i$" src="form_2986.png"/> be a subdivision of the manifold <img class="formulaInl" alt="$\Gamma = \partial \Omega$" src="form_2987.png"/> into <img class="formulaInl" alt="$M$" src="form_64.png"/> line segments if <img class="formulaInl" alt="$n=2$" src="form_2988.png"/>, or <img class="formulaInl" alt="$M$" src="form_64.png"/> quadrilaterals if <img class="formulaInl" alt="$n=3$" src="form_2989.png"/>. We will call each individual segment or quadrilateral an <em>element</em> or <em>cell</em>, independently of the dimension <img class="formulaInl" alt="$n$" src="form_73.png"/> of the surrounding space <img class="formulaInl" alt="$\mathbb{R}^n$" src="form_2953.png"/>. We define the finite dimensional space <img class="formulaInl" alt="$V_h$" src="form_79.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \label{eq:definition-Vh} V_h := \{ v \in C^0(\Gamma) \text{ s.t. } v|_{K_i} \in \mathcal{Q}^1(K_i), \forall i\}, \]" src="form_2990.png"/>
</p>
<p> with basis functions <img class="formulaInl" alt="$\psi_i(\mathbf{x})$" src="form_2991.png"/> for which we will use the usual <a class="el" href="classFE__Q.html">FE_Q</a> finite element, with the catch that this time it is defined on a manifold of codimension one (which we do by using the second template argument that is usually defaulted to equal the first; here, we will create objects <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim-1,dim&gt;</code> to indicate that we have <code>dim-1</code> dimensional cells in a <code>dim</code> dimensional space). An element <img class="formulaInl" alt="$\phi_h$" src="form_2992.png"/> of <img class="formulaInl" alt="$V_h$" src="form_79.png"/> is uniquely identified by the vector <img class="formulaInl" alt="$\boldsymbol{\phi}$" src="form_2993.png"/> of its coefficients <img class="formulaInl" alt="$\phi_i$" src="form_525.png"/>, that is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \label{eq:definition-of-element} \phi_h(\mathbf{x}) := \phi_i \psi_i(\mathbf{x}), \qquad \boldsymbol{\phi} := \{ \phi_i \}, \]" src="form_2994.png"/>
</p>
<p> where summation is implied over repeated indexes. Note that we could use discontinuous elements here &mdash; in fact, there is no real reason to use continuous ones since the integral formulation does not imply any derivatives on our trial functions so continuity is unnecessary, and often in the literature only piecewise constant elements are used.</p>
<p><a class="anchor" id="Collocationboundaryelementmethod"></a></p><h3>Collocation boundary element method </h3>
<p>By far, the most common approximation of boundary integral equations is by use of the collocation based boundary element method.</p>
<p>This method requires the evaluation of the boundary integral equation at a number of collocation points which is equal to the number of unknowns of the system. The choice of these points is a delicate matter, that requires a careful study. Assume that these points are known for the moment, and call them <img class="formulaInl" alt="$\mathbf x_i$" src="form_713.png"/> with <img class="formulaInl" alt="$i=0...n\_dofs$" src="form_2995.png"/>.</p>
<p>The problem then becomes: Given the datum <img class="formulaInl" alt="$\mathbf{v}_\infty$" src="form_2928.png"/>, find a function <img class="formulaInl" alt="$\phi_h$" src="form_2992.png"/> in <img class="formulaInl" alt="$V_h$" src="form_79.png"/> such that the following <img class="formulaInl" alt="$n\_dofs$" src="form_2996.png"/> equations are satisfied:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \alpha(\mathbf{x}_i) \phi_h(\mathbf{x}_i) - \int_{\Gamma_y} \frac{ \partial G(\mathbf{y}-\mathbf{x}_i)}{\partial\mathbf{n}_y } \phi_h(\mathbf{y}) \,ds_y = \int_{\Gamma_y} G(\mathbf{y}-\mathbf{x}_i) \, \mathbf{n}_y\cdot\mathbf{v_\infty} \,ds_y , \end{align*}" src="form_2997.png"/>
</p>
<p>where the quantity <img class="formulaInl" alt="$\alpha(\mathbf{x}_i)$" src="form_2998.png"/> is the fraction of (solid) angle by which the point <img class="formulaInl" alt="$\mathbf{x}_i$" src="form_1800.png"/> sees the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, as explained above, and we set <img class="formulaInl" alt="$\phi_\infty$" src="form_2950.png"/> to be zero. If the support points <img class="formulaInl" alt="$\mathbf{x}_i$" src="form_1800.png"/> are chosen appropriately, then the problem can be written as the following linear system:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \label{eq:linear-system} (\mathbf{A}+\mathbf{N})\boldsymbol\phi = \mathbf{b}, \]" src="form_2999.png"/>
</p>
<p>where</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \mathbf{A}_{ij}&amp;= \alpha(\mathbf{x}_i) \psi_j(\mathbf{x}_i) = 1+\int_\Gamma \frac{\partial G(\mathbf{y}-\mathbf{x}_i)}{\partial \mathbf{n}_y}\,ds_y \psi_j(\mathbf{x}_i) \\ \mathbf{N}_{ij}&amp;= - \int_\Gamma \frac{\partial G(\mathbf{y}-\mathbf{x}_i)}{\partial \mathbf{n}_y} \psi_j(\mathbf{y}) \,ds_y \\ \mathbf{b}_i&amp;= \int_\Gamma G(\mathbf{y}-\mathbf{x}_i) \, \mathbf{n}_y\cdot\mathbf{v_\infty} ds_y. \end{aligned} \]" src="form_3000.png"/>
</p>
<p>From a linear algebra point of view, the best possible choice of the collocation points is the one that renders the matrix <img class="formulaInl" alt="$\mathbf{A}+\mathbf{N}$" src="form_3001.png"/> the most diagonally dominant. A natural choice is then to select the <img class="formulaInl" alt="$\mathbf{x}_i$" src="form_1800.png"/> collocation points to be the support points of the nodal basis functions <img class="formulaInl" alt="$\psi_i(\mathbf{x})$" src="form_2991.png"/>. In that case, <img class="formulaInl" alt="$\psi_j(\mathbf{x}_i)=\delta_{ij}$" src="form_3002.png"/>, and as a consequence the matrix <img class="formulaInl" alt="$\mathbf{A}$" src="form_154.png"/> is diagonal with entries </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{A}_{ii} = 1+\int_\Gamma \frac{\partial G(\mathbf{y}-\mathbf{x}_i)}{\partial \mathbf{n}_y}\,ds_y = 1-\sum_j N_{ij}, \]" src="form_3003.png"/>
</p>
<p> where we have used that <img class="formulaInl" alt="$\sum_j \psi_j(\mathbf{y})=1$" src="form_3004.png"/> for the usual Lagrange elements. With this choice of collocation points, the computation of the entries of the matrices <img class="formulaInl" alt="$\mathbf{A}$" src="form_154.png"/>, <img class="formulaInl" alt="$\mathbf{N}$" src="form_1348.png"/> and of the right hand side <img class="formulaInl" alt="$\mathbf{b}$" src="form_1646.png"/> requires the evaluation of singular integrals on the elements <img class="formulaInl" alt="$K_i$" src="form_3005.png"/> of the triangulation <img class="formulaInl" alt="$\mathcal{T}_h$" src="form_3006.png"/>. As usual in these cases, all integrations are performed on a reference simple domain, i.e., we assume that each element <img class="formulaInl" alt="$K_i$" src="form_3005.png"/> of <img class="formulaInl" alt="$\mathcal{T}_h$" src="form_3006.png"/> can be expressed as a linear (in two dimensions) or bi-linear (in three dimensions) transformation of the reference boundary element <img class="formulaInl" alt="$\hat K := [0,1]^{n-1}$" src="form_3007.png"/>, and we perform the integrations after a change of variables from the real element <img class="formulaInl" alt="$K_i$" src="form_3005.png"/> to the reference element <img class="formulaInl" alt="$\hat K$" src="form_165.png"/>.</p>
<p><a class="anchor" id="Treatingthesingularintegrals"></a></p><h3>Treating the singular integrals. </h3>
<p>In two dimensions it is not necessary to compute the diagonal elements <img class="formulaInl" alt="$\mathbf{N}_{ii}$" src="form_3008.png"/> of the system matrix, since, even if the denominator goes to zero when <img class="formulaInl" alt="$\mathbf{x}=\mathbf{y}$" src="form_3009.png"/>, the numerator is always zero because <img class="formulaInl" alt="$\mathbf{n}_y$" src="form_3010.png"/> and <img class="formulaInl" alt="$(\mathbf{y}-\mathbf{x})$" src="form_3011.png"/> are orthogonal (on our polygonal approximation of the boundary of <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>), and the only singular integral arises in the computation of <img class="formulaInl" alt="$\mathbf{b}_i$" src="form_3012.png"/> on the i-th element of <img class="formulaInl" alt="$\mathcal{T}_h$" src="form_3006.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{1}{\pi} \int_{K_i} \ln|\mathbf{y}-\mathbf{x}_i| \, \mathbf{n}_y\cdot\mathbf{v_\infty} \,ds_y. \]" src="form_3013.png"/>
</p>
<p>This can be easily treated by the <a class="el" href="classQGaussLogR.html">QGaussLogR</a> quadrature formula.</p>
<p>Similarly, it is possible to use the <a class="el" href="classQGaussOneOverR.html">QGaussOneOverR</a> quadrature formula to perform the singular integrations in three dimensions. The interested reader will find detailed explanations on how these quadrature rules work in their documentation.</p>
<p>The resulting matrix <img class="formulaInl" alt="$\mathbf{A}+\mathbf{N}$" src="form_3001.png"/> is full. Depending on its size, it might be convenient to use a direct solver or an iterative one. For the purpose of this example code, we chose to use only an iterative solver, without providing any preconditioner.</p>
<p>If this were a production code rather than a demonstration of principles, there are techniques that are available to not store full matrices but instead store only those entries that are large and/or relevant. In the literature on boundary element methods, a plethora of methods is available that allows to determine which elements are important and which are not, leading to a significantly sparser representation of these matrices that also facilitates rapid evaluations of the scalar product between vectors and matrices. This not being the goal of this program, we leave this for more sophisticated implementations.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>The implementation is rather straight forward. The main point that hasn't been used in any of the previous tutorial programs is that most classes in deal.II are not only templated on the dimension, but in fact on the dimension of the manifold on which we pose the differential equation as well as the dimension of the space into which this manifold is embedded. By default, the second template argument equals the first, meaning for example that we want to solve on a two-dimensional region of two-dimensional space. The triangulation class to use in this case would be <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2&gt;</code>, which is an equivalent way of writing <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>.</p>
<p>However, this doesn't have to be so: in the current example, we will for example want to solve on the surface of a sphere, which is a two-dimensional manifold embedded in a three-dimensional space. Consequently, the right class will be <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code>, and correspondingly we will use <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;2,3&gt;</code> as the DoF handler class and <code><a class="el" href="classFE__Q.html">FE_Q</a>&lt;2,3&gt;</code> for finite elements.</p>
<p>Some further details on what one can do with things that live on curved manifolds can be found in the report <a href="http://www.dealii.org/reports/codimension-one/desimone-heltai-manigrasso.pdf" target="_top"><em>Tools for the Solution of PDEs Defined on Curved Manifolds with the deal.II Library</em> by A. DeSimone, L. Heltai, C. Manigrasso</a>. In addition, the <a class="el" href="step_38.html">step-38</a> tutorial program extends what we show here to cases where the equation posed on the manifold is not an integral operator but in fact involves derivatives.</p>
<p><a class="anchor" id="Testcase"></a></p><h3>Testcase</h3>
<p>The testcase we will be solving is for a circular (in 2d) or spherical (in 3d) obstacle. Meshes for these geometries will be read in from files in the current directory and an object of type <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a> will then be attached to the triangulation to allow mesh refinement that respects the continuous geometry behind the discrete initial mesh.</p>
<p>For a sphere of radius <img class="formulaInl" alt="$a$" src="form_523.png"/> translating at a velocity of <img class="formulaInl" alt="$U$" src="form_203.png"/> in the <img class="formulaInl" alt="$x$" src="form_9.png"/> direction, the potential reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \phi = -\frac{1}{2}U \left(\frac{a}{r}\right)3 r \cos\theta \end{align*}" src="form_3014.png"/>
</p>
<p> see, e.g. J. N. Newman, <em>Marine Hydrodynamics</em>, 1977, pp. 127. For unit speed and radius, and restricting <img class="formulaInl" alt="$(x,y,z)$" src="form_3015.png"/> to lie on the surface of the sphere, <img class="formulaInl" alt="$\phi = -x/2$" src="form_3016.png"/>. In the test problem, the flow is <img class="formulaInl" alt="$(1,1,1)$" src="form_3017.png"/>, so the appropriate exact solution on the surface of the sphere is the superposition of the above solution with the analogous solution along the <img class="formulaInl" alt="$y$" src="form_10.png"/> and <img class="formulaInl" alt="$z$" src="form_11.png"/> axes, or <img class="formulaInl" alt="$\phi = \frac{1}{2}(x + y + z)$" src="form_3018.png"/>. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with including a bunch of include files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/smartpointer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_selector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parsed_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_control.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div></div><!-- fragment --><p>And here are a few C++ standard header files that we will need:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>The last part of this preamble is to import everything in the dealii namespace into the one into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step34</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Singleanddoublelayeroperatorkernels"></a> </p><h3>Single and double layer operator kernels</h3>
<p>First, let us define a bit of the boundary integral equation machinery.</p>
<p>The following two functions are the actual calculations of the single and double layer potential kernels, that is <img class="formulaInl" alt="$G$" src="form_2300.png"/> and <img class="formulaInl" alt="$\nabla G$" src="form_3019.png"/>. They are well defined only if the vector <img class="formulaInl" alt="$R = \mathbf{y}-\mathbf{x}$" src="form_3020.png"/> is different from zero.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceKernel</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> single_layer(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &amp;R)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        <span class="keywordflow">return</span> (-std::log(R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>()) / (2*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) );</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        <span class="keywordflow">return</span> (1./( R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>()*4*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> ) );</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">return</span> 0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> double_layer(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &amp;R)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        <span class="keywordflow">return</span> R / ( -2*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * R.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>());</div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        <span class="keywordflow">return</span> R / ( -4*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * R.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() * R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>() );</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a>();</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBEMProblemclass"></a> </p><h3>The BEMProblem class</h3>
<p>The structure of a boundary element method code is very similar to the structure of a finite element code, and so the member functions of this class are like those of most of the other tutorial programs. In particular, by now you should be familiar with reading parameters from an external file, and with the splitting of the different tasks into different modules. The same applies to boundary element methods, and we won't comment too much on them, except on the differences.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BEMProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BEMProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree = 1,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree = 1);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> read_parameters (<span class="keyword">const</span> std::string &amp;filename);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> refine_and_resize();</div></div><!-- fragment --><p>The only really different function that we find here is the assembly routine. We wrote this function in the most possible general way, in order to allow for easy generalization to higher order methods and to different fundamental solutions (e.g., Stokes or Maxwell).</p>
<p>The most noticeable difference is the fact that the final matrix is full, and that we have a nested loop inside the usual loop on cells that visits all support points of the degrees of freedom. Moreover, when the support point lies inside the cell which we are visiting, then the integral we perform becomes singular.</p>
<p>The practical consequence is that we have two sets of quadrature formulas, finite element values and temporary storage, one for standard integration and one for the singular integration, which are used where necessary.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system();</div></div><!-- fragment --><p>There are two options for the solution of this problem. The first is to use a direct solver, and the second is to use an iterative solver. We opt for the second option.</p>
<p>The matrix that we assemble is not symmetric, and we opt to use the GMRES method; however the construction of an efficient preconditioner for boundary element methods is not a trivial issue. Here we use a non preconditioned GMRES solver. The options for the iterative solver, such as the tolerance, the maximum number of iterations, are selected through the parameter file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve_system();</div></div><!-- fragment --><p>Once we obtained the solution, we compute the <img class="formulaInl" alt="$L^2$" src="form_700.png"/> error of the computed potential as well as the <img class="formulaInl" alt="$L^\infty$" src="form_2795.png"/> error of the approximation of the solid angle. The mesh we are using is an approximation of a smooth curve, therefore the computed diagonal matrix of fraction of angles or solid angles <img class="formulaInl" alt="$\alpha(\mathbf{x})$" src="form_2957.png"/> should be constantly equal to <img class="formulaInl" alt="$\frac 12$" src="form_1656.png"/>. In this routine we output the error on the potential and the error in the approximation of the computed angle. Notice that the latter error is actually not the error in the computation of the angle, but a measure of how well we are approximating the sphere and the circle.</p>
<p>Experimenting a little with the computation of the angles gives very accurate results for simpler geometries. To verify this you can comment out, in the read_domain() method, the tria.set_manifold(1, manifold) line, and check the alpha that is generated by the program. By removing this call, whenever the mesh is refined new nodes will be placed along the straight lines that made up the coarse mesh, rather than be pulled onto the surface that we really want to approximate. In the three dimensional case, the coarse grid of the sphere is obtained starting from a cube, and the obtained values of alphas are exactly <img class="formulaInl" alt="$\frac 12$" src="form_1656.png"/> on the nodes of the faces, <img class="formulaInl" alt="$\frac 34$" src="form_3021.png"/> on the nodes of the edges and <img class="formulaInl" alt="$\frac 78$" src="form_2660.png"/> on the 8 nodes of the vertices.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compute_errors(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Once we obtained a solution on the codimension one domain, we want to interpolate it to the rest of the space. This is done by performing again the convolution of the solution with the kernel in the compute_exterior_solution() function.</p>
<p>We would like to plot the velocity variable which is the gradient of the potential solution. The potential solution is only known on the boundary, but we use the convolution with the fundamental solution to interpolate it on a standard dim dimensional continuous finite element space. The plot of the gradient of the extrapolated solution will give us the velocity we want.</p>
<p>In addition to the solution on the exterior domain, we also output the solution on the domain's boundary in the output_results() function, of course.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compute_exterior_solution();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>To allow for dimension independent programming, we specialize this single function to extract the singular quadrature formula needed to integrate the singular kernels in the interior of the cells.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &amp; get_singular_quadrature(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;dim-1, dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The usual deal.II classes can be used for boundary element methods by specifying the "codimension" of the problem. This is done by setting the optional second template arguments to <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classFiniteElement.html">FiniteElement</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> to the dimension of the embedding space. In our case we generate either 1 or 2 dimensional meshes embedded in 2 or 3 dimensional spaces.</p>
<p>The optional argument by default is equal to the first argument, and produces the usual finite element classes that we saw in all previous examples.</p>
<p>The class is constructed in a way to allow for arbitrary order of approximation of both the domain (through high order mapping) and the finite element space. The order of the finite element space and of the mapping can be selected in the constructor of the class.</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim-1, dim&gt;   tria;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim-1,dim&gt;             fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;       dh;</div><div class="line"><a class="code" href="classMappingQ.html">MappingQ</a>&lt;dim-1, dim&gt;      mapping;</div></div><!-- fragment --><p>In BEM methods, the matrix that is generated is dense. Depending on the size of the problem, the final system might be solved by direct LU decomposition, or by iterative methods. In this example we use an unpreconditioned GMRES method. Building a preconditioner for BEM method is non trivial, and we don't treat this subject here.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    system_matrix;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>        system_rhs;</div></div><!-- fragment --><p>The next two variables will denote the solution <img class="formulaInl" alt="$\phi$" src="form_643.png"/> as well as a vector that will hold the values of <img class="formulaInl" alt="$\alpha(\mathbf x)$" src="form_3022.png"/> (the fraction of <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> visible from a point <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/>) at the support points of our shape functions.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>              phi;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>              alpha;</div></div><!-- fragment --><p>The convergence table is used to output errors in the exact solution and in the computed alphas.</p>
<div class="fragment"><div class="line"><a class="code" href="classConvergenceTable.html">ConvergenceTable</a>  convergence_table;</div></div><!-- fragment --><p>The following variables are the ones that we fill through a parameter file. The new objects that we use in this example are the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> object and the <a class="el" href="classQuadratureSelector.html">QuadratureSelector</a> object.</p>
<p>The <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class allows us to easily and quickly define new function objects via parameter files, with custom definitions which can be very complex (see the documentation of that class for all the available options).</p>
<p>We will allocate the quadrature object using the <a class="el" href="classQuadratureSelector.html">QuadratureSelector</a> class that allows us to generate quadrature formulas based on an identifying string and on the possible degree of the formula itself. We used this to allow custom selection of the quadrature formulas for the standard integration, and to define the order of the singular quadrature rule.</p>
<p>We also define a couple of parameters which are used in case we wanted to extend the solution to the entire domain.</p>
<div class="fragment"><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;dim&gt;</a> wind;</div><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;dim&gt;</a> exact_solution;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> singular_quadrature_order;</div><div class="line">  std::shared_ptr&lt;<a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &gt; quadrature;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> external_refinement;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> run_in_this_dimension;</div><div class="line">  <span class="keywordtype">bool</span> extend_solution;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemBEMProblemandBEMProblemread_parameters"></a> </p><h4>BEMProblem::BEMProblem and BEMProblem::read_parameters</h4>
<p>The constructor initializes the various object in much the same way as done in the finite element programs such as <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>. The only new ingredient here is the ParsedFunction object, which needs, at construction time, the specification of the number of components.</p>
<p>For the exact solution the number of vector components is one, and no action is required since one is the default value for a ParsedFunction object. The wind, however, requires dim components to be specified. Notice that when declaring entries in a parameter file for the expression of the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a>, we need to specify the number of components explicitly, since the function <a class="el" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction::declare_parameters</a> is static, and has no knowledge of the number of components.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BEMProblem&lt;dim&gt;::BEMProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree)</div><div class="line">  :</div><div class="line">  fe(fe_degree),</div><div class="line">  dh(tria),</div><div class="line">  mapping(mapping_degree, true),</div><div class="line">  wind(dim),</div><div class="line">  singular_quadrature_order(5),</div><div class="line">  n_cycles(4),</div><div class="line">  external_refinement(5),</div><div class="line">  run_in_this_dimension(true),</div><div class="line">  extend_solution(true)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::read_parameters (<span class="keyword">const</span> std::string &amp;filename)</div><div class="line">{</div><div class="line">  deallog &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Parsing parameter file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;for a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; dimensional simulation. &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Number of cycles&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;External refinement&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Extend solution on the -2,2 box&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Run 2d simulation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Run 3d simulation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Quadrature rules&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature type&quot;</span>, <span class="stringliteral">&quot;gauss&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<a class="code" href="classQuadratureSelector.html">QuadratureSelector</a>&lt;(dim-1)&gt;::get_quadrature_names()));</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Singular quadrature order&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>For both two and three dimensions, we set the default input data to be such that the solution is <img class="formulaInl" alt="$x+y$" src="form_3023.png"/> or <img class="formulaInl" alt="$x+y+z$" src="form_3024.png"/>. The actually computed solution will have value zero at infinity. In this case, this coincide with the exact solution, and no additional corrections are needed, but you should be aware of the fact that we arbitrarily set <img class="formulaInl" alt="$\phi_\infty$" src="form_2950.png"/>, and the exact solution we pass to the program needs to have the same value at infinity for the error to be computed correctly.</p>
<p>The use of the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> object is pretty straight forward. The <a class="el" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction::declare_parameters</a> function takes an additional integer argument that specifies the number of components of the given function. Its default value is one. When the corresponding <a class="el" href="classFunctions_1_1ParsedFunction.html#ad63dc7cf2f447d3acfec839f28416914">Functions::ParsedFunction::parse_parameters</a> method is called, the calling object has to have the same number of components defined here, otherwise an exception is thrown.</p>
<p>When declaring entries, we declare both 2 and three dimensional functions. However only the dim-dimensional one is ultimately parsed. This allows us to have only one parameter file for both 2 and 3 dimensional problems.</p>
<p>Notice that from a mathematical point of view, the wind function on the boundary should satisfy the condition <img class="formulaInl" alt="$\int_{\partial\Omega} \mathbf{v}\cdot \mathbf{n} d \Gamma = 0$" src="form_3025.png"/>, for the problem to have a solution. If this condition is not satisfied, then no solution can be found, and the solver will not converge.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Wind function 2d&quot;</span>);</div><div class="line">{</div><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;2&gt;::declare_parameters</a>(prm, 2);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1; 1&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Wind function 3d&quot;</span>);</div><div class="line">{</div><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;3&gt;::declare_parameters</a>(prm, 3);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1; 1; 1&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Exact solution 2d&quot;</span>);</div><div class="line">{</div><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;2&gt;::declare_parameters</a>(prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;x+y&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Exact solution 3d&quot;</span>);</div><div class="line">{</div><div class="line">  <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;3&gt;::declare_parameters</a>(prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;x+y+z&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>In the solver section, we set all <a class="el" href="classSolverControl.html">SolverControl</a> parameters. The object will then be fed to the GMRES solver in the solve_system() function.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line"><a class="code" href="classSolverControl.html#a0bb6dc567e07e9f7b0a9d09f801bf149">SolverControl::declare_parameters</a>(prm);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>After declaring all these parameters to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object, let's read an input file that will give the parameters their values. We then proceed to extract these values from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a>(filename);</div><div class="line"></div><div class="line">n_cycles = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of cycles&quot;</span>);</div><div class="line">external_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;External refinement&quot;</span>);</div><div class="line">extend_solution = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Extend solution on the -2,2 box&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Quadrature rules&quot;</span>);</div><div class="line">{</div><div class="line">  quadrature =</div><div class="line">    std::shared_ptr&lt;<a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &gt;</div><div class="line">    (<span class="keyword">new</span> <a class="code" href="classQuadratureSelector.html">QuadratureSelector</a>&lt;dim-1&gt; (prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Quadrature type&quot;</span>),</div><div class="line">                                    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>)));</div><div class="line">  singular_quadrature_order = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Singular quadrature order&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(std::string(<span class="stringliteral">&quot;Wind function &quot;</span>)+</div><div class="line">                     <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim)+std::string(<span class="stringliteral">&quot;d&quot;</span>));</div><div class="line">{</div><div class="line">  wind.parse_parameters(prm);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(std::string(<span class="stringliteral">&quot;Exact solution &quot;</span>)+</div><div class="line">                     <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim)+std::string(<span class="stringliteral">&quot;d&quot;</span>));</div><div class="line">{</div><div class="line">  exact_solution.parse_parameters(prm);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">solver_control.parse_parameters(prm);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div></div><!-- fragment --><p>Finally, here's another example of how to use parameter files in dimension independent programming. If we wanted to switch off one of the two simulations, we could do this by setting the corresponding "Run
   2d simulation" or "Run 3d simulation" flag to false:</p>
<div class="fragment"><div class="line">  run_in_this_dimension = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Run &quot;</span> +</div><div class="line">                                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) +</div><div class="line">                                       <span class="stringliteral">&quot;d simulation&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemread_domain"></a> </p><h4>BEMProblem::read_domain</h4>
<p>A boundary element method triangulation is basically the same as a (dim-1) dimensional triangulation, with the difference that the vertices belong to a (dim) dimensional space.</p>
<p>Some of the mesh formats supported in deal.II use by default three dimensional points to describe meshes. These are the formats which are compatible with the boundary element method capabilities of deal.II. In particular we can use either UCD or GMSH formats. In both cases, we have to be particularly careful with the orientation of the mesh, because, unlike in the standard finite element case, no reordering or compatibility check is performed here. All meshes are considered as oriented, because they are embedded in a higher dimensional space. (See the documentation of the <a class="el" href="classGridIn.html">GridIn</a> and of the <a class="el" href="classTriangulation.html">Triangulation</a> for further details on orientation of cells in a triangulation.) In our case, the normals to the mesh are external to both the circle in 2d or the sphere in 3d.</p>
<p>The other detail that is required for appropriate refinement of the boundary element mesh, is an accurate description of the manifold that the mesh is approximating. We already saw this several times for the boundary of standard finite element meshes (for example in <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a>), and here the principle and usage is the same, except that the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class takes an additional template parameter that specifies the embedding space dimension. The function object still has to be static to live at least as long as the triangulation object to which it is attached.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::read_domain()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold</a>&lt;dim-1, dim&gt; manifold(center);</div><div class="line"></div><div class="line">  std::ifstream in;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">      in.open (<span class="stringliteral">&quot;coarse_circle.inp&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">      in.open (<span class="stringliteral">&quot;coarse_sphere.inp&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn</a>&lt;dim-1, dim&gt; gi;</div><div class="line">  gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a> (tria);</div><div class="line">  gi.read_ucd (in);</div><div class="line"></div><div class="line">  tria.set_all_manifold_ids(1);</div><div class="line">  tria.set_manifold(1, manifold);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemrefine_and_resize"></a> </p><h4>BEMProblem::refine_and_resize</h4>
<p>This function globally refines the mesh, distributes degrees of freedom, and resizes matrices and vectors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::refine_and_resize()</div><div class="line">{</div><div class="line">  tria.refine_global(1);</div><div class="line"></div><div class="line">  dh.distribute_dofs(fe);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =  dh.n_dofs();</div><div class="line"></div><div class="line">  system_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">  system_rhs.reinit(n_dofs);</div><div class="line">  phi.reinit(n_dofs);</div><div class="line">  alpha.reinit(n_dofs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemassemble_system"></a> </p><h4>BEMProblem::assemble_system</h4>
<p>The following is the main function of this program, assembling the matrix that corresponds to the boundary integral equation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div></div><!-- fragment --><p>First we initialize an <a class="el" href="classFEValues.html">FEValues</a> object with the quadrature formula for the integration of the kernel in non singular cells. This quadrature is selected with the parameter file, and needs to be quite precise, since the functions we are integrating are not polynomial functions.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v(mapping, fe, *quadrature,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; cell_wind(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line"><span class="keywordtype">double</span> normal_wind;</div></div><!-- fragment --><p>Unlike in finite element methods, if we use a collocation boundary element method, then in each assembly loop we only assemble the information that refers to the coupling between one degree of freedom (the degree associated with support point <img class="formulaInl" alt="$i$" src="form_90.png"/>) and the current cell. This is done using a vector of fe.dofs_per_cell elements, which will then be distributed to the matrix in the global row <img class="formulaInl" alt="$i$" src="form_90.png"/>. The following object will hold this information:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>      local_matrix_row_i(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div></div><!-- fragment --><p>The index <img class="formulaInl" alt="$i$" src="form_90.png"/> runs on the collocation points, which are the support points of the <img class="formulaInl" alt="$i$" src="form_90.png"/>th basis function, while <img class="formulaInl" alt="$j$" src="form_513.png"/> runs on inner integration points.</p>
<p>We construct a vector of support points which will be used in the local integrations:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;dim&gt; &gt; support_points(dh.n_dofs());</div><div class="line"><a class="code" href="namespaceDoFTools.html#a10af6ba7adc43214e7b9f6815588f2aa">DoFTools::map_dofs_to_support_points</a>&lt;dim-1, dim&gt;( mapping, dh, support_points);</div></div><!-- fragment --><p>After doing so, we can start the integration loop over all cells, where we first initialize the <a class="el" href="classFEValues.html">FEValues</a> object and get the values of <img class="formulaInl" alt="$\mathbf{\tilde v}$" src="form_3026.png"/> at the quadrature points (this vector field should be constant, but it doesn't hurt to be more general):</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;::active_cell_iterator</div><div class="line">cell = dh.begin_active(),</div><div class="line">endc = dh.end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (cell = dh.begin_active(); cell != endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_v.reinit(cell);</div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;q_points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals  = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a>();</div><div class="line">    wind.vector_value_list(q_points, cell_wind);</div></div><!-- fragment --><p>We then form the integral over the current cell for all degrees of freedom (note that this includes degrees of freedom not located on the current cell, a deviation from the usual finite element integrals). The integral that we need to perform is singular if one of the local degrees of freedom is the same as the support point <img class="formulaInl" alt="$i$" src="form_90.png"/>. A the beginning of the loop we therefore check whether this is the case, and we store which one is the singular index:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dh.n_dofs() ; ++i)</div><div class="line">  {</div><div class="line"></div><div class="line">    local_matrix_row_i = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_singular = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> singular_index = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">      <span class="keywordflow">if</span> (local_dof_indices[j] == i)</div><div class="line">        {</div><div class="line">          singular_index = j;</div><div class="line">          is_singular = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div></div><!-- fragment --><p>We then perform the integral. If the index <img class="formulaInl" alt="$i$" src="form_90.png"/> is not one of the local degrees of freedom, we simply have to add the single layer terms to the right hand side, and the double layer terms to the matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (is_singular == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        normal_wind = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">          normal_wind += normals[q][d]*cell_wind[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = q_points[q] - support_points[i];</div><div class="line"></div><div class="line">        system_rhs(i) += ( LaplaceKernel::single_layer(R)   *</div><div class="line">                           normal_wind                      *</div><div class="line">                           fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) );</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line"></div><div class="line">          local_matrix_row_i(j) -= ( ( LaplaceKernel::double_layer(R)     *</div><div class="line">                                       normals[q] )            *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q)     *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)       );</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>Now we treat the more delicate case. If we are here, this means that the cell that runs on the <img class="formulaInl" alt="$j$" src="form_513.png"/> index contains support_point[i]. In this case both the single and the double layer potential are singular, and they require special treatment.</p>
<p>Whenever the integration is performed with the singularity inside the given cell, then a special quadrature formula is used that allows one to integrate arbitrary functions against a singular weight on the reference cell.</p>
<p>The correct quadrature formula is selected by the get_singular_quadrature function, which is explained in detail below.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(singular_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &amp; singular_quadrature =</div><div class="line">    get_singular_quadrature(cell, singular_index);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v_singular (mapping, fe, singular_quadrature,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa9e3f2944ebdadf4409dc11f8fc0afe14">update_jacobians</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> );</div><div class="line"></div><div class="line">  fe_v_singular.reinit(cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; singular_cell_wind( singular_quadrature.size(),</div><div class="line">                                                   <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;singular_normals  = fe_v_singular.get_all_normal_vectors();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;singular_q_points = fe_v_singular.get_quadrature_points();</div><div class="line"></div><div class="line">  wind.vector_value_list(singular_q_points, singular_cell_wind);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;singular_quadrature.size(); ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = singular_q_points[q] - support_points[i];</div><div class="line">      <span class="keywordtype">double</span> normal_wind = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">        normal_wind += (singular_cell_wind[q](d)*</div><div class="line">                        singular_normals[q][d]);</div><div class="line"></div><div class="line">      system_rhs(i) += ( LaplaceKernel::single_layer(R) *</div><div class="line">                         normal_wind                         *</div><div class="line">                         fe_v_singular.JxW(q) );</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">        {</div><div class="line">          local_matrix_row_i(j) -= (( LaplaceKernel::double_layer(R) *</div><div class="line">                                      singular_normals[q])                *</div><div class="line">                                    fe_v_singular.shape_value(j,q)        *</div><div class="line">                                    fe_v_singular.JxW(q)       );</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we need to add the contributions of the current cell to the global matrix.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">        system_matrix(i,local_dof_indices[j])</div><div class="line">        += local_matrix_row_i(j);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The second part of the integral operator is the term <img class="formulaInl" alt="$\alpha(\mathbf{x}_i) \phi_j(\mathbf{x}_i)$" src="form_3027.png"/>. Since we use a collocation scheme, <img class="formulaInl" alt="$\phi_j(\mathbf{x}_i)=\delta_{ij}$" src="form_3028.png"/> and the corresponding matrix is a diagonal one with entries equal to <img class="formulaInl" alt="$\alpha(\mathbf{x}_i)$" src="form_2998.png"/>.</p>
<p>One quick way to compute this diagonal matrix of the solid angles, is to use the Neumann matrix itself. It is enough to multiply the matrix with a vector of elements all equal to -1, to get the diagonal matrix of the alpha angles, or solid angles (see the formula in the introduction for this). The result is then added back onto the system matrix object to yield the final form of the matrix:</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> ones(dh.n_dofs());</div><div class="line">  ones.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(-1.);</div><div class="line"></div><div class="line">  system_matrix.vmult(alpha, ones);</div><div class="line">  alpha.add(1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;dh.n_dofs(); ++i)</div><div class="line">    system_matrix(i,i) +=  alpha(i);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemsolve_system"></a> </p><h4>BEMProblem::solve_system</h4>
<p>The next function simply solves the linear system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::solve_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a> &gt; solver (solver_control);</div><div class="line">  solver.solve (system_matrix, phi, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemcompute_errors"></a> </p><h4>BEMProblem::compute_errors</h4>
<p>The computation of the errors is exactly the same in all other example programs, and we won't comment too much. Notice how the same methods that are used in the finite element methods can be used here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::compute_errors(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (tria.n_active_cells());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (mapping, dh, phi,</div><div class="line">                                     exact_solution,</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss</a>&lt;(dim-1)&gt;(2*fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(tria,</div><div class="line">                                                            difference_per_cell,</div><div class="line">                                                            <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div></div><!-- fragment --><p>The error in the alpha vector can be computed directly using the <a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">Vector::linfty_norm()</a> function, since on each node, the value should be <img class="formulaInl" alt="$\frac 12$" src="form_1656.png"/>. All errors are then output and appended to our <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> object for later computation of convergence rates:</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> difference_per_node(alpha);</div><div class="line">  difference_per_node.add(-.5);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_error = difference_per_node.linfty_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells=tria.n_active_cells();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs=dh.n_dofs();</div><div class="line"></div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">          &lt;&lt; n_active_cells</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; n_dofs</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, n_active_cells);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, n_dofs);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;L2(phi)&quot;</span>, L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, alpha_error);</div><div class="line">}</div></div><!-- fragment --><p>Singular integration requires a careful selection of the quadrature rules. In particular the deal.II library provides quadrature rules which are tailored for logarithmic singularities (<a class="el" href="classQGaussLog.html">QGaussLog</a>, <a class="el" href="classQGaussLogR.html">QGaussLogR</a>), as well as for 1/R singularities (<a class="el" href="classQGaussOneOverR.html">QGaussOneOverR</a>).</p>
<p>Singular integration is typically obtained by constructing weighted quadrature formulas with singular weights, so that it is possible to write</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_K f(x) s(x) dx = \sum_{i=1}^N w_i f(q_i) \]" src="form_3029.png"/>
</p>
<p>where <img class="formulaInl" alt="$s(x)$" src="form_3030.png"/> is a given singularity, and the weights and quadrature points <img class="formulaInl" alt="$w_i,q_i$" src="form_3031.png"/> are carefully selected to make the formula above an equality for a certain class of functions <img class="formulaInl" alt="$f(x)$" src="form_418.png"/>.</p>
<p>In all the finite element examples we have seen so far, the weight of the quadrature itself (namely, the function <img class="formulaInl" alt="$s(x)$" src="form_3030.png"/>), was always constantly equal to 1. For singular integration, we have two choices: we can use the definition above, factoring out the singularity from the integrand (i.e., integrating <img class="formulaInl" alt="$f(x)$" src="form_418.png"/> with the special quadrature rule), or we can ask the quadrature rule to "normalize" the weights <img class="formulaInl" alt="$w_i$" src="form_3032.png"/> with <img class="formulaInl" alt="$s(q_i)$" src="form_3033.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_K f(x) s(x) dx = \int_K g(x) dx = \sum_{i=1}^N \frac{w_i}{s(q_i)} g(q_i) \]" src="form_3034.png"/>
</p>
<p>We use this second option, through the <code>factor_out_singularity</code> parameter of both <a class="el" href="classQGaussLogR.html">QGaussLogR</a> and <a class="el" href="classQGaussOneOverR.html">QGaussOneOverR</a>.</p>
<p>These integrals are somewhat delicate, especially in two dimensions, due to the transformation from the real to the reference cell, where the variable of integration is scaled with the determinant of the transformation.</p>
<p>In two dimensions this process does not result only in a factor appearing as a constant factor on the entire integral, but also on an additional integral altogether that needs to be evaluated:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_0^1 f(x)\ln(x/\alpha) dx = \int_0^1 f(x)\ln(x) dx - \int_0^1 f(x) \ln(\alpha) dx. \]" src="form_3035.png"/>
</p>
<p>This process is taken care of by the constructor of the <a class="el" href="classQGaussLogR.html">QGaussLogR</a> class, which adds additional quadrature points and weights to take into consideration also the second part of the integral.</p>
<p>A similar reasoning should be done in the three dimensional case, since the singular quadrature is tailored on the inverse of the radius <img class="formulaInl" alt="$r$" src="form_267.png"/> in the reference cell, while our singular function lives in real space, however in the three dimensional case everything is simpler because the singularity scales linearly with the determinant of the transformation. This allows us to build the singular two dimensional quadrature rules only once and, reuse them over all cells.</p>
<p>In the one dimensional singular integration this is not possible, since we need to know the scaling parameter for the quadrature, which is not known a priori. Here, the quadrature rule itself depends also on the size of the current cell. For this reason, it is necessary to create a new quadrature for each singular integration.</p>
<p>The different quadrature rules are built inside the get_singular_quadrature, which is specialized for dim=2 and dim=3, and they are retrieved inside the assemble_system function. The index given as an argument is the index of the unit support point where the singularity is located.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;2&gt;</a> &amp;BEMProblem&lt;3&gt;::get_singular_quadrature(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2,3&gt;::active_cell_iterator</a> &amp;,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(index &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(0, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, index));</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;QGaussOneOverR&lt;2&gt; &gt; quadratures;</div><div class="line">  <span class="keywordflow">if</span> (quadratures.size() == 0)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">      quadratures.push_back(<a class="code" href="classQGaussOneOverR.html">QGaussOneOverR&lt;2&gt;</a>(singular_quadrature_order,</div><div class="line">                                              fe.<a class="code" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a>()[i],</div><div class="line">                                              <span class="keyword">true</span>));</div><div class="line">  <span class="keywordflow">return</span> quadratures[index];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;1&gt;</a> &amp;BEMProblem&lt;2&gt;::get_singular_quadrature(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;1,2&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(index &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(0, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, index));</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <a class="code" href="classQuadrature.html">Quadrature&lt;1&gt;</a> *q_pointer = <span class="keyword">nullptr</span>;</div><div class="line">  <span class="keywordflow">if</span> (q_pointer) <span class="keyword">delete</span> q_pointer;</div><div class="line"></div><div class="line">  q_pointer = <span class="keyword">new</span> <a class="code" href="classQGaussLogR.html">QGaussLogR&lt;1&gt;</a>(singular_quadrature_order,</div><div class="line">                                fe.<a class="code" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a>()[index],</div><div class="line">                                1./cell-&gt;measure(), <span class="keyword">true</span>);</div><div class="line">  <span class="keywordflow">return</span> (*q_pointer);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemcompute_exterior_solution"></a> </p><h4>BEMProblem::compute_exterior_solution</h4>
<p>We'd like to also know something about the value of the potential <img class="formulaInl" alt="$\phi$" src="form_643.png"/> in the exterior domain: after all our motivation to consider the boundary integral problem was that we wanted to know the velocity in the exterior domain!</p>
<p>To this end, let us assume here that the boundary element domain is contained in the box <img class="formulaInl" alt="$[-2,2]^{\text{dim}}$" src="form_3036.png"/>, and we extrapolate the actual solution inside this box using the convolution with the fundamental solution. The formula for this is given in the introduction.</p>
<p>The reconstruction of the solution in the entire space is done on a continuous finite element grid of dimension dim. These are the usual ones, and we don't comment any further on them. At the end of the function, we output this exterior solution in, again, much the usual way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::compute_exterior_solution()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>  external_tria;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(external_tria, -2, 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>           external_fe(1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     external_dh (external_tria);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>      external_phi;</div><div class="line"></div><div class="line">  external_tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(external_refinement);</div><div class="line">  external_dh.distribute_dofs(external_fe);</div><div class="line">  external_phi.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(external_dh.n_dofs());</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;::active_cell_iterator</div><div class="line">  cell = dh.begin_active(),</div><div class="line">  endc = dh.end();</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v(mapping, fe, *quadrature,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; dofs(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; local_phi(n_q_points);</div><div class="line">  std::vector&lt;double&gt; normal_wind(n_q_points);</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; local_wind(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line"></div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt; external_support_points(external_dh.n_dofs());</div><div class="line">  DoFTools::map_dofs_to_support_points&lt;dim&gt;(<a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;dim&gt;::mapping</a>,</div><div class="line">                                            external_dh, external_support_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (cell = dh.begin_active(); cell != endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_v.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;q_points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals  = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a>();</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(dofs);</div><div class="line">      fe_v.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(phi, local_phi);</div><div class="line"></div><div class="line">      wind.vector_value_list(q_points, local_wind);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          normal_wind[q] = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">            normal_wind[q] += normals[q][d]*local_wind[q](d);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;external_dh.n_dofs(); ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          {</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = q_points[q] - external_support_points[i];</div><div class="line"></div><div class="line">            external_phi(i) += ( ( LaplaceKernel::single_layer(R) *</div><div class="line">                                   normal_wind[q]</div><div class="line">                                   +</div><div class="line">                                   (LaplaceKernel::double_layer(R) *</div><div class="line">                                    normals[q] )            *</div><div class="line">                                   local_phi[q] )           *</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) );</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(external_dh);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(external_phi, <span class="stringliteral">&quot;external_phi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string</div><div class="line">  filename = <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) + <span class="stringliteral">&quot;d_external.vtk&quot;</span>;</div><div class="line">  std::ofstream file(filename.c_str());</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemoutput_results"></a> </p><h4>BEMProblem::output_results</h4>
<p>Outputting the results of our computations is a rather mechanical tasks. All the components of this function have been discussed before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1, dim&gt; &gt; dataout;</div><div class="line"></div><div class="line">  dataout.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dh);</div><div class="line">  dataout.add_data_vector(phi, <span class="stringliteral">&quot;phi&quot;</span>,</div><div class="line">                          <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim-1, dim&gt;</a> &gt;::type_dof_data);</div><div class="line">  dataout.add_data_vector(alpha, <span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                          <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim-1, dim&gt;</a> &gt;::type_dof_data);</div><div class="line">  dataout.build_patches(mapping,</div><div class="line">                        mapping.get_degree(),</div><div class="line">                        <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1, dim&gt; &gt;::curved_inner_cells);</div><div class="line"></div><div class="line">  std::string filename = ( <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) +</div><div class="line">                           <span class="stringliteral">&quot;d_boundary_solution_&quot;</span> +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) +</div><div class="line">                           <span class="stringliteral">&quot;.vtk&quot;</span> );</div><div class="line">  std::ofstream file(filename.c_str());</div><div class="line"></div><div class="line">  dataout.write_vtk(file);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cycle == n_cycles-1)</div><div class="line">    {</div><div class="line">      convergence_table.set_precision(<span class="stringliteral">&quot;L2(phi)&quot;</span>, 3);</div><div class="line">      convergence_table.set_precision(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, 3);</div><div class="line"></div><div class="line">      convergence_table.set_scientific(<span class="stringliteral">&quot;L2(phi)&quot;</span>, <span class="keyword">true</span>);</div><div class="line">      convergence_table.set_scientific(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      convergence_table</div><div class="line">      .evaluate_convergence_rates(<span class="stringliteral">&quot;L2(phi)&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">      convergence_table</div><div class="line">      .evaluate_convergence_rates(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">      deallog &lt;&lt; std::endl;</div><div class="line">      convergence_table.write_text(std::cout);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BEMProblemrun"></a> </p><h4>BEMProblem::run</h4>
<p>This is the main function. It should be self explanatory in its briefness:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::run()</div><div class="line">  {</div><div class="line"></div><div class="line">    read_parameters(<span class="stringliteral">&quot;parameters.prm&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (run_in_this_dimension == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Run in dimension &quot;</span> &lt;&lt; dim</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; explicitly disabled in parameter file. &quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_and_resize();</div><div class="line">        assemble_system();</div><div class="line">        solve_system();</div><div class="line">        compute_errors(cycle);</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (extend_solution == <span class="keyword">true</span>)</div><div class="line">      compute_exterior_solution();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is the main function of this program. It is exactly like all previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step34;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = 1;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree = 1;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (3);</div><div class="line">      BEMProblem&lt;2&gt; laplace_problem_2d(degree, mapping_degree);</div><div class="line">      laplace_problem_2d.run();</div><div class="line"></div><div class="line">      BEMProblem&lt;3&gt; laplace_problem_3d(degree, mapping_degree);</div><div class="line">      laplace_problem_3d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>We ran the program using the following <code>parameters.prm</code> file (which can also be found in the directory in which all the other source files are): </p><pre class="fragment"># Listing of Parameters
# ---------------------
set Extend solution on the -2,2 box = true
set External refinement             = 5
set Number of cycles                = 4
set Run 2d simulation               = true
set Run 3d simulation               = true


subsection Exact solution 2d
  # Any constant used inside the function which is not a variable name.
  set Function constants  = 

  # Separate vector valued expressions by ';' as ',' is used internally by the
  # function parser.
  set Function expression = x+y   # default: 0

  # The name of the variables as they will be used in the function, separated
  # by ','.
  set Variable names      = x,y,t
end


subsection Exact solution 3d
  # Any constant used inside the function which is not a variable name.
  set Function constants  = 

  # Separate vector valued expressions by ';' as ',' is used internally by the
  # function parser.
  set Function expression = .5*(x+y+z)   # default: 0

  # The name of the variables as they will be used in the function, separated
  # by ','.
  set Variable names      = x,y,z,t
end


subsection Quadrature rules
  set Quadrature order          = 4
  set Quadrature type           = gauss
  set Singular quadrature order = 5
end


subsection Solver
  set Log frequency = 1
  set Log history   = false
  set Log result    = true
  set Max steps     = 100
  set Tolerance     = 1.e-10
end


subsection Wind function 2d
  # Any constant used inside the function which is not a variable name.
  set Function constants  = 

  # Separate vector valued expressions by ';' as ',' is used internally by the
  # function parser.
  set Function expression = 1; 1  # default: 0; 0

  # The name of the variables as they will be used in the function, separated
  # by ','.
  set Variable names      = x,y,t
end


subsection Wind function 3d
  # Any constant used inside the function which is not a variable name.
  set Function constants  = 

  # Separate vector valued expressions by ';' as ',' is used internally by the
  # function parser.
  set Function expression = 1; 1; 1 # default: 0; 0; 0

  # The name of the variables as they will be used in the function, separated
  # by ','.
  set Variable names      = x,y,z,t
end
</pre><p>When we run the program, the following is printed on screen: </p><pre class="fragment">DEAL::
DEAL::Parsing parameter file parameters.prm
DEAL::for a 2 dimensional simulation. 
DEAL:GMRES::Starting value 2.21576
DEAL:GMRES::Convergence step 1 value 2.37635e-13
DEAL::Cycle 0:
DEAL::   Number of active cells:       20
DEAL::   Number of degrees of freedom: 20
DEAL:GMRES::Starting value 3.15543
DEAL:GMRES::Convergence step 1 value 2.89310e-13
DEAL::Cycle 1:
DEAL::   Number of active cells:       40
DEAL::   Number of degrees of freedom: 40
DEAL:GMRES::Starting value 4.46977
DEAL:GMRES::Convergence step 1 value 3.11815e-13
DEAL::Cycle 2:
DEAL::   Number of active cells:       80
DEAL::   Number of degrees of freedom: 80
DEAL:GMRES::Starting value 6.32373
DEAL:GMRES::Convergence step 1 value 3.22474e-13
DEAL::Cycle 3:
DEAL::   Number of active cells:       160
DEAL::   Number of degrees of freedom: 160
DEAL::
cycle cells dofs  L2(phi)  Linfty(alpha) 
    0    20   20 4.465e-02             - 5.000e-02    - 
    1    40   40 1.081e-02          2.05 2.500e-02 1.00 
    2    80   80 2.644e-03          2.03 1.250e-02 1.00 
    3   160  160 6.529e-04          2.02 6.250e-03 1.00 
DEAL::
DEAL::Parsing parameter file parameters.prm
DEAL::for a 3 dimensional simulation. 
DEAL:GMRES::Starting value 2.84666
DEAL:GMRES::Convergence step 3 value 8.68638e-18
DEAL::Cycle 0:
DEAL::   Number of active cells:       24
DEAL::   Number of degrees of freedom: 26
DEAL:GMRES::Starting value 6.34288
DEAL:GMRES::Convergence step 5 value 1.38740e-11
DEAL::Cycle 1:
DEAL::   Number of active cells:       96
DEAL::   Number of degrees of freedom: 98
DEAL:GMRES::Starting value 12.9780
DEAL:GMRES::Convergence step 5 value 3.29225e-11
DEAL::Cycle 2:
DEAL::   Number of active cells:       384
DEAL::   Number of degrees of freedom: 386
DEAL:GMRES::Starting value 26.0874
DEAL:GMRES::Convergence step 6 value 1.47271e-12
DEAL::Cycle 3:
DEAL::   Number of active cells:       1536
DEAL::   Number of degrees of freedom: 1538
DEAL::
cycle cells dofs  L2(phi)  Linfty(alpha) 
    0    24   26 6.873e-01             - 2.327e-01    - 
    1    96   98 1.960e-01          1.81 1.239e-01 0.91 
    2   384  386 4.837e-02          2.02 6.319e-02 0.97 
    3  1536 1538 1.176e-02          2.04 3.176e-02 0.99 
</pre><p>As we can see from the convergence table in 2d, if we choose quadrature formulas which are accurate enough, then the error we obtain for <img class="formulaInl" alt="$\alpha(\mathbf{x})$" src="form_2957.png"/> should be exactly the inverse of the number of elements. The approximation of the circle with N segments of equal size generates a regular polygon with N faces, whose angles are exactly <img class="formulaInl" alt="$\pi-\frac {2\pi}{N}$" src="form_3037.png"/>, therefore the error we commit should be exactly <img class="formulaInl" alt="$\frac 12 - (\frac 12 -\frac 1N) = \frac 1N$" src="form_3038.png"/>. In fact this is a very good indicator that we are performing the singular integrals in an appropriate manner.</p>
<p>The error in the approximation of the potential <img class="formulaInl" alt="$\phi$" src="form_643.png"/> is largely due to approximation of the domain. A much better approximation could be obtained by using higher order mappings.</p>
<p>If we modify the main() function, setting fe_degree and mapping_degree to two, and raise the order of the quadrature formulas in the parameter file, we obtain the following convergence table for the two dimensional simulation</p>
<pre class="fragment">cycle cells dofs  L2(phi)  Linfty(alpha) 
    0    20   40 5.404e-05             - 2.306e-04    - 
    1    40   80 3.578e-06          3.92 1.738e-05 3.73 
    2    80  160 2.479e-07          3.85 1.253e-05 0.47 
    3   160  320 1.856e-08          3.74 7.670e-06 0.71 
</pre><p>and</p>
<pre class="fragment">cycle cells dofs  L2(phi)  Linfty(alpha) 
    0    24   98 9.187e-03             - 8.956e-03    - 
    1    96  386 3.991e-04          4.52 1.182e-03 2.92 
    2   384 1538 2.113e-05          4.24 1.499e-04 2.98 
    3  1536 6146 1.247e-06          4.08 1.896e-05 2.98 
</pre><p>for the three dimensional case. As we can see, convergence results are much better with higher order mapping, mainly due to a better resolution of the curved geometry. Notice that, given the same number of degrees of freedom, for example in step 3 of the Q1 case and step 2 of Q2 case in the three dimensional simulation, the error is roughly three orders of magnitude lower.</p>
<p>The result of running these computations is a bunch of output files that we can pass to our visualization program of choice. The output files are of two kind: the potential on the boundary element surface, and the potential extended to the outer and inner domain. The combination of the two for the two dimensional case looks like</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-34_2d.png"/>
</div>
<p>while in three dimensions we show first the potential on the surface, together with a contour plot,</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-34_3d.png"/>
</div>
<p>and then the external contour plot of the potential, with opacity set to 25%:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-34_3d-2.png"/>
</div>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>This is the first tutorial program that considers solving equations defined on surfaces embedded in higher dimensional spaces. But the equation discussed here was relatively simple because it only involved an integral operator, not derivatives which are more difficult to define on the surface. The <a class="el" href="step_38.html">step-38</a> tutorial program considers such problems and provides the necessary tools. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Luca Heltai, Cataldo Manigrasso, 2009</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/smartpointer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_selector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parsed_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_control.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step34</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LaplaceKernel</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> single_layer(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &amp;R)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> (-std::log(R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>()) / (2*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) );</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> (1./( R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>()*4*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> ) );</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <span class="keywordflow">return</span> 0.;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> double_layer(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &amp;R)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> R / ( -2*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * R.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>());</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> R / ( -4*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a> * R.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() * R.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>() );</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a>();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BEMProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BEMProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree = 1,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree = 1);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> read_parameters (<span class="keyword">const</span> std::string &amp;filename);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_and_resize();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute_errors(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute_exterior_solution();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &amp; get_singular_quadrature(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;dim-1, dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim-1, dim&gt;   tria;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim-1,dim&gt;             fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;       dh;</div><div class="line">    <a class="code" href="classMappingQ.html">MappingQ</a>&lt;dim-1, dim&gt;      mapping;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    system_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        system_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              phi;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              alpha;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>  convergence_table;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;dim&gt;</a> wind;</div><div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;dim&gt;</a> exact_solution;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> singular_quadrature_order;</div><div class="line">    std::shared_ptr&lt;<a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &gt; quadrature;</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> external_refinement;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> run_in_this_dimension;</div><div class="line">    <span class="keywordtype">bool</span> extend_solution;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BEMProblem&lt;dim&gt;::BEMProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree)</div><div class="line">    :</div><div class="line">    fe(fe_degree),</div><div class="line">    dh(tria),</div><div class="line">    mapping(mapping_degree, true),</div><div class="line">    wind(dim),</div><div class="line">    singular_quadrature_order(5),</div><div class="line">    n_cycles(4),</div><div class="line">    external_refinement(5),</div><div class="line">    run_in_this_dimension(true),</div><div class="line">    extend_solution(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::read_parameters (<span class="keyword">const</span> std::string &amp;filename)</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Parsing parameter file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;for a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; dimensional simulation. &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Number of cycles&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;External refinement&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Extend solution on the -2,2 box&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Run 2d simulation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Run 3d simulation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>());</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Quadrature rules&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature type&quot;</span>, <span class="stringliteral">&quot;gauss&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<a class="code" href="classQuadratureSelector.html">QuadratureSelector</a>&lt;(dim-1)&gt;::get_quadrature_names()));</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Singular quadrature order&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Wind function 2d&quot;</span>);</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;2&gt;::declare_parameters</a>(prm, 2);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1; 1&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Wind function 3d&quot;</span>);</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;3&gt;::declare_parameters</a>(prm, 3);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1; 1; 1&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Exact solution 2d&quot;</span>);</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;2&gt;::declare_parameters</a>(prm);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;x+y&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Exact solution 3d&quot;</span>);</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;3&gt;::declare_parameters</a>(prm);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;x+y+z&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">    <a class="code" href="classSolverControl.html#a0bb6dc567e07e9f7b0a9d09f801bf149">SolverControl::declare_parameters</a>(prm);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a>(filename);</div><div class="line"></div><div class="line">    n_cycles = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of cycles&quot;</span>);</div><div class="line">    external_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;External refinement&quot;</span>);</div><div class="line">    extend_solution = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Extend solution on the -2,2 box&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Quadrature rules&quot;</span>);</div><div class="line">    {</div><div class="line">      quadrature =</div><div class="line">        std::shared_ptr&lt;<a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &gt;</div><div class="line">        (<span class="keyword">new</span> <a class="code" href="classQuadratureSelector.html">QuadratureSelector</a>&lt;dim-1&gt; (prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Quadrature type&quot;</span>),</div><div class="line">                                        prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>)));</div><div class="line">      singular_quadrature_order = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Singular quadrature order&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(std::string(<span class="stringliteral">&quot;Wind function &quot;</span>)+</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim)+std::string(<span class="stringliteral">&quot;d&quot;</span>));</div><div class="line">    {</div><div class="line">      wind.parse_parameters(prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(std::string(<span class="stringliteral">&quot;Exact solution &quot;</span>)+</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim)+std::string(<span class="stringliteral">&quot;d&quot;</span>));</div><div class="line">    {</div><div class="line">      exact_solution.parse_parameters(prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">    solver_control.parse_parameters(prm);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line"></div><div class="line">    run_in_this_dimension = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Run &quot;</span> +</div><div class="line">                                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) +</div><div class="line">                                         <span class="stringliteral">&quot;d simulation&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::read_domain()</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold</a>&lt;dim-1, dim&gt; manifold(center);</div><div class="line"></div><div class="line">    std::ifstream in;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        in.open (<span class="stringliteral">&quot;coarse_circle.inp&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        in.open (<span class="stringliteral">&quot;coarse_sphere.inp&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classGridIn.html">GridIn</a>&lt;dim-1, dim&gt; gi;</div><div class="line">    gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a> (tria);</div><div class="line">    gi.read_ucd (in);</div><div class="line"></div><div class="line">    tria.set_all_manifold_ids(1);</div><div class="line">    tria.set_manifold(1, manifold);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::refine_and_resize()</div><div class="line">  {</div><div class="line">    tria.refine_global(1);</div><div class="line"></div><div class="line">    dh.distribute_dofs(fe);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =  dh.n_dofs();</div><div class="line"></div><div class="line">    system_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">    system_rhs.reinit(n_dofs);</div><div class="line">    phi.reinit(n_dofs);</div><div class="line">    alpha.reinit(n_dofs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v(mapping, fe, *quadrature,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; cell_wind(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line">    <span class="keywordtype">double</span> normal_wind;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>      local_matrix_row_i(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; support_points(dh.n_dofs());</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a10af6ba7adc43214e7b9f6815588f2aa">DoFTools::map_dofs_to_support_points</a>&lt;dim-1, dim&gt;( mapping, dh, support_points);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;::active_cell_iterator</div><div class="line">    cell = dh.begin_active(),</div><div class="line">    endc = dh.end();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (cell = dh.begin_active(); cell != endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_v.reinit(cell);</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;q_points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">        <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals  = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a>();</div><div class="line">        wind.vector_value_list(q_points, cell_wind);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dh.n_dofs() ; ++i)</div><div class="line">          {</div><div class="line"></div><div class="line">            local_matrix_row_i = 0;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> is_singular = <span class="keyword">false</span>;</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> singular_index = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">              <span class="keywordflow">if</span> (local_dof_indices[j] == i)</div><div class="line">                {</div><div class="line">                  singular_index = j;</div><div class="line">                  is_singular = <span class="keyword">true</span>;</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (is_singular == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">                  {</div><div class="line">                    normal_wind = 0;</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">                      normal_wind += normals[q][d]*cell_wind[q](d);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = q_points[q] - support_points[i];</div><div class="line"></div><div class="line">                    system_rhs(i) += ( LaplaceKernel::single_layer(R)   *</div><div class="line">                                       normal_wind                      *</div><div class="line">                                       fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) );</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line"></div><div class="line">                      local_matrix_row_i(j) -= ( ( LaplaceKernel::double_layer(R)     *</div><div class="line">                                                   normals[q] )            *</div><div class="line">                                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q)     *</div><div class="line">                                                 fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)       );</div><div class="line">                  }</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(singular_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; &amp; singular_quadrature =</div><div class="line">                  get_singular_quadrature(cell, singular_index);</div><div class="line"></div><div class="line">                <a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v_singular (mapping, fe, singular_quadrature,</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa9e3f2944ebdadf4409dc11f8fc0afe14">update_jacobians</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> );</div><div class="line"></div><div class="line">                fe_v_singular.reinit(cell);</div><div class="line"></div><div class="line">                std::vector&lt;Vector&lt;double&gt; &gt; singular_cell_wind( singular_quadrature.size(),</div><div class="line">                                                                 <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line"></div><div class="line">                <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;singular_normals  = fe_v_singular.get_all_normal_vectors();</div><div class="line">                <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;singular_q_points = fe_v_singular.get_quadrature_points();</div><div class="line"></div><div class="line">                wind.vector_value_list(singular_q_points, singular_cell_wind);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;singular_quadrature.size(); ++q)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = singular_q_points[q] - support_points[i];</div><div class="line">                    <span class="keywordtype">double</span> normal_wind = 0;</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">                      normal_wind += (singular_cell_wind[q](d)*</div><div class="line">                                      singular_normals[q][d]);</div><div class="line"></div><div class="line">                    system_rhs(i) += ( LaplaceKernel::single_layer(R) *</div><div class="line">                                       normal_wind                         *</div><div class="line">                                       fe_v_singular.JxW(q) );</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">                      {</div><div class="line">                        local_matrix_row_i(j) -= (( LaplaceKernel::double_layer(R) *</div><div class="line">                                                    singular_normals[q])                *</div><div class="line">                                                  fe_v_singular.shape_value(j,q)        *</div><div class="line">                                                  fe_v_singular.JxW(q)       );</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">              system_matrix(i,local_dof_indices[j])</div><div class="line">              += local_matrix_row_i(j);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> ones(dh.n_dofs());</div><div class="line">    ones.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(-1.);</div><div class="line"></div><div class="line">    system_matrix.vmult(alpha, ones);</div><div class="line">    alpha.add(1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;dh.n_dofs(); ++i)</div><div class="line">      system_matrix(i,i) +=  alpha(i);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::solve_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a> &gt; solver (solver_control);</div><div class="line">    solver.solve (system_matrix, phi, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::compute_errors(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (tria.n_active_cells());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (mapping, dh, phi,</div><div class="line">                                       exact_solution,</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss</a>&lt;(dim-1)&gt;(2*fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(tria,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> difference_per_node(alpha);</div><div class="line">    difference_per_node.add(-.5);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_error = difference_per_node.linfty_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells=tria.n_active_cells();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs=dh.n_dofs();</div><div class="line"></div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; n_active_cells</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; n_dofs</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, n_active_cells);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, n_dofs);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;L2(phi)&quot;</span>, L2_error);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, alpha_error);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;2&gt;</a> &amp;BEMProblem&lt;3&gt;::get_singular_quadrature(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2,3&gt;::active_cell_iterator</a> &amp;,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(index &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(0, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, index));</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;QGaussOneOverR&lt;2&gt; &gt; quadratures;</div><div class="line">    <span class="keywordflow">if</span> (quadratures.size() == 0)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">        quadratures.push_back(<a class="code" href="classQGaussOneOverR.html">QGaussOneOverR&lt;2&gt;</a>(singular_quadrature_order,</div><div class="line">                                                fe.<a class="code" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a>()[i],</div><div class="line">                                                <span class="keyword">true</span>));</div><div class="line">    <span class="keywordflow">return</span> quadratures[index];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;1&gt;</a> &amp;BEMProblem&lt;2&gt;::get_singular_quadrature(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;1,2&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(index &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(0, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, index));</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="classQuadrature.html">Quadrature&lt;1&gt;</a> *q_pointer = <span class="keyword">nullptr</span>;</div><div class="line">    <span class="keywordflow">if</span> (q_pointer) <span class="keyword">delete</span> q_pointer;</div><div class="line"></div><div class="line">    q_pointer = <span class="keyword">new</span> <a class="code" href="classQGaussLogR.html">QGaussLogR&lt;1&gt;</a>(singular_quadrature_order,</div><div class="line">                                  fe.<a class="code" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a>()[index],</div><div class="line">                                  1./cell-&gt;measure(), <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">return</span> (*q_pointer);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::compute_exterior_solution()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>  external_tria;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(external_tria, -2, 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>           external_fe(1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     external_dh (external_tria);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>      external_phi;</div><div class="line"></div><div class="line">    external_tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(external_refinement);</div><div class="line">    external_dh.distribute_dofs(external_fe);</div><div class="line">    external_phi.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(external_dh.n_dofs());</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1,dim&gt;::active_cell_iterator</div><div class="line">    cell = dh.begin_active(),</div><div class="line">    endc = dh.end();</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues</a>&lt;dim-1,dim&gt; fe_v(mapping, fe, *quadrature,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fae88a420f5da7313bdaf30c3e4943f013">update_cell_normal_vectors</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs(fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; local_phi(n_q_points);</div><div class="line">    std::vector&lt;double&gt; normal_wind(n_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; local_wind(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim) );</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; external_support_points(external_dh.n_dofs());</div><div class="line">    DoFTools::map_dofs_to_support_points&lt;dim&gt;(StaticMappingQ1&lt;dim&gt;::mapping,</div><div class="line">                                              external_dh, external_support_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (cell = dh.begin_active(); cell != endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_v.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt;    &amp;q_points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">        <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals  = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a>();</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(dofs);</div><div class="line">        fe_v.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(phi, local_phi);</div><div class="line"></div><div class="line">        wind.vector_value_list(q_points, local_wind);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          {</div><div class="line">            normal_wind[q] = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">              normal_wind[q] += normals[q][d]*local_wind[q](d);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;external_dh.n_dofs(); ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            {</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> R = q_points[q] - external_support_points[i];</div><div class="line"></div><div class="line">              external_phi(i) += ( ( LaplaceKernel::single_layer(R) *</div><div class="line">                                     normal_wind[q]</div><div class="line">                                     +</div><div class="line">                                     (LaplaceKernel::double_layer(R) *</div><div class="line">                                      normals[q] )            *</div><div class="line">                                     local_phi[q] )           *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) );</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(external_dh);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(external_phi, <span class="stringliteral">&quot;external_phi&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string</div><div class="line">    filename = <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) + <span class="stringliteral">&quot;d_external.vtk&quot;</span>;</div><div class="line">    std::ofstream file(filename.c_str());</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1, dim&gt; &gt; dataout;</div><div class="line"></div><div class="line">    dataout.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dh);</div><div class="line">    dataout.add_data_vector(phi, <span class="stringliteral">&quot;phi&quot;</span>,</div><div class="line">                            <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim-1, dim&gt;</a> &gt;::type_dof_data);</div><div class="line">    dataout.add_data_vector(alpha, <span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                            <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim-1, dim&gt;</a> &gt;::type_dof_data);</div><div class="line">    dataout.build_patches(mapping,</div><div class="line">                          mapping.get_degree(),</div><div class="line">                          <a class="code" href="classDataOut.html">DataOut</a>&lt;dim-1, <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim-1, dim&gt; &gt;::curved_inner_cells);</div><div class="line"></div><div class="line">    std::string filename = ( <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(dim) +</div><div class="line">                             <span class="stringliteral">&quot;d_boundary_solution_&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) +</div><div class="line">                             <span class="stringliteral">&quot;.vtk&quot;</span> );</div><div class="line">    std::ofstream file(filename.c_str());</div><div class="line"></div><div class="line">    dataout.write_vtk(file);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cycle == n_cycles-1)</div><div class="line">      {</div><div class="line">        convergence_table.set_precision(<span class="stringliteral">&quot;L2(phi)&quot;</span>, 3);</div><div class="line">        convergence_table.set_precision(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, 3);</div><div class="line"></div><div class="line">        convergence_table.set_scientific(<span class="stringliteral">&quot;L2(phi)&quot;</span>, <span class="keyword">true</span>);</div><div class="line">        convergence_table.set_scientific(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;L2(phi)&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;Linfty(alpha)&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">        deallog &lt;&lt; std::endl;</div><div class="line">        convergence_table.write_text(std::cout);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BEMProblem&lt;dim&gt;::run()</div><div class="line">  {</div><div class="line"></div><div class="line">    read_parameters(<span class="stringliteral">&quot;parameters.prm&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (run_in_this_dimension == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Run in dimension &quot;</span> &lt;&lt; dim</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; explicitly disabled in parameter file. &quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_and_resize();</div><div class="line">        assemble_system();</div><div class="line">        solve_system();</div><div class="line">        compute_errors(cycle);</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (extend_solution == <span class="keyword">true</span>)</div><div class="line">      compute_exterior_solution();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step34;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = 1;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree = 1;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (3);</div><div class="line">      BEMProblem&lt;2&gt; laplace_problem_2d(degree, mapping_degree);</div><div class="line">      laplace_problem_2d.run();</div><div class="line"></div><div class="line">      BEMProblem&lt;3&gt; laplace_problem_3d(degree, mapping_degree);</div><div class="line">      laplace_problem_3d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
