<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: AlignedVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classAlignedVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AlignedVector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="aligned__vector_8h_source.html">deal.II/base/aligned_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AlignedVector&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAlignedVector__inherit__graph.svg" width="616" height="607"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3486eeb9d5d0318c74c3b2d515adeca7"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a3486eeb9d5d0318c74c3b2d515adeca7">value_type</a></td></tr>
<tr class="separator:a3486eeb9d5d0318c74c3b2d515adeca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0c7b2f2bf51aa54825ad6565e8413e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ae0c7b2f2bf51aa54825ad6565e8413e8">AlignedVector</a> ()</td></tr>
<tr class="separator:ae0c7b2f2bf51aa54825ad6565e8413e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7471090217ad0df74031a7fbb4e3457"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa7471090217ad0df74031a7fbb4e3457">AlignedVector</a> (const size_type <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size</a>, const T &amp;init=T())</td></tr>
<tr class="separator:aa7471090217ad0df74031a7fbb4e3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae788ac1d6d718429058871c235270497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ae788ac1d6d718429058871c235270497">~AlignedVector</a> ()</td></tr>
<tr class="separator:ae788ac1d6d718429058871c235270497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c70aaf5700b42530b57e0f0b7e402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#abd1c70aaf5700b42530b57e0f0b7e402">AlignedVector</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:abd1c70aaf5700b42530b57e0f0b7e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9e018e7e29c7351df342f7f6e62553"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#adc9e018e7e29c7351df342f7f6e62553">AlignedVector</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;vec)</td></tr>
<tr class="separator:adc9e018e7e29c7351df342f7f6e62553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d07700c53e247ea13a18c82c2e0ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa0d07700c53e247ea13a18c82c2e0ed6">operator=</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aa0d07700c53e247ea13a18c82c2e0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ddfa1732095208c5ad9a9d49366818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa3ddfa1732095208c5ad9a9d49366818">operator=</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;vec)</td></tr>
<tr class="separator:aa3ddfa1732095208c5ad9a9d49366818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46143d6d89752a5ca2c8f2f45b15b1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a46143d6d89752a5ca2c8f2f45b15b1e8">resize_fast</a> (const size_type <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size</a>)</td></tr>
<tr class="separator:a46143d6d89752a5ca2c8f2f45b15b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1880d584a976e609a03e23d1dd5d547a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a1880d584a976e609a03e23d1dd5d547a">resize</a> (const size_type size_in, const T &amp;init=T())</td></tr>
<tr class="separator:a1880d584a976e609a03e23d1dd5d547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb28803f20b9888306dc51432986f65c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#acb28803f20b9888306dc51432986f65c">reserve</a> (const size_type size_alloc)</td></tr>
<tr class="separator:acb28803f20b9888306dc51432986f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2beb26ca2ae3921a0dc634bc8c9cdd44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2beb26ca2ae3921a0dc634bc8c9cdd44">clear</a> ()</td></tr>
<tr class="separator:a2beb26ca2ae3921a0dc634bc8c9cdd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de70f70d696a43451f4e48c1c119d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a9de70f70d696a43451f4e48c1c119d69">push_back</a> (const T in_data)</td></tr>
<tr class="separator:a9de70f70d696a43451f4e48c1c119d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa09530be204c4fd3f25155da71215a7"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#afa09530be204c4fd3f25155da71215a7">back</a> ()</td></tr>
<tr class="separator:afa09530be204c4fd3f25155da71215a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71d86c84614ed6356f845b9d951b8af"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac71d86c84614ed6356f845b9d951b8af">back</a> () const</td></tr>
<tr class="separator:ac71d86c84614ed6356f845b9d951b8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc666796f52070206a2798b1dba090"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:af2bc666796f52070206a2798b1dba090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#af2bc666796f52070206a2798b1dba090">insert_back</a> (ForwardIterator <a class="el" href="classAlignedVector.html#a2a928b90e816fe71668a693dd1e50edf">begin</a>, ForwardIterator <a class="el" href="classAlignedVector.html#a007a479f46a0321254b029315193000a">end</a>)</td></tr>
<tr class="separator:af2bc666796f52070206a2798b1dba090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f8d9637308d670fca25e85e39c80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a1d3f8d9637308d670fca25e85e39c80f">fill</a> (const T &amp;element)</td></tr>
<tr class="separator:a1d3f8d9637308d670fca25e85e39c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679c42669ff9aede60f9fc89a57b732b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a679c42669ff9aede60f9fc89a57b732b">swap</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a679c42669ff9aede60f9fc89a57b732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76d46499c3e4eae5c0ff0ebdbddb853"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ab76d46499c3e4eae5c0ff0ebdbddb853">empty</a> () const</td></tr>
<tr class="separator:ab76d46499c3e4eae5c0ff0ebdbddb853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1900b4748c7de0d12858b0a93ee0060"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size</a> () const</td></tr>
<tr class="separator:ac1900b4748c7de0d12858b0a93ee0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862418053c6e253515381451d77818c0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a862418053c6e253515381451d77818c0">capacity</a> () const</td></tr>
<tr class="separator:a862418053c6e253515381451d77818c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172650dad815f1e7b0053567f5782260"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a172650dad815f1e7b0053567f5782260">operator[]</a> (const size_type index)</td></tr>
<tr class="separator:a172650dad815f1e7b0053567f5782260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec7ff2f0ee47fb5df016fad1870fdb3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a5ec7ff2f0ee47fb5df016fad1870fdb3">operator[]</a> (const size_type index) const</td></tr>
<tr class="separator:a5ec7ff2f0ee47fb5df016fad1870fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a928b90e816fe71668a693dd1e50edf"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2a928b90e816fe71668a693dd1e50edf">begin</a> ()</td></tr>
<tr class="separator:a2a928b90e816fe71668a693dd1e50edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007a479f46a0321254b029315193000a"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a007a479f46a0321254b029315193000a">end</a> ()</td></tr>
<tr class="separator:a007a479f46a0321254b029315193000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72f9cd8f0d7ca2098b81d070ecf953f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa72f9cd8f0d7ca2098b81d070ecf953f">begin</a> () const</td></tr>
<tr class="separator:aa72f9cd8f0d7ca2098b81d070ecf953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b355e808731cc71dd0a90f07e566275"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2b355e808731cc71dd0a90f07e566275">end</a> () const</td></tr>
<tr class="separator:a2b355e808731cc71dd0a90f07e566275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe56d5aff0ce372d2bddc2a0847ff35"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a0fe56d5aff0ce372d2bddc2a0847ff35">memory_consumption</a> () const</td></tr>
<tr class="separator:a0fe56d5aff0ce372d2bddc2a0847ff35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae546c280e6238488934b4958bab7cc1b"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae546c280e6238488934b4958bab7cc1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ae546c280e6238488934b4958bab7cc1b">save</a> (Archive &amp;ar, const unsigned int version) const</td></tr>
<tr class="separator:ae546c280e6238488934b4958bab7cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55665c8e84f060b973cdbc322c4f00"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:adc55665c8e84f060b973cdbc322c4f00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#adc55665c8e84f060b973cdbc322c4f00">load</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:adc55665c8e84f060b973cdbc322c4f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a90246f0f7c72bc1cbc5365abb21bcb86"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a90246f0f7c72bc1cbc5365abb21bcb86">_data</a></td></tr>
<tr class="separator:a90246f0f7c72bc1cbc5365abb21bcb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d81735d1cc6b56aa9cab3eacc62cade"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2d81735d1cc6b56aa9cab3eacc62cade">_end_data</a></td></tr>
<tr class="separator:a2d81735d1cc6b56aa9cab3eacc62cade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5760d82a58229e09985a44ffb5bf9132"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a5760d82a58229e09985a44ffb5bf9132">_end_allocated</a></td></tr>
<tr class="separator:a5760d82a58229e09985a44ffb5bf9132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad12008400b484088aa5e775e6d2262ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad12008400b484088aa5e775e6d2262ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ad12008400b484088aa5e775e6d2262ab">operator==</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad12008400b484088aa5e775e6d2262ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5194e9bde680a0b5d359cd17fc1de808"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5194e9bde680a0b5d359cd17fc1de808"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a5194e9bde680a0b5d359cd17fc1de808">operator!=</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5194e9bde680a0b5d359cd17fc1de808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class AlignedVector&lt; T &gt;</h3>

<p>This is a replacement class for std::vector to be used in combination with <a class="el" href="classVectorizedArray.html">VectorizedArray</a> and derived data types. It allocates memory aligned to addresses of a vectorized data type (in order to avoid segmentation faults when a variable of type <a class="el" href="classVectorizedArray.html">VectorizedArray</a> which the compiler assumes to be aligned to certain memory addresses does not actually follow these rules). This could also be achieved by proving std::vector with a user-defined allocator. On the other hand, writing an own small vector class lets us implement parallel copy and move operations with TBB, insert deal.II-style assertions, and cut some unnecessary functionality. Note that this vector is a bit more memory-consuming than std::vector because of alignment, so it is recommended to only use this vector on long vectors.</p>
<p><code>author</code> Katharina Kormann, Martin Kronbichler, 2011 </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00052">52</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3486eeb9d5d0318c74c3b2d515adeca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3486eeb9d5d0318c74c3b2d515adeca7">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#a3486eeb9d5d0318c74c3b2d515adeca7">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00059">59</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0c7b2f2bf51aa54825ad6565e8413e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c7b2f2bf51aa54825ad6565e8413e8">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. Sets the vector size to zero. </p>

</div>
</div>
<a id="aa7471090217ad0df74031a7fbb4e3457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7471090217ad0df74031a7fbb4e3457">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>init</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the vector size to the given size and initializes all elements with T().</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae788ac1d6d718429058871c235270497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae788ac1d6d718429058871c235270497">&#9670;&nbsp;</a></span>~AlignedVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::~<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="abd1c70aaf5700b42530b57e0f0b7e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1c70aaf5700b42530b57e0f0b7e402">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="adc9e018e7e29c7351df342f7f6e62553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9e018e7e29c7351df342f7f6e62553">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. Create a new aligned vector by stealing the contents of <code>vec</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa0d07700c53e247ea13a18c82c2e0ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d07700c53e247ea13a18c82c2e0ed6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&amp; <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment to the input vector <code>vec</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa3ddfa1732095208c5ad9a9d49366818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ddfa1732095208c5ad9a9d49366818">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&amp; <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a46143d6d89752a5ca2c8f2f45b15b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46143d6d89752a5ca2c8f2f45b15b1e8">&#9670;&nbsp;</a></span>resize_fast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::resize_fast </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of the vector. It keeps old elements previously available but does not initialize the newly allocated memory, leaving it in an undefined state.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be invoked for classes <code>T</code> that define a default constructor, <code>T()</code>. Otherwise, compilation will fail. </dd></dl>

</div>
</div>
<a id="a1880d584a976e609a03e23d1dd5d547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1880d584a976e609a03e23d1dd5d547a">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>init</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of the vector. It keeps old elements previously available, and initializes each element with the specified data. If the new vector size is shorter than the old one, the memory is not released unless the new size is zero.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="acb28803f20b9888306dc51432986f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb28803f20b9888306dc51432986f65c">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size_alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve memory space for <code>size</code> elements. If the argument <code>size</code> is set to zero, all previously allocated memory is released.</p>
<p>In order to avoid too frequent reallocation (which involves copy of the data), this function doubles the amount of memory occupied when the given size is larger than the previously allocated size. </p>

</div>
</div>
<a id="a2beb26ca2ae3921a0dc634bc8c9cdd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2beb26ca2ae3921a0dc634bc8c9cdd44">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all previously allocated memory and leaves the vector in a state equivalent to the state after the default constructor has been called. </p>

</div>
</div>
<a id="a9de70f70d696a43451f4e48c1c119d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de70f70d696a43451f4e48c1c119d69">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>in_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an element at the end of the vector, increasing the vector size by one. Note that the allocated size will double whenever the previous space is not enough to hold the new element. </p>

</div>
</div>
<a id="afa09530be204c4fd3f25155da71215a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa09530be204c4fd3f25155da71215a7">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last element of the vector (read and write access). </p>

</div>
</div>
<a id="ac71d86c84614ed6356f845b9d951b8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71d86c84614ed6356f845b9d951b8af">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last element of the vector (read-only access). </p>

</div>
</div>
<a id="af2bc666796f52070206a2798b1dba090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bc666796f52070206a2798b1dba090">&#9670;&nbsp;</a></span>insert_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::insert_back </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts several elements at the end of the vector given by a range of elements. </p>

</div>
</div>
<a id="a1d3f8d9637308d670fca25e85e39c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3f8d9637308d670fca25e85e39c80f">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the vector with <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a> copies of the given input.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be invoked for classes that define the copy assignment operator. Otherwise, compilation will fail.</dd>
<dd>
If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a679c42669ff9aede60f9fc89a57b732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679c42669ff9aede60f9fc89a57b732b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the given vector with the calling vector. </p>

</div>
</div>
<a id="ab76d46499c3e4eae5c0ff0ebdbddb853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76d46499c3e4eae5c0ff0ebdbddb853">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector is empty, i.e., its size is zero. </p>

</div>
</div>
<a id="ac1900b4748c7de0d12858b0a93ee0060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1900b4748c7de0d12858b0a93ee0060">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of the vector. </p>

</div>
</div>
<a id="a862418053c6e253515381451d77818c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862418053c6e253515381451d77818c0">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the capacity of the vector, i.e., the size this vector can hold without reallocation. Note that <a class="el" href="classAlignedVector.html#a862418053c6e253515381451d77818c0">capacity()</a> &gt;= <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a>. </p>

</div>
</div>
<a id="a172650dad815f1e7b0053567f5782260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172650dad815f1e7b0053567f5782260">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-write access to entry <code>index</code> in the vector. </p>

</div>
</div>
<a id="a5ec7ff2f0ee47fb5df016fad1870fdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec7ff2f0ee47fb5df016fad1870fdb3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-only access to entry <code>index</code> in the vector. </p>

</div>
</div>
<a id="a2a928b90e816fe71668a693dd1e50edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a928b90e816fe71668a693dd1e50edf">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read and write pointer to the beginning of the data array. </p>

</div>
</div>
<a id="a007a479f46a0321254b029315193000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007a479f46a0321254b029315193000a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read and write pointer to the end of the data array. </p>

</div>
</div>
<a id="aa72f9cd8f0d7ca2098b81d070ecf953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72f9cd8f0d7ca2098b81d070ecf953f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-only pointer to the beginning of the data array. </p>

</div>
</div>
<a id="a2b355e808731cc71dd0a90f07e566275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b355e808731cc71dd0a90f07e566275">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-only pointer to the end of the data array. </p>

</div>
</div>
<a id="a0fe56d5aff0ce372d2bddc2a0847ff35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe56d5aff0ce372d2bddc2a0847ff35">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption of the allocated memory in this class. If the underlying type <code>T</code> allocates memory by itself, this memory is not counted. </p>

</div>
</div>
<a id="ae546c280e6238488934b4958bab7cc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae546c280e6238488934b4958bab7cc1b">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization. </p>

</div>
</div>
<a id="adc55665c8e84f060b973cdbc322c4f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55665c8e84f060b973cdbc322c4f00">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad12008400b484088aa5e775e6d2262ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12008400b484088aa5e775e6d2262ab">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relational operator == for <a class="el" href="classAlignedVector.html">AlignedVector</a> </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00909">909</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a5194e9bde680a0b5d359cd17fc1de808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5194e9bde680a0b5d359cd17fc1de808">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relational operator != for <a class="el" href="classAlignedVector.html">AlignedVector</a> </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00930">930</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a90246f0f7c72bc1cbc5365abb21bcb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90246f0f7c72bc1cbc5365abb21bcb86">&#9670;&nbsp;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to actual class data. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00266">266</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a2d81735d1cc6b56aa9cab3eacc62cade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d81735d1cc6b56aa9cab3eacc62cade">&#9670;&nbsp;</a></span>_end_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::_end_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the end of valid data fields. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00271">271</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a5760d82a58229e09985a44ffb5bf9132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5760d82a58229e09985a44ffb5bf9132">&#9670;&nbsp;</a></span>_end_allocated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::_end_allocated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the end of the allocated memory. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00276">276</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/base/<a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
