<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DerivativeApproximation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DerivativeApproximation Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace2a9964b7da0d28c8184346902a6563"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:ace2a9964b7da0d28c8184346902a6563"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ace2a9964b7da0d28c8184346902a6563">approximate_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned int component=0)</td></tr>
<tr class="separator:ace2a9964b7da0d28c8184346902a6563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96e5a10a7b5dc8617c8e80efab64eb5"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:aa96e5a10a7b5dc8617c8e80efab64eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#aa96e5a10a7b5dc8617c8e80efab64eb5">approximate_gradient</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned int component=0)</td></tr>
<tr class="separator:aa96e5a10a7b5dc8617c8e80efab64eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f18de1e83609860a8244a6ecb939e2"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:a78f18de1e83609860a8244a6ecb939e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a78f18de1e83609860a8244a6ecb939e2">approximate_second_derivative</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned int component=0)</td></tr>
<tr class="separator:a78f18de1e83609860a8244a6ecb939e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae818e3c3dda7a215ca51ef7e8c443df0"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:ae818e3c3dda7a215ca51ef7e8c443df0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ae818e3c3dda7a215ca51ef7e8c443df0">approximate_second_derivative</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned int component=0)</td></tr>
<tr class="separator:ae818e3c3dda7a215ca51ef7e8c443df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48374cde5c4f8290906c74cd3b72035c"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , class InputVector , int order&gt; </td></tr>
<tr class="memitem:a48374cde5c4f8290906c74cd3b72035c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a48374cde5c4f8290906c74cd3b72035c">approximate_derivative_tensor</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;mapping, const DoFHandlerType &amp;dof, const InputVector &amp;solution, const typename DoFHandlerType::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, DoFHandlerType::dimension &gt; &amp;derivative, const unsigned int component=0)</td></tr>
<tr class="separator:a48374cde5c4f8290906c74cd3b72035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93966982a03bb2844db9cb933f4d3032"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , class InputVector , int order&gt; </td></tr>
<tr class="memitem:a93966982a03bb2844db9cb933f4d3032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a93966982a03bb2844db9cb933f4d3032">approximate_derivative_tensor</a> (const DoFHandlerType &amp;dof, const InputVector &amp;solution, const typename DoFHandlerType::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, DoFHandlerType::dimension &gt; &amp;derivative, const unsigned int component=0)</td></tr>
<tr class="separator:a93966982a03bb2844db9cb933f4d3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplParams" colspan="2">template&lt;int dim, int order&gt; </td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative)</td></tr>
<tr class="separator:acb554e2cd5a43377269eb278b394dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f3c26181266c16c70727b84301d27f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68f3c26181266c16c70727b84301d27f">ExcVectorLengthVsNActiveCells</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga68f3c26181266c16c70727b84301d27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab44c48829b37a139eaa9de31589bbf"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5ab44c48829b37a139eaa9de31589bbf">ExcInsufficientDirections</a> ()</td></tr>
<tr class="separator:ga5ab44c48829b37a139eaa9de31589bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions that compute a cell-wise approximation of the norm of a derivative of a finite element field by taking difference quotients between neighboring cells. This is a rather simple but efficient form to get an error indicator, since it can be computed with relatively little numerical effort and yet gives a reasonable approximation.</p>
<p>The way the difference quotients are computed on cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is the following (here described for the approximation of the gradient of a finite element field, but see below for higher derivatives): let <img class="formulaInl" alt="$K'$" src="form_1147.png"/> be a neighboring cell, and let <img class="formulaInl" alt="$y_{K'}=x_{K'}-x_K$" src="form_1148.png"/> be the distance vector between the centers of the two cells, then <img class="formulaInl" alt="$ \frac{u_h(x_{K'}) - u_h(x_K)}{ \|y_{K'}\| }$" src="form_1149.png"/> is an approximation of the directional derivative <img class="formulaInl" alt="$ \nabla u(x_K) \cdot \frac{y_{K'}}{ \|y_{K'}\| }.$" src="form_1150.png"/> By multiplying both terms by <img class="formulaInl" alt="$\frac{y_{K'}}{ \|y_{K'}\| }$" src="form_1151.png"/> from the left and summing over all neighbors <img class="formulaInl" alt="$K'$" src="form_1147.png"/>, we obtain <img class="formulaInl" alt="$ \sum_{K'} \left( \frac{y_{K'}}{ \|y_{K'}\|} \frac{y_{K'}^T}{ \|y_{K'}\| } \right) \nabla u(x_K) \approx \sum_{K'} \left( \frac{y_{K'}}{ \|y_{K'}\|} \frac{u_h(x_{K'}) - u_h(x_K)}{ \|y_{K'}\| } \right).$" src="form_1152.png"/></p>
<p>Thus, if the matrix <img class="formulaInl" alt="$ Y = \sum_{K'} \left( \frac{y_{K'}}{\|y_{K'}\|} \frac{y_{K'}^T}{ \|y_{K'}\| } \right)$" src="form_1153.png"/> is regular (which is the case when the vectors <img class="formulaInl" alt="$y_{K'}$" src="form_1154.png"/> to all neighbors span the whole space), we can obtain an approximation to the true gradient by <img class="formulaInl" alt="$ \nabla u(x_K) \approx Y^{-1} \sum_{K'} \left( \frac{y_{K'}}{\|y_{K'}\|} \frac{u_h(x_{K'}) - u_h(x_K)}{ \|y_{K'}\| } \right).$" src="form_1155.png"/> This is a quantity that is easily computed. The value returned for each cell when calling the <code>approximate_gradient</code> function of this class is the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> norm of this approximation to the gradient. To make this a useful quantity, you may want to scale each element by the correct power of the respective cell size.</p>
<p>The computation of this quantity must fail if a cell has only neighbors for which the direction vectors <img class="formulaInl" alt="$y_K$" src="form_1156.png"/> do not span the whole space, since then the matrix <img class="formulaInl" alt="$Y$" src="form_1157.png"/> is no longer invertible. If this happens, you will get an error similar to this one: </p><div class="fragment"><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;749&gt; of file &lt;source/numerics/derivative_approximation.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keywordtype">void</span> DerivativeApproximation::approximate(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim,spacedim&gt;</a>&amp;, <span class="keyword">const</span> DoFHandlerType&lt;dim,spacedim&gt;&amp;, <span class="keyword">const</span> InputVector&amp;, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">const</span></div><div class="line"> std::pair&lt;unsigned int, unsigned int&gt;&amp;, <a class="code" href="classVector.html">Vector&lt;float&gt;</a>&amp;) [with DerivativeDescription = DerivativeApproximation::Gradient&lt;3&gt;, <span class="keywordtype">int</span></div><div class="line">dim = 3, DoFHandlerType = <a class="code" href="classDoFHandler.html">DoFHandler</a>, InputVector = <a class="code" href="classVector.html">Vector&lt;double&gt;</a>]</div><div class="line">The violated condition was:</div><div class="line">    determinant(Y) != 0</div><div class="line">The name and call sequence of the exception was:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga5ab44c48829b37a139eaa9de31589bbf">ExcInsufficientDirections</a>()</div><div class="line">Additional Information:</div><div class="line">(none)</div><div class="line">--------------------------------------------------------</div></div><!-- fragment --><p> As can easily be verified, this can only happen on very coarse grids, when some cells and all their neighbors have not been refined even once. You should therefore only call the functions of this class if all cells are at least once refined. In practice this is not much of a restriction.</p>
<h3>Approximation of higher derivatives</h3>
<p>Similar to the reasoning above, approximations to higher derivatives can be computed in a similar fashion. For example, the tensor of second derivatives is approximated by the formula <img class="formulaInl" alt="$ \nabla^2 u(x_K) \approx Y^{-1} \sum_{K'} \left( \frac{y_{K'}}{\|y_{K'}\|} \otimes \frac{\nabla u_h(x_{K'}) - \nabla u_h(x_K)}{ \|y_{K'}\| } \right), $" src="form_1158.png"/> where <img class="formulaInl" alt="$\otimes$" src="form_1159.png"/> denotes the outer product of two vectors. Note that unlike the true tensor of second derivatives, its approximation is not necessarily symmetric. This is due to the fact that in the derivation, it is not clear whether we shall consider as projected second derivative the term <img class="formulaInl" alt="$\nabla^2 u y_{KK'}$" src="form_1160.png"/> or <img class="formulaInl" alt="$y_{KK'}^T \nabla^2 u$" src="form_1161.png"/>. Depending on which choice we take, we obtain one approximation of the tensor of second derivatives or its transpose. To avoid this ambiguity, as result we take the symmetrized form, which is the mean value of the approximation and its transpose.</p>
<p>The returned value on each cell is the spectral norm of the approximated tensor of second derivatives, i.e. the largest eigenvalue by absolute value. This equals the largest curvature of the finite element field at each cell, and the spectral norm is the matrix norm associated to the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> vector norm.</p>
<p>Even higher than the second derivative can be obtained along the same lines as exposed above.</p>
<h3>Refinement indicators based on the derivatives</h3>
<p>If you would like to base a refinement criterion upon these approximation of the derivatives, you will have to scale the results of this class by an appropriate power of the mesh width. For example, since <img class="formulaInl" alt="$\|u-u_h\|^2_{L_2} \le C h^2 \|\nabla u\|^2_{L_2}$" src="form_1162.png"/>, it might be the right thing to scale the indicators as <img class="formulaInl" alt="$\eta_K = h \|\nabla u\|_K$" src="form_1163.png"/>, i.e. <img class="formulaInl" alt="$\eta_K = h^{1+d/2} \|\nabla u\|_{\infty;K}$" src="form_1164.png"/>, i.e. the right power is <img class="formulaInl" alt="$1+d/2$" src="form_1165.png"/>.</p>
<p>Likewise, for the second derivative, one should choose a power of the mesh size <img class="formulaInl" alt="$h$" src="form_720.png"/> one higher than for the gradient.</p>
<h3>Implementation</h3>
<p>The formulae for the computation of approximations to the gradient and to the tensor of second derivatives shown above are very much alike. The basic difference is that in one case the finite difference quotient is a scalar, while in the other case it is a vector. For higher derivatives, this would be a tensor of even higher rank. We then have to form the outer product of this difference quotient with the distance vector <img class="formulaInl" alt="$y_{KK'}$" src="form_1166.png"/>, symmetrize it, contract it with the matrix <img class="formulaInl" alt="$Y^{-1}$" src="form_1167.png"/> and compute its norm. To make the implementation simpler and to allow for code reuse, all these operations that are dependent on the actual order of the derivatives to be approximated, as well as the computation of the quantities entering the difference quotient, have been separated into auxiliary nested classes (names <code>Gradient</code> and <code>SecondDerivative</code>) and the main algorithm is simply passed one or the other data types and asks them to perform the order dependent operations. The main framework that is independent of this, such as finding all active neighbors, or setting up the matrix <img class="formulaInl" alt="$Y$" src="form_1157.png"/> is done in the main function <code>approximate</code>.</p>
<p>Due to this way of operation, the class may be easily extended for higher oder derivatives than are presently implemented. Basically, only an additional class along the lines of the derivative descriptor classes <code>Gradient</code> and <code>SecondDerivative</code> has to be implemented, with the respective typedefs and functions replaced by the appropriate analogues for the derivative that is to be approximated.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2000 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ace2a9964b7da0d28c8184346902a6563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2a9964b7da0d28c8184346902a6563">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to obtain an approximation of the gradient. Pass it the DoF handler object that describes the finite element field, a nodal value vector, and receive the cell-wise Euclidean norm of the approximated gradient.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01018">1018</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="aa96e5a10a7b5dc8617c8e80efab64eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96e5a10a7b5dc8617c8e80efab64eb5">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <code>interpolate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01034">1034</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a78f18de1e83609860a8244a6ecb939e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f18de1e83609860a8244a6ecb939e2">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the analogue to the one above, computing finite difference approximations of the tensor of second derivatives. Pass it the DoF handler object that describes the finite element field, a nodal value vector, and receive the cell-wise spectral norm of the approximated tensor of second derivatives. The spectral norm is the matrix norm associated to the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> vector norm.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01049">1049</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="ae818e3c3dda7a215ca51ef7e8c443df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae818e3c3dda7a215ca51ef7e8c443df0">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <code>interpolate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01065">1065</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a48374cde5c4f8290906c74cd3b72035c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48374cde5c4f8290906c74cd3b72035c">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, DoFHandlerType::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the <code>order</code>-th order approximate derivative and returns the full tensor for a single cell.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01081">1081</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a93966982a03bb2844db9cb933f4d3032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93966982a03bb2844db9cb933f4d3032">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, DoFHandlerType::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01106">1106</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="acb554e2cd5a43377269eb278b394dfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb554e2cd5a43377269eb278b394dfa2">&#9670;&nbsp;</a></span>derivative_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DerivativeApproximation::derivative_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the norm of the derivative. </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01132">1132</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
