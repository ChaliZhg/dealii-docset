<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MatrixBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1MatrixBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MatrixBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__matrix__base_8h_source.html">deal.II/lac/petsc_matrix_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MatrixBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MatrixBase__inherit__graph.svg" width="596" height="198"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9daaa67d19e61e1f59135e31b6002820"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a></td></tr>
<tr class="separator:a9daaa67d19e61e1f59135e31b6002820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02115578620b6df0638b8754bad6aaaa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a></td></tr>
<tr class="separator:a02115578620b6df0638b8754bad6aaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f9f200e7a90df0c74bd9a96bb9cd8"><td class="memItemLeft" align="right" valign="top">typedef PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a></td></tr>
<tr class="separator:af69f9f200e7a90df0c74bd9a96bb9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afe8c5db4389d2eb35ea78e1b2db6c041">MatrixBase</a> ()</td></tr>
<tr class="separator:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9582573cb9b8fe8a21387dce79860c90"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9582573cb9b8fe8a21387dce79860c90">~MatrixBase</a> ()</td></tr>
<tr class="separator:a9582573cb9b8fe8a21387dce79860c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4172ea26dafecdd3843447342f62a10c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4172ea26dafecdd3843447342f62a10c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a> d)</td></tr>
<tr class="separator:a4172ea26dafecdd3843447342f62a10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const bool elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const bool elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const bool elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *col_indices, const PetscScalar *values, const bool elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const bool elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const bool elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const bool elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *col_indices, const PetscScalar *values, const bool elide_zero_values=true, const bool col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264ec17db96d955590626c8da8e6aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ae264ec17db96d955590626c8da8e6aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8eddd61ef58cb9f312b47b0e3c165f7a">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j) const</td></tr>
<tr class="separator:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89476484bfd365c60972c76d3a893925"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> j) const</td></tr>
<tr class="separator:a89476484bfd365c60972c76d3a893925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2bb6345b774b4029dc1cc04b6c5ecedf">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> i) const</td></tr>
<tr class="separator:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d397cb51074c94824c3db0a21e6210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m</a> () const</td></tr>
<tr class="separator:ae6d397cb51074c94824c3db0a21e6210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31319c249e3ff1bf572c79ee0f41bade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a31319c249e3ff1bf572c79ee0f41bade">n</a> () const</td></tr>
<tr class="separator:a31319c249e3ff1bf572c79ee0f41bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b350e8500ad00885d36508ded03c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size</a> () const</td></tr>
<tr class="separator:a8b350e8500ad00885d36508ded03c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca73a7174b92973d2a57e41af737fd1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range</a> () const</td></tr>
<tr class="separator:adca73a7174b92973d2a57e41af737fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988bc02bfef4479879867a411eb2b682"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a988bc02bfef4479879867a411eb2b682">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> index) const</td></tr>
<tr class="separator:a988bc02bfef4479879867a411eb2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadd5aebcdc166b840df3430a23606"><td class="memItemLeft" align="right" valign="top">virtual const MPI_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">get_mpi_communicator</a> () const =0</td></tr>
<tr class="separator:ae1aadd5aebcdc166b840df3430a23606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc9652ade95e371d4191e28461eeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adfcc9652ade95e371d4191e28461eeb8">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:adfcc9652ade95e371d4191e28461eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0aee7127b31ea26d3847ce7d4d9236ad">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> row) const</td></tr>
<tr class="separator:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1976b38af71b46e0fa5f3b4837f2fd05">l1_norm</a> () const</td></tr>
<tr class="separator:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ba7168f27d27bae50b653587fd8f"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afd06ba7168f27d27bae50b653587fd8f">linfty_norm</a> () const</td></tr>
<tr class="separator:afd06ba7168f27d27bae50b653587fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5ab9e8f1061cef606eaeb0993ce3d887">frobenius_norm</a> () const</td></tr>
<tr class="separator:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0c76f22865de9a597b7342f87463e"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae7e0c76f22865de9a597b7342f87463e">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:ae7e0c76f22865de9a597b7342f87463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aef113fe7fed539cc6e5a75f457571"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0aef113fe7fed539cc6e5a75f457571">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:aa0aef113fe7fed539cc6e5a75f457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b99bfc37fc183a7d978ec48f83623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4b99bfc37fc183a7d978ec48f83623">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:aad4b99bfc37fc183a7d978ec48f83623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455541189a44467806299d3f0e0d2005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a455541189a44467806299d3f0e0d2005">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a455541189a44467806299d3f0e0d2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be932238458b6c1cd83b51571891a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5be932238458b6c1cd83b51571891a6a">add</a> (const PetscScalar factor, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a5be932238458b6c1cd83b51571891a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb0884ba6df009131584806e3b63808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aabb0884ba6df009131584806e3b63808">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other, const PetscScalar factor) 1</td></tr>
<tr class="separator:aabb0884ba6df009131584806e3b63808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e08f3caffe58c6213f1a142140d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a228e08f3caffe58c6213f1a142140d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa53f7571665e69020dd5c1c90cf2e04d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714cb0c98ae635dd7591b40192dc9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a714cb0c98ae635dd7591b40192dc9240">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a714cb0c98ae635dd7591b40192dc9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab7d09f592d2683c8d9cb7e422dfc2e57">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ad4470cefee04a01c4595b609d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin</a> () const</td></tr>
<tr class="separator:a417ad4470cefee04a01c4595b609d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2141ca2fb58139da5e1f532634958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end</a> () const</td></tr>
<tr class="separator:a6cc2141ca2fb58139da5e1f532634958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7d876a5651cfc339c93a5406b4f7eb79">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> r) const</td></tr>
<tr class="separator:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748f0b7f03b5b7452a38b92561d2943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0748f0b7f03b5b7452a38b92561d2943">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> r) const</td></tr>
<tr class="separator:a0748f0b7f03b5b7452a38b92561d2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a01597f3233c1f817a09471c937e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac11a01597f3233c1f817a09471c937e3">operator Mat</a> () const</td></tr>
<tr class="separator:ac11a01597f3233c1f817a09471c937e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ebd95b68d080d6656aa53bba651b0b"><td class="memItemLeft" align="right" valign="top">PetscBooleanType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25ebd95b68d080d6656aa53bba651b0b">is_symmetric</a> (const double tolerance=1.e-12)</td></tr>
<tr class="separator:a25ebd95b68d080d6656aa53bba651b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc542395926e82eef9360801fcff4b07"><td class="memItemLeft" align="right" valign="top">PetscBooleanType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afc542395926e82eef9360801fcff4b07">is_hermitian</a> (const double tolerance=1.e-12)</td></tr>
<tr class="separator:afc542395926e82eef9360801fcff4b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515e640202d1ad50bd9baa13c404cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7515e640202d1ad50bd9baa13c404cb1">print</a> (std::ostream &amp;out, const bool alternative_output=false) const</td></tr>
<tr class="separator:a7515e640202d1ad50bd9baa13c404cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7a8873fc01cd20682e079dbb8f225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0af7a8873fc01cd20682e079dbb8f225">memory_consumption</a> () const</td></tr>
<tr class="separator:a0af7a8873fc01cd20682e079dbb8f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gacd8a5f80f5a4d368d5f1a31d39db865d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacd8a5f80f5a4d368d5f1a31d39db865d">ExcSourceEqualsDestination</a> ()</td></tr>
<tr class="separator:gacd8a5f80f5a4d368d5f1a31d39db865d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd943ab88fef4b2a39143695b874eafe"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabd943ab88fef4b2a39143695b874eafe">ExcWrongMode</a> (int arg1, int arg2)</td></tr>
<tr class="separator:gabd943ab88fef4b2a39143695b874eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9795580277a7bc3a4348443768b6c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9795580277a7bc3a4348443768b6c0fd">prepare_action</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> new_action)</td></tr>
<tr class="separator:a9795580277a7bc3a4348443768b6c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0e10ef38e7bb5901bc5678a8a4ffd6d">assert_is_compressed</a> ()</td></tr>
<tr class="separator:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1deda2ab63ef62230745b4ff99bd26d6">last_action</a></td></tr>
<tr class="separator:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac9d0bef234b3bee00f709ae9506c4b78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac9d0bef234b3bee00f709ae9506c4b78">MatrixBase</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)</td></tr>
<tr class="separator:ac9d0bef234b3bee00f709ae9506c4b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7066ca270f211ac404fa88310535f706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7066ca270f211ac404fa88310535f706">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)</td></tr>
<tr class="separator:a7066ca270f211ac404fa88310535f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa0f173897e0d5d926636e85aa68c7286"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0f173897e0d5d926636e85aa68c7286">column_indices</a></td></tr>
<tr class="separator:aa0f173897e0d5d926636e85aa68c7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289dc1463501c97a48127414ce5ee1ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscScalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a289dc1463501c97a48127414ce5ee1ac">column_values</a></td></tr>
<tr class="separator:a289dc1463501c97a48127414ce5ee1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4d4720fcda9813b7fdcd3f0cb04ac6">::BlockMatrixBase</a></td></tr>
<tr class="separator:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all matrix classes that are implemented on top of the PETSc matrix types. Since in PETSc all matrix types (i.e. sequential and parallel, sparse, blocked, etc.) are built by filling the contents of an abstract object that is only referenced through a pointer of a type that is independent of the actual matrix type, we can implement almost all functionality of matrices in this base class. Derived classes will then only have to provide the functionality to create one or the other kind of matrix.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class in deal.II. It has almost the same member functions, and is often exchangeable. However, since PETSc only supports a single scalar type (either double, float, or a complex data type), it is not templated, and only works with whatever your PETSc installation has defined the data type PetscScalar to.</p>
<p>Note that PETSc only guarantees that operations do what you expect if the functions <code>MatAssemblyBegin</code> and <code>MatAssemblyEnd</code> have been called after matrix assembly. Therefore, you need to call <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">SparseMatrix::compress()</a> before you actually use the matrix. This also calls <code>MatCompress</code> that compresses the storage format for sparse matrices by discarding unused elements. PETSc allows to continue with assembling the matrix after calls to these functions, but since there are no more free entries available after that any more, it is better to only call <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">SparseMatrix::compress()</a> once at the end of the assembly stage and before the matrix is actively used.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2004 </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00269">269</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9daaa67d19e61e1f59135e31b6002820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daaa67d19e61e1f59135e31b6002820">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">PETScWrappers::MatrixBase::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00275">275</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a02115578620b6df0638b8754bad6aaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02115578620b6df0638b8754bad6aaaa">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">PETScWrappers::MatrixBase::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00280">280</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="af69f9f200e7a90df0c74bd9a96bb9cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69f9f200e7a90df0c74bd9a96bb9cd8">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PetscScalar <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">PETScWrappers::MatrixBase::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef in analogy to all the other container classes. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00285">285</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe8c5db4389d2eb35ea78e1b2db6c041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c5db4389d2eb35ea78e1b2db6c041">&#9670;&nbsp;</a></span>MatrixBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00076">76</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9582573cb9b8fe8a21387dce79860c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9582573cb9b8fe8a21387dce79860c90">&#9670;&nbsp;</a></span>~MatrixBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::~MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00084">84</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ac9d0bef234b3bee00f709ae9506c4b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d0bef234b3bee00f709ae9506c4b78">&#9670;&nbsp;</a></span>MatrixBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>purposefully not implemented </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4172ea26dafecdd3843447342f62a10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4172ea26dafecdd3843447342f62a10c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af69f9f200e7a90df0c74bd9a96bb9cd8">value_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00112">112</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b895d26bc6c0a0cf96d37d00e5853c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00092">92</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af5067751068b7290030fe97cc8cadd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5067751068b7290030fe97cc8cadd02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a6e591d33f2af5e44a20c8b3e30943">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="a90d04e83f54969c8c504da62bdee60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d04e83f54969c8c504da62bdee60a8">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="abc988c43c687b2af0b7e4352def7f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc988c43c687b2af0b7e4352def7f19b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fe7cc7dd404261b63b7ee651233de1">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017ad4b1e0e18954db42d489e91ed0bb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="a97b079c5bf7843592a347a9874752eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b079c5bf7843592a347a9874752eef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a068368a605f2661042e104f0ad3eef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068368a605f2661042e104f0ad3eef47">&#9670;&nbsp;</a></span>add() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8298c20ffaf1ba83c286e119fd53e7d0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5dd7bf11e94aeeeca18e94576c06e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="af918fe8858fea210e01de289340c2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918fe8858fea210e01de289340c2468">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets some entries to zero. It may drop them from the sparsity pattern, though (but retains the allocated memory in case new entries are again added later).</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &ndash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00128">128</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25c2d67d301ec5cb4181b071168a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c2d67d301ec5cb4181b071168a6783">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00138">138</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae264ec17db96d955590626c8da8e6aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264ec17db96d955590626c8da8e6aad">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PETSc matrices store their own sparsity patterns. So, in analogy to our own <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting matrix to be used in all other operations where before only assembly functions were allowed. This function must therefore be called once you have assembled the matrix.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00207">207</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8eddd61ef58cb9f312b47b0e3c165f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eddd61ef58cb9f312b47b0e3c165f7a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. In contrast to the respective function in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class, we don't throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, since PETSc does not transmit this information.</p>
<p>This function is therefore exactly equivalent to the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a></code> function. </p>

</div>
</div>
<a id="a89476484bfd365c60972c76d3a893925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89476484bfd365c60972c76d3a893925">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00178">178</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a2bb6345b774b4029dc1cc04b6c5ecedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6345b774b4029dc1cc04b6c5ecedf">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic.</p>
<p>Since we do not have direct access to the underlying data structure, this function is no faster than the elementwise access using the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a> function. However, we provide this function for compatibility with the <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> class. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00195">195</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae6d397cb51074c94824c3db0a21e6210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d397cb51074c94824c3db0a21e6210">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> PETScWrappers::MatrixBase::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00246">246</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a31319c249e3ff1bf572c79ee0f41bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31319c249e3ff1bf572c79ee0f41bade">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00259">259</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8b350e8500ad00885d36508ded03c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b350e8500ad00885d36508ded03c159">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range()</a>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00272">272</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adca73a7174b92973d2a57e41af737fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca73a7174b92973d2a57e41af737fd1">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> &gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00285">285</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a988bc02bfef4479879867a411eb2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988bc02bfef4479879867a411eb2b682">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range()</a>. </p>

</div>
</div>
<a id="ae1aadd5aebcdc166b840df3430a23606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadd5aebcdc166b840df3430a23606">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const MPI_Comm&amp; PETScWrappers::MatrixBase::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. This function has to be implemented in derived classes. </p>

<p>Implemented in <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a9855056dec88e659ee0dddfcc704afbd">PETScWrappers::MPI::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a9855056dec88e659ee0dddfcc704afbd">PETScWrappers::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1MatrixFree.html#adac3cb017e4652fb9f144ac924512489">PETScWrappers::MatrixFree</a>, and <a class="el" href="classPETScWrappers_1_1FullMatrix.html#a961d0089366aa41c6a01f25f62559232">PETScWrappers::FullMatrix</a>.</p>

</div>
</div>
<a id="adfcc9652ade95e371d4191e28461eeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc9652ade95e371d4191e28461eeb8">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00299">299</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0aee7127b31ea26d3847ce7d4d9236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee7127b31ea26d3847ce7d4d9236ad">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">MatrixBase::size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00312">312</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1976b38af71b46e0fa5f3b4837f2fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b38af71b46e0fa5f3b4837f2fd05">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the l1-norm of the matrix, that is <img class="formulaInl" alt="$|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|$" src="form_989.png"/>, (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. <img class="formulaInl" alt="$|Mv|_1\leq |M|_1 |v|_1$" src="form_990.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00347">347</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afd06ba7168f27d27bae50b653587fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ba7168f27d27bae50b653587fd8f">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is <img class="formulaInl" alt="$|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|$" src="form_991.png"/>, (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. <img class="formulaInl" alt="$|Mv|_infty \leq |M|_infty |v|_infty$" src="form_992.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00360">360</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5ab9e8f1061cef606eaeb0993ce3d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9e8f1061cef606eaeb0993ce3d887">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00373">373</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae7e0c76f22865de9a597b7342f87463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0c76f22865de9a597b7342f87463e">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <img class="formulaInl" alt="$v$" src="form_987.png"/> with respect to the norm induced by this matrix, i.e. <img class="formulaInl" alt="$\left(v,Mv\right)$" src="form_988.png"/>. This is useful, e.g. in the finite element context, where the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then the given vector has to be a distributed vector as well. Conversely, if the matrix is not distributed, then neither may the vector be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00385">385</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa0aef113fe7fed539cc6e5a75f457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aef113fe7fed539cc6e5a75f457571">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_980.png"/>.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00394">394</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aad4b99bfc37fc183a7d978ec48f83623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b99bfc37fc183a7d978ec48f83623">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00419">419</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a455541189a44467806299d3f0e0d2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455541189a44467806299d3f0e0d2005">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00430">430</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5be932238458b6c1cd83b51571891a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be932238458b6c1cd83b51571891a6a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the matrix <code>other</code> scaled by the factor <code>factor</code> to the current matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00441">441</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aabb0884ba6df009131584806e3b63808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb0884ba6df009131584806e3b63808">&#9670;&nbsp;</a></span>add() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the matrix <code>other</code> scaled by the factor <code>factor</code> to the current matrix. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Use the function with order of arguments reversed instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00454">454</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a228e08f3caffe58c6213f1a142140d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228e08f3caffe58c6213f1a142140d3f">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00462">462</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa53f7571665e69020dd5c1c90cf2e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f7571665e69020dd5c1c90cf2e04d">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00474">474</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adb7231c9d5f340181ac3c45827f5b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231c9d5f340181ac3c45827f5b9e4">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00486">486</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a714cb0c98ae635dd7591b40192dc9240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714cb0c98ae635dd7591b40192dc9240">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00498">498</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab7d09f592d2683c8d9cb7e422dfc2e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d09f592d2683c8d9cb7e422dfc2e57">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then all vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00509">509</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a417ad4470cefee04a01c4595b609d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417ad4470cefee04a01c4595b609d310">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. </p>

</div>
</div>
<a id="a6cc2141ca2fb58139da5e1f532634958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2141ca2fb58139da5e1f532634958">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="a7d876a5651cfc339c93a5406b4f7eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d876a5651cfc339c93a5406b4f7eb79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferencable in that case. </p>

</div>
</div>
<a id="a0748f0b7f03b5b7452a38b92561d2943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748f0b7f03b5b7452a38b92561d2943">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9daaa67d19e61e1f59135e31b6002820">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a02115578620b6df0638b8754bad6aaaa">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="ac11a01597f3233c1f817a09471c937e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a01597f3233c1f817a09471c937e3">&#9670;&nbsp;</a></span>operator Mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion operator to gain access to the underlying PETSc type. If you do this, you cut this class off some information it may need, so this conversion operator should only be used if you know what you do. In particular, it should only be used for read-only operations into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00525">525</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aacd76b6ce3247735964836a82eedff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76b6ce3247735964836a82eedff6d">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an in-place transpose of a matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00531">531</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25ebd95b68d080d6656aa53bba651b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ebd95b68d080d6656aa53bba651b0b">&#9670;&nbsp;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBooleanType PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a matrix is symmetric. Default tolerance is <img class="formulaInl" alt="$1000\times32$" src="form_1054.png"/>-bit machine precision. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00538">538</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afc542395926e82eef9360801fcff4b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc542395926e82eef9360801fcff4b07">&#9670;&nbsp;</a></span>is_hermitian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBooleanType PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a matrix is Hermitian, i.e. it is the complex conjugate of its transpose. Default tolerance is <img class="formulaInl" alt="$1000\times32$" src="form_1054.png"/>-bit machine precision. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00548">548</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ad127fd1b40ab452473f96cc298694528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad127fd1b40ab452473f96cc298694528">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the PETSc matrix object values using PETSc internal matrix viewer function <code>MatView</code>. The default format prints the non- zero matrix elements. For other valid view formats, consult <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html</a> </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00560">560</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a7515e640202d1ad50bd9baa13c404cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515e640202d1ad50bd9baa13c404cb1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the elements of a matrix to the given output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The output stream to which to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_output</td><td>This argument is ignored. It exists for compatibility with similar functions in other matrix classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00575">575</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0af7a8873fc01cd20682e079dbb8f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7a8873fc01cd20682e079dbb8f225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number bytes consumed by this matrix on this CPU. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00606">606</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9795580277a7bc3a4348443768b6c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9795580277a7bc3a4348443768b6c0fd">&#9670;&nbsp;</a></span>prepare_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the add/set mode that is required for actions following this call is compatible with the current mode. Should be called from all internal functions accessing matrix elements. </p>

</div>
</div>
<a id="aa0e10ef38e7bb5901bc5678a8a4ffd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e10ef38e7bb5901bc5678a8a4ffd6d">&#9670;&nbsp;</a></span>assert_is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::assert_is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function that checks that there are no pending insert/add operations. Throws an exception otherwise. Useful before calling any PETSc internal functions modifying the matrix. </p>

</div>
</div>
<a id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e49d52a74cc86386a9aff01fa88c74">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a id="a9d1b00916f856722282dcd9abb408581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b00916f856722282dcd9abb408581">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<a id="a7066ca270f211ac404fa88310535f706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7066ca270f211ac404fa88310535f706">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>purposefully not implemented </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aad4d4720fcda9813b7fdcd3f0cb04ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d4720fcda9813b7fdcd3f0cb04ac6">&#9670;&nbsp;</a></span>::BlockMatrixBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow calling protected <a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add()</a> and <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set()</a>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00971">971</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfce46e53089351cc7fe6b9ea44e167f">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A generic matrix object in PETSc. The actual type, a sparse matrix, is set in the constructor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00901">901</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a1deda2ab63ef62230745b4ff99bd26d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deda2ab63ef62230745b4ff99bd26d6">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the last action was a write or add operation. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00906">906</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="aa0f173897e0d5d926636e85aa68c7286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f173897e0d5d926636e85aa68c7286">&#9670;&nbsp;</a></span>column_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscInt&gt; PETScWrappers::MatrixBase::column_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal array of integer values that is used to store the column indices when adding/inserting local data into the (large) sparse matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00958">958</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a289dc1463501c97a48127414ce5ee1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289dc1463501c97a48127414ce5ee1ac">&#9670;&nbsp;</a></span>column_values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscScalar&gt; PETScWrappers::MatrixBase::column_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal array of double values that is used to store the column indices when adding/inserting local data into the (large) sparse matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00965">965</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/lac/<a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/lac/<a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
