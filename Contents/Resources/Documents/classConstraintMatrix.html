<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ConstraintMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classConstraintMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConstraintMatrix Class Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a><a class="el" href="group__dofs.html">Degrees of Freedom</a> &raquo;  &#124; <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="constraint__matrix_8h_source.html">deal.II/lac/constraint_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConstraintMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classConstraintMatrix__inherit__graph.svg" width="130" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a13384243a9580fd6540f0b5bc9ab2e12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a> { <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a>, 
<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12a9a973f6cdef8bfbb583f05d520940bd9">left_object_wins</a>, 
<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12a77ea16e7d833659a57b4cc7ef2aa83ff">right_object_wins</a>
 }</td></tr>
<tr class="separator:a13384243a9580fd6540f0b5bc9ab2e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b13eb29cd43c9e87abebf2bf78b2a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a></td></tr>
<tr class="separator:a71b13eb29cd43c9e87abebf2bf78b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0441dd6e2b4ac88a06ec8a74842aa67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab0441dd6e2b4ac88a06ec8a74842aa67">ConstraintMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:ab0441dd6e2b4ac88a06ec8a74842aa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9abe681db430ed7493b8f86034d2bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#acd9abe681db430ed7493b8f86034d2bf">ConstraintMatrix</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix)</td></tr>
<tr class="separator:acd9abe681db430ed7493b8f86034d2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2726821354883ac97fe7e6181de9792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:ac2726821354883ac97fe7e6181de9792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dae90cd37e79a8c2b1669b0070ddc00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a6dae90cd37e79a8c2b1669b0070ddc00">can_store_line</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line_index) const</td></tr>
<tr class="separator:a6dae90cd37e79a8c2b1669b0070ddc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1846dabf9e29ff49df6e06bf711ea1d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a1846dabf9e29ff49df6e06bf711ea1d8">get_local_lines</a> () const</td></tr>
<tr class="separator:a1846dabf9e29ff49df6e06bf711ea1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133ef470eff7de0d26a28610a047753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa133ef470eff7de0d26a28610a047753">add_selected_constraints</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_in, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;filter)</td></tr>
<tr class="separator:aa133ef470eff7de0d26a28610a047753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding constraints</div></td></tr>
<tr class="memitem:a24eb022f65797389badbb6d21da5b708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line)</td></tr>
<tr class="separator:a24eb022f65797389badbb6d21da5b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f0436882283ec56368f4b8a9bf85e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab97f0436882283ec56368f4b8a9bf85e">add_lines</a> (const std::vector&lt; bool &gt; &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:ab97f0436882283ec56368f4b8a9bf85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c11118d7fc3117aea42de57062ee6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a3c11118d7fc3117aea42de57062ee6c3">add_lines</a> (const std::set&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:a3c11118d7fc3117aea42de57062ee6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5e306f3db7f2e2a7256af61626c445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9d5e306f3db7f2e2a7256af61626c445">add_lines</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a>)</td></tr>
<tr class="separator:a9d5e306f3db7f2e2a7256af61626c445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd323a407cb379510a68c26e842304e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> column, const double value)</td></tr>
<tr class="separator:a4cd323a407cb379510a68c26e842304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c906810edcc1917729cdca50d76c021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const std::vector&lt; std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, double &gt; &gt; &amp;col_val_pairs)</td></tr>
<tr class="separator:a5c906810edcc1917729cdca50d76c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2121ba9d256cbab8e6b8390fb89dda74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line, const double value)</td></tr>
<tr class="separator:a2121ba9d256cbab8e6b8390fb89dda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8056d07faa2a7ed3f158c1b42d56abc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ()</td></tr>
<tr class="separator:a8056d07faa2a7ed3f158c1b42d56abc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa471ba15f320b700280ab5e5ac59d88b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa471ba15f320b700280ab5e5ac59d88b">merge</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;other_constraints, const <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a> merge_conflict_behavior=<a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a>, const bool allow_different_local_lines=false)</td></tr>
<tr class="separator:aa471ba15f320b700280ab5e5ac59d88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad971fb29f0a15bf8d30704d2a5ab445e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ad971fb29f0a15bf8d30704d2a5ab445e">shift</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> offset)</td></tr>
<tr class="separator:ad971fb29f0a15bf8d30704d2a5ab445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24120d0331183f9a63cbe41493a19f6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ()</td></tr>
<tr class="separator:a24120d0331183f9a63cbe41493a19f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying constraints</div></td></tr>
<tr class="memitem:a319c347182a3494ee5b3fa6a1bf695ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a319c347182a3494ee5b3fa6a1bf695ef">n_constraints</a> () const</td></tr>
<tr class="separator:a319c347182a3494ee5b3fa6a1bf695ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997d5e0e75f237a2be3fb37d84e1d53c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const</td></tr>
<tr class="separator:a997d5e0e75f237a2be3fb37d84e1d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34db859de5fc65649d8f7495b245cbe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a34db859de5fc65649d8f7495b245cbe4">is_identity_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const</td></tr>
<tr class="separator:a34db859de5fc65649d8f7495b245cbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3f87f29b0dbb7afe97dc99612444fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a6f3f87f29b0dbb7afe97dc99612444fc">are_identity_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index1, const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index2) const</td></tr>
<tr class="separator:a6f3f87f29b0dbb7afe97dc99612444fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1a988c68b8d59ac61fffe9436aaa9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#adc1a988c68b8d59ac61fffe9436aaa9e">max_constraint_indirections</a> () const</td></tr>
<tr class="separator:adc1a988c68b8d59ac61fffe9436aaa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367f93d7e359cb06e6d72d5c5966ffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ae367f93d7e359cb06e6d72d5c5966ffe">is_inhomogeneously_constrained</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index) const</td></tr>
<tr class="separator:ae367f93d7e359cb06e6d72d5c5966ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76cd7374da0a363afa66505d7c326ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ac76cd7374da0a363afa66505d7c326ee">has_inhomogeneities</a> () const</td></tr>
<tr class="separator:ac76cd7374da0a363afa66505d7c326ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d3dc702008e4a0bee164bd29a72bcf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, double &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa6d3dc702008e4a0bee164bd29a72bcf">get_constraint_entries</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const</td></tr>
<tr class="separator:aa6d3dc702008e4a0bee164bd29a72bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eda01d5f45eeaab0b32d875e082bf50"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a2eda01d5f45eeaab0b32d875e082bf50">get_inhomogeneity</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const</td></tr>
<tr class="separator:a2eda01d5f45eeaab0b32d875e082bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ae3cf8b7d318dc1835b5e451162ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ae0ae3cf8b7d318dc1835b5e451162ed3">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae0ae3cf8b7d318dc1835b5e451162ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da62200cf2765acf71c20943d84505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a12da62200cf2765acf71c20943d84505">write_dot</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:a12da62200cf2765acf71c20943d84505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68677933afb4c4874a0b949cc4fe7354"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a68677933afb4c4874a0b949cc4fe7354">memory_consumption</a> () const</td></tr>
<tr class="separator:a68677933afb4c4874a0b949cc4fe7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33044f37f2df60a5fa1b78a26b7205e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ad33044f37f2df60a5fa1b78a26b7205e">resolve_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;indices) const</td></tr>
<tr class="separator:ad33044f37f2df60a5fa1b78a26b7205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems after their creation</div></td></tr>
<tr class="memitem:a05a5f8d313eb2c777e8c9a66b9cd0a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">condense</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a05a5f8d313eb2c777e8c9a66b9cd0a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4d0577171daeed2cb767619ef3cd4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9b4d0577171daeed2cb767619ef3cd4c">condense</a> (<a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a9b4d0577171daeed2cb767619ef3cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ad4d2acd1b918dce631033747975d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a65ad4d2acd1b918dce631033747975d3">condense</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a65ad4d2acd1b918dce631033747975d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3cdaaabe4f059117c5531717be576b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aef3cdaaabe4f059117c5531717be576b">condense</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:aef3cdaaabe4f059117c5531717be576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a6c6a7e47d18b094328d7255253e64"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:aa0a6c6a7e47d18b094328d7255253e64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa0a6c6a7e47d18b094328d7255253e64">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:aa0a6c6a7e47d18b094328d7255253e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938fc9a995331887632249cc3280836"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a9938fc9a995331887632249cc3280836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a9938fc9a995331887632249cc3280836">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:a9938fc9a995331887632249cc3280836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f791c671a32f0967e04e060fbe634da"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a6f791c671a32f0967e04e060fbe634da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a6f791c671a32f0967e04e060fbe634da">condense</a> (VectorType &amp;vec) const</td></tr>
<tr class="separator:a6f791c671a32f0967e04e060fbe634da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519a950347d180bd70a3949c4f75380"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:af519a950347d180bd70a3949c4f75380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#af519a950347d180bd70a3949c4f75380">condense</a> (const VectorType &amp;vec_ghosted, VectorType &amp;output) const</td></tr>
<tr class="separator:af519a950347d180bd70a3949c4f75380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaf1612855fe118ca05c8b264ae392e"><td class="memTemplParams" colspan="2">template&lt;typename number , class VectorType &gt; </td></tr>
<tr class="memitem:aedaf1612855fe118ca05c8b264ae392e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aedaf1612855fe118ca05c8b264ae392e">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, VectorType &amp;vector) const</td></tr>
<tr class="separator:aedaf1612855fe118ca05c8b264ae392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505204d2a13bf7ecd98537b0ec8c7dc4"><td class="memTemplParams" colspan="2">template&lt;typename number , class BlockVectorType &gt; </td></tr>
<tr class="memitem:a505204d2a13bf7ecd98537b0ec8c7dc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a505204d2a13bf7ecd98537b0ec8c7dc4">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, BlockVectorType &amp;vector) const</td></tr>
<tr class="separator:a505204d2a13bf7ecd98537b0ec8c7dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4f1186dc10d707b933b6ff24f7cad8"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a5a4f1186dc10d707b933b6ff24f7cad8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5a4f1186dc10d707b933b6ff24f7cad8">set_zero</a> (VectorType &amp;vec) const</td></tr>
<tr class="separator:a5a4f1186dc10d707b933b6ff24f7cad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems during their creation</div></td></tr>
<tr class="memitem:a1c61203741d499990c6288c3fcf3d48c"><td class="memTemplParams" colspan="2">template&lt;class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a1c61203741d499990c6288c3fcf3d48c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (const InVector &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</td></tr>
<tr class="separator:a1c61203741d499990c6288c3fcf3d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c6923dbed7310344a75360fda3d4a8"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename LocalType &gt; </td></tr>
<tr class="memitem:af4c6923dbed7310344a75360fda3d4a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#af4c6923dbed7310344a75360fda3d4a8">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, VectorType &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:af4c6923dbed7310344a75360fda3d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b71c666610158b7dca38803818e59"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename LocalType &gt; </td></tr>
<tr class="memitem:a258b71c666610158b7dca38803818e59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a258b71c666610158b7dca38803818e59">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices_row, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices_col, VectorType &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;local_matrix, bool diagonal=false) const</td></tr>
<tr class="separator:a258b71c666610158b7dca38803818e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326bcda2e260428ea4f2ba3a2255a692"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a326bcda2e260428ea4f2ba3a2255a692"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a326bcda2e260428ea4f2ba3a2255a692">distribute_local_to_global</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> index, const double value, VectorType &amp;global_vector) const</td></tr>
<tr class="separator:a326bcda2e260428ea4f2ba3a2255a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd03cdb082dc5a5d8bb647ee9d6752f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a4cd03cdb082dc5a5d8bb647ee9d6752f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a4cd03cdb082dc5a5d8bb647ee9d6752f">distribute_local_to_global</a> (ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end, ForwardIteratorInd local_indices_begin, VectorType &amp;global_vector) const</td></tr>
<tr class="separator:a4cd03cdb082dc5a5d8bb647ee9d6752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf1401a8b7f9510ab5230a31f1b8a40"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:adbf1401a8b7f9510ab5230a31f1b8a40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#adbf1401a8b7f9510ab5230a31f1b8a40">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:adbf1401a8b7f9510ab5230a31f1b8a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c71cc4387e90b6133d3e78070f43839"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a5c71cc4387e90b6133d3e78070f43839"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5c71cc4387e90b6133d3e78070f43839">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;col_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:a5c71cc4387e90b6133d3e78070f43839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b2367cb12d4ff1adc080606619f568"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a82b2367cb12d4ff1adc080606619f568"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a82b2367cb12d4ff1adc080606619f568">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, VectorType &amp;global_vector, bool use_inhomogeneities_for_rhs=false) const</td></tr>
<tr class="separator:a82b2367cb12d4ff1adc080606619f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42f9aba996e2528dc152497eac08dd8"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ac42f9aba996e2528dc152497eac08dd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ac42f9aba996e2528dc152497eac08dd8">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const bool keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;dof_mask=<a class="el" href="classConstraintMatrix.html#aa67af6d18d297f65d6b56f99ae7a9285">default_empty_table</a>) const</td></tr>
<tr class="separator:ac42f9aba996e2528dc152497eac08dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a06681a4539f12bd68e7d289703803"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:aa9a06681a4539f12bd68e7d289703803"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa9a06681a4539f12bd68e7d289703803">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;col_indices, SparsityPatternType &amp;sparsity_pattern, const bool keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;dof_mask=<a class="el" href="classConstraintMatrix.html#aa67af6d18d297f65d6b56f99ae7a9285">default_empty_table</a>) const</td></tr>
<tr class="separator:aa9a06681a4539f12bd68e7d289703803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d6d6eddec96cbf89bbcd036d7bdad9"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a08d6d6eddec96cbf89bbcd036d7bdad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a08d6d6eddec96cbf89bbcd036d7bdad9">get_dof_values</a> (const VectorType &amp;global_vector, ForwardIteratorInd local_indices_begin, ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end) const</td></tr>
<tr class="separator:a08d6d6eddec96cbf89bbcd036d7bdad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with constraints after solving a linear system</div></td></tr>
<tr class="memitem:a5bd4b10531ae0809a415d91742d1870c"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a5bd4b10531ae0809a415d91742d1870c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (VectorType &amp;vec) const</td></tr>
<tr class="separator:a5bd4b10531ae0809a415d91742d1870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gaafd58bda97981dfc86b3654ac9ecdc19"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafd58bda97981dfc86b3654ac9ecdc19">ExcMatrixIsClosed</a> ()</td></tr>
<tr class="separator:gaafd58bda97981dfc86b3654ac9ecdc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63b2e6907ffe43413a3296d2cde21d9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae63b2e6907ffe43413a3296d2cde21d9">ExcMatrixNotClosed</a> ()</td></tr>
<tr class="separator:gae63b2e6907ffe43413a3296d2cde21d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662aea30cbcffb10aeffcad6fe642c45"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga662aea30cbcffb10aeffcad6fe642c45">ExcLineInexistant</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1)</td></tr>
<tr class="separator:ga662aea30cbcffb10aeffcad6fe642c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7f7c5806b915ae58d9ce0f2185309f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7b7f7c5806b915ae58d9ce0f2185309f">ExcEntryAlreadyExists</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg2, double arg3, double arg4)</td></tr>
<tr class="separator:ga7b7f7c5806b915ae58d9ce0f2185309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5d19336f7aa45faf5160f33f1f15dd"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafe5d19336f7aa45faf5160f33f1f15dd">ExcDoFConstrainedToConstrainedDoF</a> (int arg1, int arg2)</td></tr>
<tr class="separator:gafe5d19336f7aa45faf5160f33f1f15dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa2bddb6fbfc6be527e09cc855fe046"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacaa2bddb6fbfc6be527e09cc855fe046">ExcDoFIsConstrainedFromBothObjects</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1)</td></tr>
<tr class="separator:gacaa2bddb6fbfc6be527e09cc855fe046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c38a69942d473e9295af8d5793056a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf6c38a69942d473e9295af8d5793056a">ExcDoFIsConstrainedToConstrainedDoF</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1)</td></tr>
<tr class="separator:gaf6c38a69942d473e9295af8d5793056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaae2806ad80ff5e91679c2a88ce3f7f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafaae2806ad80ff5e91679c2a88ce3f7f">ExcRowNotStoredHere</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1)</td></tr>
<tr class="separator:gafaae2806ad80ff5e91679c2a88ce3f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab45b93494c924c08ef17c87ce02f2450"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab45b93494c924c08ef17c87ce02f2450">ExcColumnNotStoredHere</a> (<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg1, <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> arg2)</td></tr>
<tr class="separator:gab45b93494c924c08ef17c87ce02f2450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a2721431e38681ad8f5739ca622046"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga67a2721431e38681ad8f5739ca622046">ExcIncorrectConstraint</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga67a2721431e38681ad8f5739ca622046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0cac0047ea6195b97e2153b295df6c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0cac0047ea6195b97e2153b295df6c27">calculate_line_index</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> line) const</td></tr>
<tr class="separator:a0cac0047ea6195b97e2153b295df6c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69df832a2a5319c89931eee55914e856"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a69df832a2a5319c89931eee55914e856"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a69df832a2a5319c89931eee55914e856">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, VectorType &amp;global_vector, bool use_inhomogeneities_for_rhs, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;) const</td></tr>
<tr class="separator:a69df832a2a5319c89931eee55914e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a59dfeb5b4080a5b88164707c5a5a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:aa79a59dfeb5b4080a5b88164707c5a5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa79a59dfeb5b4080a5b88164707c5a5a">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, VectorType &amp;global_vector, bool use_inhomogeneities_for_rhs, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;) const</td></tr>
<tr class="separator:aa79a59dfeb5b4080a5b88164707c5a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d4bdda031092cf1e865bf1a90e3b6b"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a81d4bdda031092cf1e865bf1a90e3b6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a81d4bdda031092cf1e865bf1a90e3b6b">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const bool keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;dof_mask, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;) const</td></tr>
<tr class="separator:a81d4bdda031092cf1e865bf1a90e3b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c876b33b45b88768b435cb3dd0d93a3"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a7c876b33b45b88768b435cb3dd0d93a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a7c876b33b45b88768b435cb3dd0d93a3">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const bool keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;dof_mask, <a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;) const</td></tr>
<tr class="separator:a7c876b33b45b88768b435cb3dd0d93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01aad750025aa4263f0620649dda06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ab01aad750025aa4263f0620649dda06c">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, internals::GlobalRowsFromLocal &amp;global_rows) const</td></tr>
<tr class="separator:ab01aad750025aa4263f0620649dda06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c750b2a837a13ec360113b101b117d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ac2c750b2a837a13ec360113b101b117d">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;active_dofs) const</td></tr>
<tr class="separator:ac2c750b2a837a13ec360113b101b117d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2910e8107287dc297b58cf601597d59a"><td class="memTemplParams" colspan="2">template&lt;typename LocalType &gt; </td></tr>
<tr class="memitem:a2910e8107287dc297b58cf601597d59a"><td class="memTemplItemLeft" align="right" valign="top">LocalType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a2910e8107287dc297b58cf601597d59a">resolve_vector_entry</a> (const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> i, const internals::GlobalRowsFromLocal &amp;global_rows, const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;local_dof_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:a2910e8107287dc297b58cf601597d59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c40831563ee3d4362b932d713ae0b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a5c40831563ee3d4362b932d713ae0b08">operator=</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;other)</td></tr>
<tr class="separator:a5c40831563ee3d4362b932d713ae0b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aadfab7e5ddcde341e5843d99abd77149"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aadfab7e5ddcde341e5843d99abd77149">check_zero_weight</a> (const std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, double &gt; &amp;p)</td></tr>
<tr class="separator:aadfab7e5ddcde341e5843d99abd77149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0f3b653958a9f500be62c61791e42dd0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a0f3b653958a9f500be62c61791e42dd0">lines</a></td></tr>
<tr class="separator:a0f3b653958a9f500be62c61791e42dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db0740488705b778ab6eedeec9c1fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a25db0740488705b778ab6eedeec9c1fb">lines_cache</a></td></tr>
<tr class="separator:a25db0740488705b778ab6eedeec9c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dd31bd6fceeb6b67fe54017e0750b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#a58dd31bd6fceeb6b67fe54017e0750b5">local_lines</a></td></tr>
<tr class="separator:a58dd31bd6fceeb6b67fe54017e0750b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada29d922494c2b645e418cc311ec872d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#ada29d922494c2b645e418cc311ec872d">sorted</a></td></tr>
<tr class="separator:ada29d922494c2b645e418cc311ec872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa67af6d18d297f65d6b56f99ae7a9285"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html#aa67af6d18d297f65d6b56f99ae7a9285">default_empty_table</a> = <a class="el" href="classTable.html">Table</a>&lt;2,bool&gt;()</td></tr>
<tr class="separator:aa67af6d18d297f65d6b56f99ae7a9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements dealing with linear (possibly inhomogeneous) constraints on degrees of freedom. The concept and origin of such constraints is extensively described in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module. The class is meant to deal with a limited number of constraints relative to the total number of degrees of freedom, for example a few per cent up to maybe 30 per cent; and with a linear combination of <em>M</em> other degrees of freedom where <em>M</em> is also relatively small (no larger than at most around the average number of entries per row of a linear system). It is <em>not</em> meant to describe full rank linear systems.</p>
<p>The algorithms used in the implementation of this class are described in some detail in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. There is also a significant amount of documentation on how to use this class in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<h3>Description of constraints</h3>
<p>Each "line" in objects of this class corresponds to one constrained degree of freedom, with the number of the line being <em>i</em>, entered by using <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> or <a class="el" href="classConstraintMatrix.html#ab97f0436882283ec56368f4b8a9bf85e">add_lines()</a>. The entries in this line are pairs of the form (<em>j</em>,<em>a<sub>ij</sub></em>), which are added by <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> or <a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries()</a>. The organization is essentially a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, but with only a few lines containing nonzero elements, and therefore no data wasted on the others. For each line, which has been added by the mechanism above, an elimination of the constrained degree of freedom of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_i = \sum_j a_{ij} x_j + b_i \]" src="form_997.png"/>
</p>
<p> is performed, where <em>b<sub>i</sub></em> is optional and set by <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. Thus, if a constraint is formulated for instance as a zero mean value of several degrees of freedom, one of the degrees has to be chosen to be eliminated.</p>
<p>Note that the constraints are linear in the <em>x<sub>i</sub></em>, and that there might be a constant (non-homogeneous) term in the constraint. This is exactly the form we need for hanging node constraints, where we need to constrain one degree of freedom in terms of others. There are other conditions of this form possible, for example for implementing mean value conditions as is done in the <a class="el" href="step_11.html">step-11</a> tutorial program. The name of the class stems from the fact that these constraints can be represented in matrix form as <b>X</b> <em>x</em> = <em>b</em>, and this object then describes the matrix <b>X</b> (and the vector <em>b</em>; originally, the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class was only meant to handle homogenous constraints where <em>b</em>=0, thus the name). The most frequent way to create/fill objects of this type is using the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints()</a> function. The use of these objects is first explained in <a class="el" href="step_6.html">step-6</a>.</p>
<p>Objects of the present type are organized in lines (rows), but only those lines are stored where constraints are present. New constraints are added by adding new lines using the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function, and then populating it using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function to a given line, or <a class="el" href="classConstraintMatrix.html#a5c906810edcc1917729cdca50d76c021">add_entries()</a> to add more than one entry at a time. The right hand side element, if nonzero, can be set using the <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a> function. After all constraints have been added, you need to call <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a>, which compresses the storage format and sorts the entries.</p>
<dl class="section note"><dt>Note</dt><dd>Many of the algorithms this class implements are discussed in the <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a>. The algorithms are also related to those shown in <em>M. S. Shephard: Linear multipoint constraints applied via transformation as part of a direct stiffness assembly process. Int. J. Numer. Meth. Engrg., vol. 20 (1984), pp. 2107-2112.</em>, with the difference that the algorithms shown there completely eliminated constrained degrees of freedom, whereas we usually keep them as part of the linear system.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Martin Kronbichler, 1998, 2004, 2008, 2009 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00135">135</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a71b13eb29cd43c9e87abebf2bf78b2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b13eb29cd43c9e87abebf2bf78b2a3">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">ConstraintMatrix::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00141">141</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a13384243a9580fd6540f0b5bc9ab2e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13384243a9580fd6540f0b5bc9ab2e12">&#9670;&nbsp;</a></span>MergeConflictBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">ConstraintMatrix::MergeConflictBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum that describes what should happen if the two <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects involved in a call to the <a class="el" href="classConstraintMatrix.html#aa471ba15f320b700280ab5e5ac59d88b">merge()</a> function happen to have constraints on the same degrees of freedom. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c"></a>no_conflicts_allowed&#160;</td><td class="fielddoc"><p>Throw an exception if the two objects concerned have conflicting constraints on the same degree of freedom. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13384243a9580fd6540f0b5bc9ab2e12a9a973f6cdef8bfbb583f05d520940bd9"></a>left_object_wins&#160;</td><td class="fielddoc"><p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a13384243a9580fd6540f0b5bc9ab2e12a77ea16e7d833659a57b4cc7ef2aa83ff"></a>right_object_wins&#160;</td><td class="fielddoc"><p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm2</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l00148">148</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0441dd6e2b4ac88a06ec8a74842aa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0441dd6e2b4ac88a06ec8a74842aa67">&#9670;&nbsp;</a></span>ConstraintMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintMatrix::ConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. The supplied <a class="el" href="classIndexSet.html">IndexSet</a> defines which indices might be constrained inside this <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. In a calculation with a <a class="el" href="classDoFHandler.html">DoFHandler</a> object based on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, one should use the set of locally relevant dofs (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">GlossLocallyRelevantDof</a>).</p>
<p>The given <a class="el" href="classIndexSet.html">IndexSet</a> allows the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to save memory by just not caring about degrees of freedom that are not of importance to the current processor. Alternatively, if no such <a class="el" href="classIndexSet.html">IndexSet</a> is provided, internal data structures for <em>all</em> possible indices will be created, leading to memory consumption on every processor that is proportional to the <em>overall</em> size of the problem, not just proportional to the size of the portion of the overall problem that is handled by the current processor. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01405">1405</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="acd9abe681db430ed7493b8f86034d2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9abe681db430ed7493b8f86034d2bf">&#9670;&nbsp;</a></span>ConstraintMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintMatrix::ConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01420">1420</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2726821354883ac97fe7e6181de9792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2726821354883ac97fe7e6181de9792">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear()</a> the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object and supply an <a class="el" href="classIndexSet.html">IndexSet</a> with lines that may be constrained. This function is only relevant in the distributed case to supply a different <a class="el" href="classIndexSet.html">IndexSet</a>. Otherwise this routine is equivalent to calling <a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear()</a>. See the constructor for details. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00670">670</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a6dae90cd37e79a8c2b1669b0070ddc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dae90cd37e79a8c2b1669b0070ddc00">&#9670;&nbsp;</a></span>can_store_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::can_store_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if we can store a constraint for the given <code>line_index</code>. This routine only matters in the distributed case and checks if the <a class="el" href="classIndexSet.html">IndexSet</a> allows storage of this line. Always returns true if not in the distributed case. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01610">1610</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a1846dabf9e29ff49df6e06bf711ea1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1846dabf9e29ff49df6e06bf711ea1d8">&#9670;&nbsp;</a></span>get_local_lines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp; ConstraintMatrix::get_local_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index set describing locally relevant lines if any are present. Note that if no local lines were given, this represents an empty <a class="el" href="classIndexSet.html">IndexSet</a>, whereas otherwise it contains the global problem size and the local range. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01619">1619</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="aa133ef470eff7de0d26a28610a047753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa133ef470eff7de0d26a28610a047753">&#9670;&nbsp;</a></span>add_selected_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_selected_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the content of <code>constraints_in</code> with DoFs that are element of the <a class="el" href="classIndexSet.html">IndexSet</a> <code>filter</code>. Elements that are not present in the <a class="el" href="classIndexSet.html">IndexSet</a> are ignored. All DoFs will be transformed to local index space of the filter, both the constrained DoFs and the other DoFs these entries are constrained to. The local index space of the filter is a contiguous numbering of all (global) DoFs that are elements in the filter.</p>
<p>If, for example, the filter represents the range <code>[10,20)</code>, and the constraint matrix <code>constraints_in</code> includes the global indices <code>{7,13,14}</code>, the indices <code>{3,4}</code> are added to the calling constraint matrix (since 13 and 14 are elements in the filter and element 13 is the fourth element in the index, and 14 is the fifth).</p>
<p>This function provides an easy way to create a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for certain vector components in a vector-valued problem from a full <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, i.e. extracting a diagonal subblock from a larger <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. The block is specified by the <a class="el" href="classIndexSet.html">IndexSet</a> argument. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00163">163</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a24eb022f65797389badbb6d21da5b708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eb022f65797389badbb6d21da5b708">&#9670;&nbsp;</a></span>add_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new line to the matrix. If the line already exists, then the function simply returns without doing anything. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01432">1432</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="ab97f0436882283ec56368f4b8a9bf85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f0436882283ec56368f4b8a9bf85e">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> for which <code>lines[i]</code> is true.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00103">103</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a3c11118d7fc3117aea42de57062ee6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c11118d7fc3117aea42de57062ee6c3">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00093">93</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a9d5e306f3db7f2e2a7256af61626c445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5e306f3db7f2e2a7256af61626c445">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_lines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity()</a>. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00113">113</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a4cd323a407cb379510a68c26e842304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd323a407cb379510a68c26e842304e">&#9670;&nbsp;</a></span>add_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an entry to a given line. The list of lines is searched from the back to the front, so clever programming would add a new line (which is pushed to the back) and immediately afterwards fill the entries of that line. This way, no expensive searching is needed.</p>
<p>If an entry with the same indices as the one this function call denotes already exists, then this function simply returns provided that the value of the entry is the same. Thus, it does no harm to enter a constraint twice. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01465">1465</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a5c906810edcc1917729cdca50d76c021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c906810edcc1917729cdca50d76c021">&#9670;&nbsp;</a></span>add_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_val_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a whole series of entries, denoted by pairs of column indices and values, to a line of constraints. This function is equivalent to calling the preceding function several times, but is faster. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00123">123</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a2121ba9d256cbab8e6b8390fb89dda74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2121ba9d256cbab8e6b8390fb89dda74">&#9670;&nbsp;</a></span>set_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::set_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an inhomogeneity to the constraint line <em>i</em>, according to the discussion in the general class description.</p>
<dl class="section note"><dt>Note</dt><dd>the line needs to be added with one of the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> calls first. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01508">1508</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a8056d07faa2a7ed3f158c1b42d56abc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8056d07faa2a7ed3f158c1b42d56abc8">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the filling of entries. Since the lines of a matrix of this type are usually filled in an arbitrary order and since we do not want to use associative constrainers to store the lines, we need to sort the lines and within the lines the columns before usage of the matrix. This is done through this function.</p>
<p>Also, zero entries are discarded, since they are not needed.</p>
<p>After closing, no more entries are accepted. If the object was already closed, then this function returns immediately.</p>
<p>This function also resolves chains of constraints. For example, degree of freedom 13 may be constrained to <img class="formulaInl" alt="$u_{13} = \frac{u_3}{2} + \frac{u_7}{2}$" src="form_998.png"/> while degree of freedom 7 is itself constrained as <img class="formulaInl" alt="$u_{7} = \frac{u_2}{2} + \frac{u_4}{2}$" src="form_999.png"/>. Then, the resolution will be that <img class="formulaInl" alt="$u_{13} = \frac{u_3}{2} + \frac{u_2}{4} + \frac{u_4}{4}$" src="form_1000.png"/>. Note, however, that cycles in this graph of constraints are not allowed, i.e. for example <img class="formulaInl" alt="$u_4$" src="form_1001.png"/> may not be constrained, directly or indirectly, to <img class="formulaInl" alt="$u_{13}$" src="form_1002.png"/> again. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00187">187</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="aa471ba15f320b700280ab5e5ac59d88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa471ba15f320b700280ab5e5ac59d88b">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12">MergeConflictBehavior</a>&#160;</td>
          <td class="paramname"><em>merge_conflict_behavior</em> = <code><a class="el" href="classConstraintMatrix.html#a13384243a9580fd6540f0b5bc9ab2e12acbfe858c120a4048128ed22a4b7d6d3c">no_conflicts_allowed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_different_local_lines</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the constraints represented by the object given as argument into the constraints represented by this object. Both objects may or may not be closed (by having their function <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> called before). If this object was closed before, then it will be closed afterwards as well. Note, however, that if the other argument is closed, then merging may be significantly faster.</p>
<p>Using the default value of the second arguments, the constraints in each of the two objects (the old one represented by this object and the argument) may not refer to the same degree of freedom, i.e. a degree of freedom that is constrained in one object may not be constrained in the second. If this is nevertheless the case, an exception is thrown. However, this behavior can be changed by providing a different value for the second argument.</p>
<p>By default, merging two <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects that are initialized with different <a class="el" href="classIndexSet.html">IndexSet</a> objects is not allowed. This behavior can be altered by setting <code>allow_different_local_lines</code> appropriately.</p>
<p>Merging a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> that is initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> and one that is not initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> is not yet implemented. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00476">476</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="ad971fb29f0a15bf8d30704d2a5ab445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad971fb29f0a15bf8d30704d2a5ab445e">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift all entries of this matrix down <code>offset</code> rows and over <code>offset</code> columns. If this object is initialized with an <a class="el" href="classIndexSet.html">IndexSet</a>, local_lines are shifted as well.</p>
<p>This function is useful if you are building block matrices, where all blocks are built by the same <a class="el" href="classDoFHandler.html">DoFHandler</a> object, i.e. the matrix size is larger than the number of degrees of freedom. Since several matrix rows and columns correspond to the same degrees of freedom, you'd generate several constraint objects, then shift them, and finally <a class="el" href="classConstraintMatrix.html#aa471ba15f320b700280ab5e5ac59d88b">merge()</a> them together again. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00618">618</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a24120d0331183f9a63cbe41493a19f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24120d0331183f9a63cbe41493a19f6b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all entries of this matrix. Reset the flag determining whether new entries are accepted or not.</p>
<p>This function may be called also on objects which are empty or already cleared. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00653">653</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a319c347182a3494ee5b3fa6a1bf695ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319c347182a3494ee5b3fa6a1bf695ef">&#9670;&nbsp;</a></span>n_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> ConstraintMatrix::n_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of constraints stored in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01524">1524</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a997d5e0e75f237a2be3fb37d84e1d53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997d5e0e75f237a2be3fb37d84e1d53c">&#9670;&nbsp;</a></span>is_constrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::is_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the degree of freedom with number <code>index</code> is a constrained one.</p>
<p>Note that if <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> was called before, then this function is significantly faster, since then the constrained degrees of freedom are sorted and we can do a binary search, while before <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a> was called, we have to perform a linear search through all entries. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01533">1533</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a34db859de5fc65649d8f7495b245cbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34db859de5fc65649d8f7495b245cbe4">&#9670;&nbsp;</a></span>is_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::is_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the dof is constrained, and whether it is constrained to only one other degree of freedom with weight one. The function therefore returns whether the degree of freedom would simply be eliminated in favor of exactly one other degree of freedom.</p>
<p>The function returns <code>false</code> if either the degree of freedom is not constrained at all, or if it is constrained to more than one other degree of freedom, or if it is constrained to only one degree of freedom but with a weight different from one. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01083">1083</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a6f3f87f29b0dbb7afe97dc99612444fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3f87f29b0dbb7afe97dc99612444fc">&#9670;&nbsp;</a></span>are_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::are_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the two given degrees of freedom are linked by an equality constraint that either constrains index1 to be so that <code>index1=index2</code> or constrains index2 so that <code>index2=index1</code>. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01098">1098</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="adc1a988c68b8d59ac61fffe9436aaa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1a988c68b8d59ac61fffe9436aaa9e">&#9670;&nbsp;</a></span>max_constraint_indirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">ConstraintMatrix::size_type</a> ConstraintMatrix::max_constraint_indirections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of other dofs that one dof is constrained to. For example, in 2d a hanging node is constrained only to its two neighbors, so the returned value would be 2. However, for higher order elements and/or higher dimensions, or other types of constraints, this number is no more obvious.</p>
<p>The name indicates that within the system matrix, references to a constrained node are indirected to the nodes it is constrained to. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01130">1130</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="ae367f93d7e359cb06e6d72d5c5966ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae367f93d7e359cb06e6d72d5c5966ffe">&#9670;&nbsp;</a></span>is_inhomogeneously_constrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::is_inhomogeneously_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> in case the dof is constrained and there is a non- trivial inhomogeneous values set to the dof. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01545">1545</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="ac76cd7374da0a363afa66505d7c326ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76cd7374da0a363afa66505d7c326ee">&#9670;&nbsp;</a></span>has_inhomogeneities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::has_inhomogeneities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>false</code> if all constraints in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> are homogeneous ones, and <code>true</code> if there is at least one inhomogeneity. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01145">1145</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="aa6d3dc702008e4a0bee164bd29a72bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d3dc702008e4a0bee164bd29a72bcf">&#9670;&nbsp;</a></span>get_constraint_entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, double &gt; &gt; * ConstraintMatrix::get_constraint_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the the vector of entries if a line is constrained, and a zero pointer in case the dof is not constrained. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01564">1564</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a2eda01d5f45eeaab0b32d875e082bf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eda01d5f45eeaab0b32d875e082bf50">&#9670;&nbsp;</a></span>get_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ConstraintMatrix::get_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the inhomogeneity stored in the constrained dof <code>line</code>. Unconstrained dofs also return a zero value. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01580">1580</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="ae0ae3cf8b7d318dc1835b5e451162ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ae3cf8b7d318dc1835b5e451162ed3">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the constraints represented by the current object to the given stream.</p>
<p>For each constraint of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{42} = 0.5 x_2 + 0.25 x_{14} + 2.75 \]" src="form_1003.png"/>
</p>
<p> this function will write a sequence of lines that look like this: </p><div class="fragment"><div class="line">42 2 : 0.5</div><div class="line">42 14 : 0.25</div><div class="line">42 : 2.75</div></div><!-- fragment --><p> The last line is only shown if the inhomogeneity (here: 2.75) is nonzero.</p>
<p>A block of lines such as the one above is repeated for each constrained degree of freedom. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01156">1156</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a12da62200cf2765acf71c20943d84505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da62200cf2765acf71c20943d84505">&#9670;&nbsp;</a></span>write_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::write_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph of constraints in 'dot' format. 'dot' is a program that can take a list of nodes and produce a graphical representation of the graph of constrained degrees of freedom and the degrees of freedom they are constrained to.</p>
<p>The output of this function can be used as input to the 'dot' program that can convert the graph into a graphical representation in postscript, png, xfig, and a number of other formats.</p>
<p>This function exists mostly for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01193">1193</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a68677933afb4c4874a0b949cc4fe7354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68677933afb4c4874a0b949cc4fe7354">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ConstraintMatrix::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01215">1215</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="ad33044f37f2df60a5fa1b78a26b7205e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33044f37f2df60a5fa1b78a26b7205e">&#9670;&nbsp;</a></span>resolve_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::resolve_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the constraint indices associated to the indices in the given vector. After a call to this function, the indices vector contains the initial elements and all the associated constrained indices. This function sorts the elements and suppresses duplicates. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l01226">1226</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a05a5f8d313eb2c777e8c9a66b9cd0a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a5f8d313eb2c777e8c9a66b9cd0a62">&#9670;&nbsp;</a></span>condense() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a sparsity pattern. The name of the function mimics the name of the function we use to condense linear systems, but it is a bit of a misnomer for the current context. This is because in the context of linear systems, we eliminate certain rows and columns of the linear system, i.e., we "reduce" or "condense" the linear system. On the other hand, in the current context, the functions does not remove nonzero entries from the sparsity pattern. Rather, it adds those nonzero entry locations to the sparsity pattern that will later be needed for the process of condensation of constrained degrees of freedom from a linear system.</p>
<p>Since this function adds new nonzero entries to the sparsity pattern, the given sparsity pattern must not be compressed. The constraint matrix (i.e., the current object) must be closed. The sparsity pattern is compressed at the end of the function. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00684">684</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a9b4d0577171daeed2cb767619ef3cd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4d0577171daeed2cb767619ef3cd4c">&#9670;&nbsp;</a></span>condense() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparsity patterns. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00858">858</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a65ad4d2acd1b918dce631033747975d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ad4d2acd1b918dce631033747975d3">&#9670;&nbsp;</a></span>condense() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00768">768</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="aef3cdaaabe4f059117c5531717be576b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3cdaaabe4f059117c5531717be576b">&#9670;&nbsp;</a></span>condense() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00970">970</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="aa0a6c6a7e47d18b094328d7255253e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a6c6a7e47d18b094328d7255253e64">&#9670;&nbsp;</a></span>condense() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix, i.e., eliminate the rows and columns of the matrix that correspond to constrained degrees of freedom.</p>
<p>See the general documentation of this class for more detailed information. </p>

</div>
</div>
<a id="a9938fc9a995331887632249cc3280836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9938fc9a995331887632249cc3280836">&#9670;&nbsp;</a></span>condense() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices. </p>

</div>
</div>
<a id="a6f791c671a32f0967e04e060fbe634da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f791c671a32f0967e04e060fbe634da">&#9670;&nbsp;</a></span>condense() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense the given vector in-place. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. Note that this function does not take any inhomogeneity into account and throws an exception in case there are any inhomogeneities. Use the function using both a matrix and vector for that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not work for MPI vectors. Use <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">condense()</a> with two vector arguments instead. </dd></dl>

</div>
</div>
<a id="af519a950347d180bd70a3949c4f75380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af519a950347d180bd70a3949c4f75380">&#9670;&nbsp;</a></span>condense() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec_ghosted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function copies and condenses values from <code>vec_ghosted</code> into <code>output</code>. In a serial code it is equivalent to calling condense (vec). If called in parallel, <code>vec_ghosted</code> is supposed to contain ghost elements while <code>output</code> should not. </p>

</div>
</div>
<a id="aedaf1612855fe118ca05c8b264ae392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaf1612855fe118ca05c8b264ae392e">&#9670;&nbsp;</a></span>condense() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix and a given vector by eliminating rows and columns of the linear system that correspond to constrained degrees of freedom. The sparsity pattern associated with the matrix needs to be condensed and compressed. This function is the appropriate choice for applying inhomogeneous constraints.</p>
<p>The constraint matrix object must be closed to call this function.</p>
<p>See the general documentation of this class for more detailed information. </p>

</div>
</div>
<a id="a505204d2a13bf7ecd98537b0ec8c7dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505204d2a13bf7ecd98537b0ec8c7dc4">&#9670;&nbsp;</a></span>condense() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number , class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices and vectors. </p>

</div>
</div>
<a id="a5a4f1186dc10d707b933b6ff24f7cad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4f1186dc10d707b933b6ff24f7cad8">&#9670;&nbsp;</a></span>set_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::set_zero </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the values of all constrained DoFs in a vector to zero. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. </p>

</div>
</div>
<a id="a1c61203741d499990c6288c3fcf3d48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c61203741d499990c6288c3fcf3d48c">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InVector , class OutVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary.</p>
<p>Note that this function will apply all constraints as if they were homogeneous. For correctly setting inhomogeneous constraints, use the similar function with a matrix argument or the function with both matrix and vector arguments.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_vector</td><td><a class="el" href="classVector.html">Vector</a> of local contributions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_dof_indices</td><td>Local degrees of freedom indices corresponding to the vector of local contributions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_vector</td><td>The global vector to which all local contributions will be added. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01680">1680</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="af4c6923dbed7310344a75360fda3d4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c6923dbed7310344a75360fda3d4a8">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename LocalType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary. This includes writing into diagonal elements of the matrix if the corresponding degree of freedom is constrained.</p>
<p>The fourth argument <code>local_matrix</code> is intended to be used in case one wants to apply inhomogeneous constraints on the vector only. Such a situation could be where one wants to assemble of a right hand side vector on a problem with inhomogeneous constraints, but the global matrix has been assembled previously. A typical example of this is a time stepping algorithm where the stiffness matrix is assembled once, and the right hand side updated every time step. Note that, however, the entries in the columns of the local matrix have to be exactly the same as those that have been written into the global matrix. Otherwise, this function will not be able to correctly handle inhomogeneities.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

</div>
</div>
<a id="a258b71c666610158b7dca38803818e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b71c666610158b7dca38803818e59">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename LocalType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function, except that it uses two (possibly) different index sets to correctly handle inhomogeneities when the local matrix is computed from a combination of two neighboring elements, for example for an edge integral term in DG. Note that in the case that these two elements have different polynomial degree, the local matrix is rectangular.</p>
<p><code>local_dof_indices_row</code> is the set of row indices and <code>local_dof_indices_col</code> is the set of column indices of the local matrix. <code>diagonal=false</code> says whether the two index sets are equal or not.</p>
<p>If both index sets are equal, <code>diagonal</code> must be set to true or we simply use the previous function. If both index sets are different (diagonal=false) the <code>global_vector</code> is modified to handle inhomogeneities but no entries from <code>local_vector</code> are added. Note that the edge integrals for inner edged for DG do not contribute any values to the right hand side. </p>

</div>
</div>
<a id="a326bcda2e260428ea4f2ba3a2255a692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326bcda2e260428ea4f2ba3a2255a692">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enter a single value into a result vector, obeying constraints. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01628">1628</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a4cd03cdb082dc5a5d8bb647ee9d6752f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd03cdb082dc5a5d8bb647ee9d6752f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a pointer to a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. Note that this function completely ignores inhomogeneous constraints.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01651">1651</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="adbf1401a8b7f9510ab5230a31f1b8a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf1401a8b7f9510ab5230a31f1b8a40">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a matrix of local contributions (<code>local_matrix</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global matrix. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_matrix</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_matrix</code> into <code>global_matrix</code>, the element is distributed to the entries in the global matrix to which this particular degree of freedom is constrained.</p>
<p>With this scheme, we never write into rows or columns of constrained degrees of freedom. In order to make sure that the resulting matrix can still be inverted, we need to do something with the diagonal elements corresponding to constrained nodes. Thus, if a degree of freedom in <code>local_dof_indices</code> is constrained, we distribute the corresponding entries in the matrix, but also add the absolute value of the diagonal entry of the local matrix to the corresponding entry in the global matrix. Assuming the discretized operator is positive definite, this guarantees that the diagonal entry is always non-zero, positive, and of the same order of magnitude as the other entries of the matrix. On the other hand, when solving a source problem <img class="formulaInl" alt="$Au=f$" src="form_1004.png"/> the exact value of the diagonal element is not important, since the value of the respective degree of freedom will be overwritten by the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute()</a> call later on anyway.</p>
<dl class="section note"><dt>Note</dt><dd>The procedure described above adds an unforeseeable number of artificial eigenvalues to the spectrum of the matrix. Therefore, it is recommended to use the equivalent function with two local index vectors in such a case.</dd></dl>
<p>By using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01806">1806</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a5c71cc4387e90b6133d3e78070f43839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c71cc4387e90b6133d3e78070f43839">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does almost the same as the function above but can treat general rectangular matrices. The main difference to achieve this is that the diagonal entries in constrained rows are left untouched instead of being filled with arbitrary values.</p>
<p>Since the diagonal entries corresponding to eliminated degrees of freedom are not set, the result may have a zero eigenvalue, if applied to a square matrix. This has to be considered when solving the resulting problems. For solving a source problem <img class="formulaInl" alt="$Au=f$" src="form_1004.png"/>, it is possible to set the diagonal entry after building the matrix by a piece of code of the form</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;matrix.m();++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.is_constrained(i))</div><div class="line">    matrix.diag_element(i) = 1.;</div></div><!-- fragment --><p>The value of one which is used here is arbitrary, but in the context of Krylov space methods uncritical, since it corresponds to an invariant subspace. If the other matrix entries are smaller or larger by a factor close to machine accuracy, it may be advisable to adjust it.</p>
<p>For solving eigenvalue problems, this will only add one spurious zero eigenvalue (with a multiplicity that is possibly greater than one). Taking this into account, nothing else has to be changed. </p>

</div>
</div>
<a id="a82b2367cb12d4ff1adc080606619f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b2367cb12d4ff1adc080606619f568">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function simultaneously writes elements into matrix and vector, according to the constraints specified by the calling <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. This function can correctly handle inhomogeneous constraints as well. For the parameter use_inhomogeneities_for_rhs see the documentation in <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix and vector allow for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01825">1825</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="ac42f9aba996e2528dc152497eac08dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42f9aba996e2528dc152497eac08dd8">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classConstraintMatrix.html#aa67af6d18d297f65d6b56f99ae7a9285">default_empty_table</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do a similar operation as the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global()</a> function that distributes writing entries into a matrix for constrained degrees of freedom, except that here we don't write into a matrix but only allocate sparsity pattern entries.</p>
<p>As explained in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a> and in <a class="el" href="step_27.html">step-27</a>, first allocating a sparsity pattern and later coming back and allocating additional entries for those matrix entries that will be written to due to the elimination of constrained degrees of freedom (using <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> ), can be a very expensive procedure. It is cheaper to allocate these entries right away without having to do a second pass over the sparsity pattern object. This function does exactly that.</p>
<p>Because the function only allocates entries in a sparsity pattern, all it needs to know are the degrees of freedom that couple to each other. Unlike the previous function, no actual values are written, so the second input argument is not necessary here.</p>
<p>The third argument to this function, keep_constrained_entries determines whether the function shall allocate entries in the sparsity pattern at all for entries that will later be set to zero upon condensation of the matrix. These entries are necessary if the matrix is built unconstrained, and only later condensed. They are not necessary if the matrix is built using the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global()</a> function of this class which distributes entries right away when copying a local matrix into a global object. The default of this argument is true, meaning to allocate the few entries that may later be set to zero.</p>
<p>By default, the function adds entries for all pairs of indices given in the first argument to the sparsity pattern (unless keep_constrained_entries is false). However, sometimes one would like to only add a subset of all of these pairs. In that case, the last argument can be used which specifies a boolean mask which of the pairs of indices should be considered. If the mask is false for a pair of indices, then no entry will be added to the sparsity pattern for this pair, irrespective of whether one or both of the indices correspond to constrained degrees of freedom.</p>
<p>This function is not typically called from user code, but is used in the <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern()</a> function when passed a constraint matrix object.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global sparsity pattern allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01846">1846</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="aa9a06681a4539f12bd68e7d289703803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a06681a4539f12bd68e7d289703803">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classConstraintMatrix.html#aa67af6d18d297f65d6b56f99ae7a9285">default_empty_table</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the other function, but for non-quadratic sparsity patterns. </p>

</div>
</div>
<a id="a08d6d6eddec96cbf89bbcd036d7bdad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d6d6eddec96cbf89bbcd036d7bdad9">&#9670;&nbsp;</a></span>get_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function imports values from a global vector (<code>global_vector</code>) by applying the constraints to a vector of local values, expressed in iterator format. In most cases, the local values will be identified by the local dof values on a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>global_vector</code> into <code>local_vector</code>, the constraints are resolved as the respective distribute function does, i.e., the local entry is constructed from the global entries to which this particular degree of freedom is constrained.</p>
<p>In contrast to the similar function get_dof_values in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function does not need the constrained values to be correctly set (i.e., distribute to be called). </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01696">1696</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a5bd4b10531ae0809a415d91742d1870c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd4b10531ae0809a415d91742d1870c">&#9670;&nbsp;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector, set all constrained degrees of freedom to values so that the constraints are satisfied. For example, if the current object stores the constraint <img class="formulaInl" alt="$x_3=\frac 12 x_1 + \frac 12 x_2$" src="form_1005.png"/>, then this function will read the values of <img class="formulaInl" alt="$x_1$" src="form_1006.png"/> and <img class="formulaInl" alt="$x_1$" src="form_1006.png"/> from the given vector and set the element <img class="formulaInl" alt="$x_3$" src="form_31.png"/> according to this constraints. Similarly, if the current object stores the constraint <img class="formulaInl" alt="$x_{42}=208$" src="form_1007.png"/>, then this function will set the 42nd element of the given vector to 208.</p>
<dl class="section note"><dt>Note</dt><dd>If this function is called with a parallel vector <code>vec</code>, then the vector must not contain ghost elements. </dd></dl>

</div>
</div>
<a id="a0cac0047ea6195b97e2153b295df6c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac0047ea6195b97e2153b295df6c27">&#9670;&nbsp;</a></span>calculate_line_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> ConstraintMatrix::calculate_line_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function to calculate the index of line <code>line</code> in the vector lines_cache using local_lines. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01595">1595</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="aadfab7e5ddcde341e5843d99abd77149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfab7e5ddcde341e5843d99abd77149">&#9670;&nbsp;</a></span>check_zero_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::check_zero_weight </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the weight of an entry (the second element of the pair) equals zero. This function is used to delete entries with zero weight. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8cc_source.html#l00059">59</a> of file <a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a>.</p>

</div>
</div>
<a id="a69df832a2a5319c89931eee55914e856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69df832a2a5319c89931eee55914e856">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) matrices. </p>

</div>
</div>
<a id="aa79a59dfeb5b4080a5b88164707c5a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79a59dfeb5b4080a5b88164707c5a5a">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; typename MatrixType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block matrices. </p>

</div>
</div>
<a id="a81d4bdda031092cf1e865bf1a90e3b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d4bdda031092cf1e865bf1a90e3b6b">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) sparsity types. </p>

</div>
</div>
<a id="a7c876b33b45b88768b435cb3dd0d93a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c876b33b45b88768b435cb3dd0d93a3">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1bool2type.html">internal::bool2type</a>&lt; true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block sparsity types. </p>

</div>
</div>
<a id="ab01aad750025aa4263f0620649dda06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01aad750025aa4263f0620649dda06c">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internals::GlobalRowsFromLocal &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function.</p>
<p>Creates a list of affected global rows for distribution, including the local rows where the entries come from. The list is sorted according to the global row indices. </p>

</div>
</div>
<a id="ac2c750b2a837a13ec360113b101b117d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c750b2a837a13ec360113b101b117d">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstraintMatrix::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for add_entries_local_to_global function.</p>
<p>Creates a list of affected rows for distribution without any additional information, otherwise similar to the other <a class="el" href="classConstraintMatrix.html#ab01aad750025aa4263f0620649dda06c">make_sorted_row_list()</a> function. </p>

</div>
</div>
<a id="a2910e8107287dc297b58cf601597d59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2910e8107287dc297b58cf601597d59a">&#9670;&nbsp;</a></span>resolve_vector_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LocalType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LocalType ConstraintMatrix::resolve_vector_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internals::GlobalRowsFromLocal &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; LocalType &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function. </p>

</div>
</div>
<a id="a5c40831563ee3d4362b932d713ae0b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c40831563ee3d4362b932d713ae0b08">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>&amp; ConstraintMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The assignment operator is not implemented for performance reasons. You can <a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear()</a> or <a class="el" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit()</a> and <a class="el" href="classConstraintMatrix.html#aa471ba15f320b700280ab5e5ac59d88b">merge()</a> manually if needed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0f3b653958a9f500be62c61791e42dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3b653958a9f500be62c61791e42dd0">&#9670;&nbsp;</a></span>lines</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a>&gt; ConstraintMatrix::lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the lines of the matrix. Entries are usually appended in an arbitrary order and insertion into a vector is done best at the end, so the order is unspecified after all entries are inserted. Sorting of the entries takes place when calling the <code><a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close()</a></code> function.</p>
<p>We could, instead of using a vector, use an associative array, like a map to store the lines. This, however, would mean a much more fragmented heap since it allocates many small objects, and would additionally make usage of this matrix much slower. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01242">1242</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a25db0740488705b778ab6eedeec9c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25db0740488705b778ab6eedeec9c1fb">&#9670;&nbsp;</a></span>lines_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classConstraintMatrix.html#a71b13eb29cd43c9e87abebf2bf78b2a3">size_type</a>&gt; ConstraintMatrix::lines_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of size_type that contains the position of the <a class="el" href="structConstraintMatrix_1_1ConstraintLine.html">ConstraintLine</a> of a constrained degree of freedom, or <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> if the degree of freedom is not constrained. The <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> return value returns thus whether there is a constraint line for a given degree of freedom index. Note that this class has no notion of how many degrees of freedom there really are, so if we check whether there is a constraint line for a given degree of freedom, then this vector may actually be shorter than the index of the DoF we check for.</p>
<p>This field exists since when adding a new constraint line we have to figure out whether it already exists. Previously, we would simply walk the unsorted list of constraint lines until we either hit the end or found it. This algorithm is O(N) if N is the number of constraints, which makes it O(N^2) when inserting all constraints. For large problems with many constraints, this could easily take 5-10 per cent of the total run time. With this field, we can save this time since we find any constraint in O(1) time or get to know that it a certain degree of freedom is not constrained.</p>
<p>To make things worse, traversing the list of existing constraints requires reads from many different places in memory. Thus, in large 3d applications, the <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line()</a> function showed up very prominently in the overall compute time, mainly because it generated a lot of cache misses. This should also be fixed by using the O(1) algorithm to access the fields of this array.</p>
<p>The field is useful in a number of other contexts as well, e.g. when one needs random access to the constraints as in all the functions that apply constraints on the fly while add cell contributions into vectors and matrices. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01276">1276</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="a58dd31bd6fceeb6b67fe54017e0750b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dd31bd6fceeb6b67fe54017e0750b5">&#9670;&nbsp;</a></span>local_lines</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> ConstraintMatrix::local_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This <a class="el" href="classIndexSet.html">IndexSet</a> is used to limit the lines to save in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to a subset. This is necessary, because the lines_cache vector would become too big in a distributed calculation. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01283">1283</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="ada29d922494c2b645e418cc311ec872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada29d922494c2b645e418cc311ec872d">&#9670;&nbsp;</a></span>sorted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConstraintMatrix::sorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the arrays are sorted. If so, no new entries can be added. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01288">1288</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<a id="aa67af6d18d297f65d6b56f99ae7a9285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67af6d18d297f65d6b56f99ae7a9285">&#9670;&nbsp;</a></span>default_empty_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt; ConstraintMatrix::default_empty_table = <a class="el" href="classTable.html">Table</a>&lt;2,bool&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dummy table that serves as default argument for function <code><a class="el" href="classConstraintMatrix.html#ac42f9aba996e2528dc152497eac08dd8">add_entries_local_to_global()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="constraint__matrix_8h_source.html#l01306">1306</a> of file <a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/lac/<a class="el" href="constraint__matrix_8h_source.html">constraint_matrix.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/lac/<a class="el" href="constraint__matrix_8cc_source.html">constraint_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
