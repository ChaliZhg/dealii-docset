<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The &#39;Goal-oriented mesh adaptivity in elastoplasticity problems&#39; code gallery program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The 'Goal-oriented mesh adaptivity in elastoplasticity problems' code gallery program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<p align="center"> 
  This program was contributed by Seyed Shahram Ghorashi &lt;s.sh.ghorashi@gmail.com&gt;.
  <br>
  It comes without any warranty or support by its authors or the authors of deal.II.
</p>

</p>
<p>This program is part of the <a class="el" href="CodeGallery.html">deal.II code gallery</a> and consists of the following files (click to inspect):</p><ul>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/readme.md">readme.md</a> (<a href="#ann-readme.md">annotated version</a>)</li>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/CMakeLists.txt">CMakeLists.txt</a></li>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/Cantiliver_II_beam_3d.prm">Cantiliver_II_beam_3d.prm</a></li>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/Thick_tube_internal_pressure.prm">Thick_tube_internal_pressure.prm</a></li>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/doc/entry-name">doc/entry-name</a></li>
<li><a href="../code-gallery/goal_oriented_elastoplasticity/elastoplastic.cc">elastoplastic.cc</a> (<a href="#ann-elastoplastic.cc">annotated version</a>)</li>
</ul>
<p><a class="anchor" id="ann-readme.md"></a> </p><h1>Annotated version of readme.md</h1>
<h3>3d goal-oriented mesh adaptivity in elastoplasticity problems</h3>
<p>The code deals with solving an elastoplasticity problem with linear isotropic hardening. At each load/displacement step, the error based on a prescribed quantity of interest (Goal-oriented error estimation) is computed by using the dual-weighted residual method.</p>
<p>Based on a prescribed error bound and estimated elementwise errors, the mesh is then refined/coarsened. Afterwards, the solution is projected to the new mesh and the analysis process is repeated.</p>
<p>The applied methodology and the solved numerical examples can be found in the following paper:</p>
<blockquote class="doxtable">
<p>Ghorashi SSh, Rabczuk T.: "Goal-Oriented Error Estimation and Mesh
 Adaptivity in 3d Elastoplasticity Problems". International Journal of Fracture. Accepted. 2016. </p>
</blockquote>
<p><a class="anchor" id="ann-elastoplastic.cc"></a> </p><h1>Annotated version of elastoplastic.cc</h1>
<div class="fragment"><div class="line">/ * ---------------------------------------------------------------------</div><div class="line"> * Id: elastoplastic.cc 31592 2013-11-08 16:47:28Z Ghorashi </div><div class="line"> *</div><div class="line"> * Copyright (C) 2012 - 2013 by the deal.II authors</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE at</div><div class="line"> * the top level of the deal.II distribution.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"></div><div class="line"> *</div><div class="line"> * Authors: Seyed Shahram Ghorashi, Bauhaus-Universit\<span class="stringliteral">&quot;at Weimar, 2014</span></div><div class="line"><span class="stringliteral"> *          Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="stringliteral"> *                        University of Siegen, 2012, 2013</span></div><div class="line"><span class="stringliteral"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012, 2013</span></div><div class="line"><span class="stringliteral"> *          Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="stringliteral"> * /</span></div></div><!-- fragment --><p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The set of include files is not much of a surprise any more at this time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/table_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_bicgstab.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/fe_field_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div></div><!-- fragment --><p>And here the only two new things among the header files: an include file in which symmetric tensors of rank 2 and 4 are implemented, as introduced in the introduction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div></div><!-- fragment --><p>And a header that implements filters for iterators looping over all cells. We will use this when selecting only those cells for output that are owned by the present process in a parallel program:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/filtered_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>This final include file provides the <code>mkdir</code> function that we will use to create a directory for output files, if necessary:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ElastoPlastic</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">extrude_triangulation</a>(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;2, 2&gt;</a> &amp;input,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_slices,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> height,</div><div class="line">                        <a class="code" href="classTriangulation.html">Triangulation&lt;3,3&gt;</a> &amp;result)</div><div class="line">  {</div></div><!-- fragment --><p>Assert (input.n_levels() == 1, ExcMessage ("The input triangulations must be coarse meshes."));</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(result.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()==0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;resultin Triangulation need to be empty upon calling extrude_triangulation.&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(height&gt;0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The height in extrude_triangulation needs to be positive.&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(n_slices&gt;=2, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The number of slices in extrude_triangulation needs to be at least 2.&quot;</span>));</div><div class="line"></div><div class="line">  std::vector&lt;Point&lt;3&gt; &gt; points(n_slices*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>());</div><div class="line">  std::vector&lt;CellData&lt;3&gt; &gt; cells;</div><div class="line">  cells.reserve((n_slices-1)*input.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> slice=0; slice&lt;n_slices; ++slice)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;input.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(); ++i)</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (input.<a class="code" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">get_used_vertices</a>()[i])</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = input.<a class="code" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a>()[i];</div><div class="line">              points[i+slice*input.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>()](0) = v(0);</div><div class="line">              points[i+slice*input.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>()](1) = v(1);</div><div class="line">              points[i+slice*input.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>()](2) = height * slice / (n_slices-1);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classTriaIterator.html">Triangulation&lt;2,2&gt;::cell_iterator</a></div><div class="line">       cell = input.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != input.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> slice=0; slice&lt;n_slices-1; ++slice)</div><div class="line">        {</div><div class="line">          <a class="code" href="structCellData.html">CellData&lt;3&gt;</a> this_cell;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;2&gt;::vertices_per_cell; ++v)</div><div class="line">            {</div><div class="line">              this_cell.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[v]</div><div class="line">                = cell-&gt;vertex_index(v)+slice*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">              this_cell.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[v+<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>]</div><div class="line">                = cell-&gt;vertex_index(v)+(slice+1)*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">            }</div><div class="line"></div><div class="line">          this_cell.<a class="code" href="structCellData.html#a7d4a093cec27f2f8c947dd97d3aab290">material_id</a> = cell-&gt;material_id();</div><div class="line">          cells.push_back(this_cell);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="structSubCellData.html">SubCellData</a> s;</div><div class="line">  <a class="code" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> bid=0;</div><div class="line">  s.<a class="code" href="structSubCellData.html#a42d039fbffe90b474b2d2513240b1998">boundary_quads</a>.reserve(input.<a class="code" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a>()*(n_slices-1) + input.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()*2);</div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classTriaIterator.html">Triangulation&lt;2,2&gt;::cell_iterator</a></div><div class="line">       cell = input.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != input.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="structCellData.html">CellData&lt;2&gt;</a> quad;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;4; ++f)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;at_boundary(f))</div><div class="line">          {</div><div class="line">            quad.<a class="code" href="structCellData.html#ab033fb6035771191211992eaa17d3640">boundary_id</a> = cell-&gt;face(f)-&gt;boundary_indicator();</div><div class="line">            bid = std::max(bid, quad.<a class="code" href="structCellData.html#ab033fb6035771191211992eaa17d3640">boundary_id</a>);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> slice=0; slice&lt;n_slices-1; ++slice)</div><div class="line">              {</div><div class="line">                quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[0] = cell-&gt;face(f)-&gt;vertex_index(0)+slice*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">                quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[1] = cell-&gt;face(f)-&gt;vertex_index(1)+slice*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">                quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[2] = cell-&gt;face(f)-&gt;vertex_index(0)+(slice+1)*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">                quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[3] = cell-&gt;face(f)-&gt;vertex_index(1)+(slice+1)*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">                s.<a class="code" href="structSubCellData.html#a42d039fbffe90b474b2d2513240b1998">boundary_quads</a>.push_back(quad);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classTriaIterator.html">Triangulation&lt;2,2&gt;::cell_iterator</a></div><div class="line">       cell = input.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != input.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="structCellData.html">CellData&lt;2&gt;</a> quad;</div><div class="line">      quad.<a class="code" href="structCellData.html#ab033fb6035771191211992eaa17d3640">boundary_id</a> = bid + 1;</div><div class="line">      quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[0] = cell-&gt;vertex_index(0);</div><div class="line">      quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[1] = cell-&gt;vertex_index(1);</div><div class="line">      quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[2] = cell-&gt;vertex_index(2);</div><div class="line">      quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[3] = cell-&gt;vertex_index(3);</div><div class="line">      s.<a class="code" href="structSubCellData.html#a42d039fbffe90b474b2d2513240b1998">boundary_quads</a>.push_back(quad);</div><div class="line"></div><div class="line">      quad.<a class="code" href="structCellData.html#ab033fb6035771191211992eaa17d3640">boundary_id</a> = bid + 2;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;4; ++i)</div><div class="line">        quad.<a class="code" href="structCellData.html#a360ade81c398472433b93854c4a94443">vertices</a>[i] += (n_slices-1)*input.<a class="code" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a>();</div><div class="line">      s.<a class="code" href="structSubCellData.html#a42d039fbffe90b474b2d2513240b1998">boundary_quads</a>.push_back(quad);</div><div class="line">    }</div><div class="line"></div><div class="line">  result.<a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">create_triangulation</a> (points,</div><div class="line">                               cells,</div><div class="line">                               s);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Evaluation</div><div class="line">{</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> get_von_Mises_stress(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;stress)</div><div class="line">  {</div></div><!-- fragment --><p>if (dim == 2) { von_Mises_stress = std::sqrt( stress[0][0]*stress[0][0]</p><ul>
<li>stress[1][1]*stress[1][1]</li>
<li>stress[0][0]*stress[1][1]</li>
<li>3*stress[0][1]*stress[0][1]); }else if (dim == 3) { von_Mises_stress = std::sqrt( stress[0][0]*stress[0][0]</li>
<li>stress[1][1]*stress[1][1]</li>
<li>stress[2][2]*stress[2][2]</li>
<li>stress[0][0]*stress[1][1]</li>
<li>stress[1][1]*stress[2][2]</li>
<li>stress[0][0]*stress[2][2]</li>
<li>3*( stress[0][1]*stress[0][1] +stress[1][2]*stress[1][2] +stress[0][2]*stress[0][2]) ); }</li>
</ul>
<hr/>
<p> "Perforated_strip_tension" plane stress const double von_Mises_stress = std::sqrt( stress[0][0]*stress[0][0]</p><ul>
<li>stress[1][1]*stress[1][1]</li>
<li>stress[0][0]*stress[1][1] <h2>+ 3*stress[0][1]*stress[0][1]); </h2>
</li>
</ul>
<p>otherwise plane strain / 3d case</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> von_Mises_stress = std::sqrt(1.5) * (<a class="code" href="classSymmetricTensor.html#aa1ba0db3d146ea2d13dca05de9a42c74">deviator</a>(stress)).norm();</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">    <span class="keywordflow">return</span> von_Mises_stress;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PointValuesEvaluation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PointValuesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;evaluation_point);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;solution,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>         &amp;point_values);</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a> (ExcEvaluationPointNotFound,</div><div class="line">                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  evaluation_point;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  PointValuesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;evaluation_point)</div><div class="line">    :</div><div class="line">    evaluation_point (evaluation_point)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  compute (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>  &amp;dof_handler,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;solution,</div><div class="line">           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>         &amp;point_values)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_vertex = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a>;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (point_values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dofs_per_vertex,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (point_values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dofs_per_vertex));</div><div class="line">    point_values = 1e20;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">for</span> (; (cell!=endc) &amp;&amp; !evaluation_point_found; ++cell)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned() &amp;&amp; !evaluation_point_found)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex=0;</div><div class="line">               vertex&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell;</div><div class="line">               ++vertex)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (cell-&gt;vertex(vertex).distance (evaluation_point)</div><div class="line">                  &lt;</div><div class="line">                  cell-&gt;diameter() * 1e-8)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dofs_per_vertex; ++id)</div><div class="line">                    {</div><div class="line">                      point_values[id] = solution(cell-&gt;vertex_dof_index(vertex,<span class="keywordtype">id</span>));</div><div class="line">                    }</div><div class="line"></div><div class="line">                  evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (evaluation_point_found,</div><div class="line">                 ExcEvaluationPointNotFound(evaluation_point));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePointHistorycodeclass"></a> </p><h3>The <code>PointHistory</code> class</h3>
<p>As was mentioned in the introduction, we have to store the old stress in quadrature point so that we can compute the residual forces at this point during the next time step. This alone would not warrant a structure with only one member, but in more complicated applications, we would have to store more information in quadrature points as well, such as the history variables of plasticity, etc. In essence, we have to store everything that affects the present state of the material here, which in plasticity is determined by the deformation history variables.</p>
<p>We will not give this class any meaningful functionality beyond being able to store data, i.e. there are no constructors, destructors, or other member functions. In such cases of `dumb' classes, we usually opt to declare them as <code>struct</code> rather than <code>class</code>, to indicate that they are closer to C-style structures than C++-style classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>PointHistory</div><div class="line">{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> old_stress;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> old_strain;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeConstitutiveLawcodeclasstemplate"></a> </p><h3>The <code>ConstitutiveLaw</code> class template</h3>
<p>This class provides an interface for a constitutive law, i.e., for the relationship between strain <img class="formulaInl" alt="$\varepsilon(\mathbf u)$" src="form_2807.png"/> and stress <img class="formulaInl" alt="$\sigma$" src="form_456.png"/>. In this example we are using an elastoplastic material behavior with linear, isotropic hardening. Such materials are characterized by Young's modulus <img class="formulaInl" alt="$E$" src="form_1205.png"/>, Poisson's ratio <img class="formulaInl" alt="$\nu$" src="form_1655.png"/>, the initial yield stress <img class="formulaInl" alt="$\sigma_0$" src="form_3424.png"/> and the isotropic hardening parameter <img class="formulaInl" alt="$\gamma$" src="form_932.png"/>. For <img class="formulaInl" alt="$\gamma = 0$" src="form_3425.png"/> we obtain perfect elastoplastic behavior.</p>
<p>As explained in the paper that describes this program, the first Newton steps are solved with a completely elastic material model to avoid having to deal with both nonlinearities (plasticity and contact) at once. To this end, this class has a function <code>set_sigma_0()</code> that we use later on to simply set <img class="formulaInl" alt="$\sigma_0$" src="form_3424.png"/> to a very large value &ndash; essentially guaranteeing that the actual stress will not exceed it, and thereby producing an elastic material. When we are ready to use a plastic model, we set <img class="formulaInl" alt="$\sigma_0$" src="form_3424.png"/> back to its proper value, using the same function. As a result of this approach, we need to leave <code>sigma_0</code> as the only non-const member variable of this class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConstitutiveLaw</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveLaw (<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  set_sigma_0 (<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">  get_stress_strain_tensor (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">  get_grad_stress_strain_tensor (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                                 <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &gt; &amp;point_hessian,</div><div class="line">                                 <a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> &amp;stress_strain_tensor_grad) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  get_linearized_stress_strain_tensors (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                                        <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor_linearized,</div><div class="line">                                        <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  <span class="keywordtype">double</span>       sigma_0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the ConstitutiveLaw class sets the required material parameter for our deformable body. Material parameters for elastic isotropic media can be defined in a variety of ways, such as the pair <img class="formulaInl" alt="$E, \nu$" src="form_3426.png"/> (elastic modulus and Poisson's number), using the Lame parameters <img class="formulaInl" alt="$\lambda,mu$" src="form_3427.png"/> or several other commonly used conventions. Here, the constructor takes a description of material parameters in the form of <img class="formulaInl" alt="$E,\nu$" src="form_3428.png"/>, but since this turns out to these are not the coefficients that appear in the equations of the plastic projector, we immediately convert them into the more suitable set <img class="formulaInl" alt="$\kappa,\mu$" src="form_3429.png"/> of bulk and shear moduli. In addition, the constructor takes <img class="formulaInl" alt="$\sigma_0$" src="form_3424.png"/> (the yield stress absent any plastic strain) and <img class="formulaInl" alt="$\gamma$" src="form_932.png"/> (the hardening parameter) as arguments. In this constructor, we also compute the two principal components of the stress-strain relation and its linearization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw (<span class="keywordtype">double</span> E,</div><div class="line">                                       <span class="keywordtype">double</span> nu,</div><div class="line">                                       <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                       <span class="keywordtype">double</span> gamma)</div><div class="line">  :</div></div><!-- fragment --> <hr/>
<p> Plane stress kappa (((E*(1+2*nu)) / (std::pow((1+nu),2))) / (3 * (1 - 2 * (nu / (1+nu))))), </p><h2>mu (((E*(1+2*nu)) / (std::pow((1+nu),2))) / (2 * (1 + (nu / (1+nu))))), </h2>
<p>3d and plane strain</p>
<div class="fragment"><div class="line">kappa (E / (3 * (1 - 2 * nu))),</div><div class="line">mu (E / (2 * (1 + nu))),</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">  sigma_0(sigma_0),</div><div class="line">  gamma(gamma),</div><div class="line">  stress_strain_tensor_kappa (kappa</div><div class="line">                              * <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(unit_symmetric_tensor&lt;dim&gt;(),</div><div class="line">                                              unit_symmetric_tensor&lt;dim&gt;())),</div><div class="line">  stress_strain_tensor_mu (2 * mu</div><div class="line">                           * (identity_tensor&lt;dim&gt;()</div><div class="line">                              - <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(unit_symmetric_tensor&lt;dim&gt;(),</div><div class="line">                                              unit_symmetric_tensor&lt;dim&gt;()) / 3.0))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ConstitutiveLaw&lt;dim&gt;::set_sigma_0 (<span class="keywordtype">double</span> sigma_zero)</div><div class="line">{</div><div class="line">  sigma_0 = sigma_zero;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_stress_strain_tensor"></a> </p><h4>ConstitutiveLaw::get_stress_strain_tensor</h4>
<p>This is the principal component of the constitutive law. It projects the deviatoric part of the stresses in a quadrature point back to the yield stress (i.e., the original yield stress <img class="formulaInl" alt="$\sigma_0$" src="form_3424.png"/> plus the term that describes linear isotropic hardening). We need this function to calculate the nonlinear residual in PlasticityContactProblem::residual_nl_system. The computations follow the formulas laid out in the introduction.</p>
<p>The function returns whether the quadrature point is plastic to allow for some statistics downstream on how many of the quadrature points are plastic and how many are elastic.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">ConstitutiveLaw&lt;dim&gt;::</div><div class="line">get_stress_strain_tensor (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor = (stress_strain_tensor_kappa + stress_strain_tensor_mu)</div><div class="line">                  * strain_tensor;</div></div><!-- fragment --><p>const <a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = deviator(stress_tensor); const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> von_Mises_stress = Evaluation::get_von_Mises_stress(stress_tensor);</div><div class="line"></div><div class="line">  stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">  <span class="keywordflow">if</span> (von_Mises_stress &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / von_Mises_stress;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - gamma) * beta);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (von_Mises_stress &gt; sigma_0);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">ConstitutiveLaw&lt;dim&gt;::</div><div class="line">get_grad_stress_strain_tensor (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                               <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &gt; &amp;point_hessian,</div><div class="line">                               <a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> &amp;stress_strain_tensor_grad)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor = (stress_strain_tensor_kappa + stress_strain_tensor_mu)</div><div class="line">                  * strain_tensor;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="classSymmetricTensor.html#aa1ba0db3d146ea2d13dca05de9a42c74">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#af1b76a3827ddec8956e44eccccb9d7df">norm</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> von_Mises_stress = Evaluation::get_von_Mises_stress(stress_tensor);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (von_Mises_stress &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_strain_tensor = <a class="code" href="classSymmetricTensor.html#aa1ba0db3d146ea2d13dca05de9a42c74">deviator</a>(strain_tensor);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_strain_tensor_norm = deviator_strain_tensor.<a class="code" href="classSymmetricTensor.html#af1b76a3827ddec8956e44eccccb9d7df">norm</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> multiplier = -(1-gamma)*sigma_0/(2*mu*std::pow(deviator_strain_tensor_norm,3));</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> multiplier_vector(dim);</div><div class="line">      multiplier_vector = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m!=dim; ++m)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n!=dim; ++n)</div><div class="line">            {</div><div class="line">              multiplier_vector(i) += deviator_strain_tensor[m][n] *</div><div class="line">                                      ( 0.5*( point_hessian[m][n][i] + point_hessian[n][m][i] )</div><div class="line">                                        + ( m==n &amp;&amp; dim==2 ? -1/dim*(point_hessian[0][0][i]</div><div class="line">                                                                     + point_hessian[1][1][i]) : 0 )</div><div class="line">                                        + ( m==n &amp;&amp; dim==3 ? -1/dim*(point_hessian[0][0][i]</div><div class="line">                                                                     + point_hessian[1][1][i]</div><div class="line">                                                                     + point_hessian[2][2][i]) : 0 ) );</div><div class="line">            }</div></div><!-- fragment --> <hr/>
<p> "Perforated_strip_tension" plane stress </p><h2>const double VM_factor = std::sqrt(2); </h2>
<p>otherwise plane strain / 3d case</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> VM_factor = std::sqrt(1.5);</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m!=dim; ++m)</div><div class="line">                {</div><div class="line">                  stress_strain_tensor_grad[i][j][k][l][m] = 1/VM_factor</div><div class="line">                                                             * multiplier</div><div class="line">                                                             * stress_strain_tensor_mu[i][j][k][l]</div><div class="line">                                                             * multiplier_vector(m);</div><div class="line">                }</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      stress_strain_tensor_grad = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (von_Mises_stress &gt; sigma_0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_linearized_stress_strain_tensors"></a> </p><h4>ConstitutiveLaw::get_linearized_stress_strain_tensors</h4>
<p>This function returns the linearized stress strain tensor, linearized around the solution <img class="formulaInl" alt="$u^{i-1}$" src="form_3432.png"/> of the previous Newton step <img class="formulaInl" alt="$i-1$" src="form_3433.png"/>. The parameter <code>strain_tensor</code> (commonly denoted <img class="formulaInl" alt="$\varepsilon(u^{i-1})$" src="form_3434.png"/>) must be passed as an argument, and serves as the linearization point. The function returns the derivative of the nonlinear constitutive law in the variable stress_strain_tensor, as well as the stress-strain tensor of the linearized problem in stress_strain_tensor_linearized. See PlasticityContactProblem::assemble_nl_system where this function is used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ConstitutiveLaw&lt;dim&gt;::</div><div class="line">get_linearized_stress_strain_tensors (<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">                                      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor_linearized,</div><div class="line">                                      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor = (stress_strain_tensor_kappa + stress_strain_tensor_mu)</div><div class="line">                  * strain_tensor;</div><div class="line"></div><div class="line">  stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">  stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="classSymmetricTensor.html#aa1ba0db3d146ea2d13dca05de9a42c74">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#af1b76a3827ddec8956e44eccccb9d7df">norm</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> von_Mises_stress = Evaluation::get_von_Mises_stress(stress_tensor);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (von_Mises_stress &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / von_Mises_stress;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - gamma) * beta);</div><div class="line">      stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta);</div><div class="line">      deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor_linearized -= (1 - gamma) * beta * 2 * mu</div><div class="line">                                         * <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(deviator_stress_tensor,</div><div class="line">                                                         deviator_stress_tensor);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">  stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">}</div></div><!-- fragment --><p>Finally, below we will need a function that computes the rotation matrix induced by a displacement at a given point. In fact, of course, the displacement at a single point only has a direction and a magnitude, it is the change in direction and magnitude that induces rotations. In effect, the rotation matrix can be computed from the gradients of a displacement, or, more specifically, from the curl.</p>
<p>The formulas by which the rotation matrices are determined are a little awkward, especially in 3d. For 2d, there is a simpler way, so we implement this function twice, once for 2d and once for 3d, so that we can compile and use the program in both space dimensions if so desired &ndash; after all, deal.II is all about dimension independent programming and reuse of algorithm thoroughly tested with cheap computations in 2d, for the more expensive computations in 3d. Here is one case, where we have to implement different algorithms for 2d and 3d, but then can write the rest of the program in a way that is independent of the space dimension.</p>
<p>So, without further ado to the 2d implementation:</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2,2&gt;</a></div><div class="line">get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,2&gt;</a> &gt; &amp;grad_u)</div><div class="line">{</div></div><!-- fragment --><p>First, compute the curl of the velocity field from the gradients. Note that we are in 2d, so the rotation is a scalar:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> curl = (grad_u[1][0] - grad_u[0][1]);</div></div><!-- fragment --><p>From this, compute the angle of rotation:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (curl);</div></div><!-- fragment --><p>And from this, build the antisymmetric rotation matrix:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> t[2][2] = {{ <a class="code" href="classVectorizedArray.html#afbe6a626041041e9d34cbf408a796db6">cos</a>(angle), <a class="code" href="classVectorizedArray.html#aad2709071b1b9d36bab0c81938355b87">sin</a>(angle) },</div><div class="line">    {-<a class="code" href="classVectorizedArray.html#aad2709071b1b9d36bab0c81938355b87">sin</a>(angle), <a class="code" href="classVectorizedArray.html#afbe6a626041041e9d34cbf408a796db6">cos</a>(angle) }</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;2,2&gt;</a>(t);</div><div class="line">}</div></div><!-- fragment --><p>The 3d case is a little more contrived:</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a></div><div class="line">get_rotation_matrix (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,3&gt;</a> &gt; &amp;grad_u)</div><div class="line">{</div></div><!-- fragment --><p>Again first compute the curl of the velocity field. This time, it is a real vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> curl (grad_u[2][1] - grad_u[1][2],</div><div class="line">                     grad_u[0][2] - grad_u[2][0],</div><div class="line">                     grad_u[1][0] - grad_u[0][1]);</div></div><!-- fragment --><p>From this vector, using its magnitude, compute the tangent of the angle of rotation, and from it the actual angle:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tan_angle = std::sqrt(curl*curl);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan (tan_angle);</div></div><!-- fragment --><p>Now, here's one problem: if the angle of rotation is too small, that means that there is no rotation going on (for example a translational motion). In that case, the rotation matrix is the identity matrix.</p>
<p>The reason why we stress that is that in this case we have that <code>tan_angle==0</code>. Further down, we need to divide by that number in the computation of the axis of rotation, and we would get into trouble when dividing doing so. Therefore, let's shortcut this and simply return the identity matrix if the angle of rotation is really small:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (angle &lt; 1e-9)</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> rotation[3][3]</div><div class="line">    = {{ 1, 0, 0}, { 0, 1, 0 }, { 0, 0, 1 } };</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a> rot(rotation);</div><div class="line">    <span class="keywordflow">return</span> rot;</div><div class="line">  }</div></div><!-- fragment --><p>Otherwise compute the real rotation matrix. The algorithm for this is not exactly obvious, but can be found in a number of books, particularly on computer games where rotation is a very frequent operation. Online, you can find a description at <a href="http://www.makegames.com/3drotation/">http://www.makegames.com/3drotation/</a> and (this particular form, with the signs as here) at <a href="http://www.gamedev.net/reference/articles/article1199.asp:">http://www.gamedev.net/reference/articles/article1199.asp:</a></p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c = std::cos(angle);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> s = std::sin(angle);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> t = 1-c;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> axis = curl/tan_angle;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rotation[3][3]</div><div class="line">  = {{</div><div class="line">      t *axis[0] *axis[0]+c,</div><div class="line">      t *axis[0] *axis[1]+s *axis[2],</div><div class="line">      t *axis[0] *axis[2]-s *axis[1]</div><div class="line">    },</div><div class="line">    {</div><div class="line">      t *axis[0] *axis[1]-s *axis[2],</div><div class="line">      t *axis[1] *axis[1]+c,</div><div class="line">      t *axis[1] *axis[2]+s *axis[0]</div><div class="line">    },</div><div class="line">    {</div><div class="line">      t *axis[0] *axis[2]+s *axis[1],</div><div class="line">      t *axis[1] *axis[1]-s *axis[0],</div><div class="line">      t *axis[2] *axis[2]+c</div><div class="line">    }</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;2,3&gt;</a>(rotation);</div><div class="line">}</div></div><!-- fragment --><h3>Equation data: Body forces, boundary forces, incremental boundary values</h3>
<p>The following should be relatively standard. We need classes for the boundary forcing term (which we here choose to be zero) and incremental boundary values.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line"></div><div class="line">  / *</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryForce ();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryForce&lt;dim&gt;::BoundaryForce ()</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  BoundaryForce&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoundaryForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      values(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBodyForcecodeclass"></a> </p><h3>The <code>BodyForce</code> class</h3>
<p>Body forces are generally mediated by one of the four basic physical types of forces: gravity, strong and weak interaction, and electromagnetism. Unless one wants to consider subatomic objects (for which quasistatic deformation is irrelevant and an inappropriate description anyway), only gravity and electromagnetic forces need to be considered. Let us, for simplicity assume that our body has a certain mass density, but is either non-magnetic and not electrically conducting or that there are no significant electromagnetic fields around. In that case, the body forces are simply <code>rho g</code>, where <code>rho</code> is the material density and <code>g</code> is a vector in negative z-direction with magnitude 9.81 m/s^2. Both the density and <code>g</code> are defined in the function, and we take as the density 7700 kg/m^3, a value commonly assumed for steel.</p>
<p>To be a little more general and to be able to do computations in 2d as well, we realize that the body force is always a function returning a <code>dim</code> dimensional vector. We assume that gravity acts along the negative direction of the last, i.e. <code>dim-1</code>th coordinate. The rest of the implementation of this function should be mostly self-explanatory given similar definitions in previous example programs. Note that the body force is independent of the location; to avoid compiler warnings about unused function arguments, we therefore comment out the name of the first argument of the <code>vector_value</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce ();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BodyForce&lt;dim&gt;::BodyForce ()</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">inline</span></div><div class="line"><span class="keywordtype">void</span></div><div class="line">BodyForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> g   = 9.81;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> rho = 7700;</div><div class="line"></div><div class="line">  values = 0;</div><div class="line">  values(dim-1) = -rho * g;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BodyForce&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    BodyForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">                                  value_list[p]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeIncrementalBoundaryValuecodeclass"></a> </p><h3>The <code>IncrementalBoundaryValue</code> class</h3>
<p>In addition to body forces, movement can be induced by boundary forces and forced boundary displacement. The latter case is equivalent to forces being chosen in such a way that they induce certain displacement.</p>
<p>For quasistatic displacement, typical boundary forces would be pressure on a body, or tangential friction against another body. We chose a somewhat simpler case here: we prescribe a certain movement of (parts of) the boundary, or at least of certain components of the displacement vector. We describe this by another vector-valued function that, for a given point on the boundary, returns the prescribed displacement.</p>
<p>Since we have a time-dependent problem, the displacement increment of the boundary equals the displacement accumulated during the length of the timestep. The class therefore has to know both the present time and the length of the present time step, and can then approximate the incremental displacement as the present velocity times the present timestep.</p>
<p>For the purposes of this program, we choose a simple form of boundary displacement: we displace the top boundary with constant velocity downwards. The rest of the boundary is either going to be fixed (and is then described using an object of type <code><a class="el" href="classZeroFunction.html">ZeroFunction</a></code>) or free (Neumann-type, in which case nothing special has to be done). The implementation of the class describing the constant downward motion should then be obvious using the knowledge we gained through all the previous example programs:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> velocity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> present_timestep)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">velocity (.1),</div><div class="line">present_time (present_time),</div><div class="line">present_timestep (present_timestep)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  values = 0;</div><div class="line">  values(2) = -present_timestep * velocity;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --><p>--------------------------&mdash; TimoshenkoBeam ------------------------------------&mdash;</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">               end_time,</div><div class="line">               shear_force,</div><div class="line">               length,</div><div class="line">               depth,</div><div class="line">               thickness;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim),</div><div class="line">present_time (present_time),</div><div class="line">end_time (end_time),</div><div class="line">shear_force (2e4),</div><div class="line">length (.48),</div><div class="line">depth (.12),</div><div class="line">thickness (.01)</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">      <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>compute traction on the right face of Timoshenko beam problem, t_bar</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> inertia_moment = (thickness*std::pow(depth,3)) / 12;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> x = p(0);</div><div class="line"><span class="keywordtype">double</span> y = p(1);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::fabs(x-length)&lt;1e-12, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">values(0) = 0;</div><div class="line">values(1) = - shear_force/(2*inertia_moment) * ( depth*depth/4-y*y );</div></div><!-- fragment --><p>compute the fraction of imposed force</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = present_time/end_time;</div><div class="line"></div><div class="line">  values *= frac;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce () : <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt; (dim) {}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">               end_time,</div><div class="line">               shear_force,</div><div class="line">               Youngs_modulus,</div><div class="line">               Poissons_ratio,</div><div class="line">               length,</div><div class="line">               depth,</div><div class="line">               thickness;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">present_time (present_time),</div><div class="line">end_time (end_time),</div><div class="line">shear_force (2e4),</div><div class="line">Youngs_modulus (2.e11),</div><div class="line">Poissons_ratio (.3),</div><div class="line">length (.48),</div><div class="line">depth (.12),</div><div class="line">thickness (.01)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>compute exact displacement of Timoshenko beam problem, u_bar</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> inertia_moment = (thickness*std::pow(depth,3)) / 12;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> x = p(0);</div><div class="line"><span class="keywordtype">double</span> y = p(1);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fac = shear_force / (6*Youngs_modulus*inertia_moment);</div><div class="line"></div><div class="line">values(0) =  fac * y * ( (6*length-3*x)*x + (2+Poissons_ratio)*(y*y-depth*depth/4) );</div><div class="line">values(1) = -fac* ( 3*Poissons_ratio*y*y*(length-x) + 0.25*(4+5*Poissons_ratio)*depth*depth*x + (3*length-x)*x*x );</div></div><!-- fragment --><p>compute the fraction of imposed force</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = present_time/end_time;</div><div class="line"></div><div class="line">  values *= frac;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --><p>----------------------&mdash; Thick_tube_internal_pressure -------------------------------&mdash;</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>IncrementalBoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                       std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                 end_time,</div><div class="line">                 pressure,</div><div class="line">                 inner_radius;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">  IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim),</div><div class="line">  present_time (present_time),</div><div class="line">  end_time (end_time),</div><div class="line">  pressure (0.6*2.4e8),</div></div><!-- fragment --><p>pressure (1.94e8),</p>
<div class="fragment"><div class="line">inner_radius(.1)</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">      <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1.e-7 * inner_radius,</div><div class="line">               radius = p.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div></div><!-- fragment --><p>compute traction on the inner boundary, t_bar</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(radius &lt; (eps+inner_radius), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> theta = std::atan2(p(1),p(0));</div><div class="line"></div><div class="line">values(0) = pressure * std::cos(theta);</div><div class="line">values(1) = pressure * std::sin(theta);</div></div><!-- fragment --><p>compute the fraction of imposed force</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = present_time/end_time;</div><div class="line"></div><div class="line">  values *= frac;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce () : <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt; (dim) {}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">               end_time;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">present_time (present_time),</div><div class="line">end_time (end_time)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  values = 0.;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --><p>----------------------&mdash; Perforated_strip_tension -------------------------------&mdash;</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">               end_time;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim),</div><div class="line">present_time (present_time),</div><div class="line">end_time (end_time)</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  values = 0;</div></div><!-- fragment --><p>compute the fraction of imposed force</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = present_time/end_time;</div><div class="line"></div><div class="line">  values *= frac;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryForce&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce () : <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt; (dim) {}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">               end_time,</div><div class="line">               imposed_displacement,</div><div class="line">               height;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">:</div><div class="line"><a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">present_time (present_time),</div><div class="line">end_time (end_time),</div><div class="line">imposed_displacement (0.00055),</div><div class="line">height (0.18)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1.e-8 * height;</div><div class="line"></div><div class="line">  values = 0.;</div></div><!-- fragment --><p>impose displacement only on the top edge</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (std::abs(p[1]-height) &lt; eps)</div><div class="line">{</div></div><!-- fragment --><p>compute the fraction of imposed displacement</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> inc_frac = 1/end_time;</div><div class="line"></div><div class="line">    values(1) = inc_frac*imposed_displacement;</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p],</div><div class="line">        value_list[p]);</div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --><p>----------------------&mdash; Cantiliver_beam_3d -------------------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">        end_time,</div><div class="line">        pressure,</div><div class="line">        height;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">IncrementalBoundaryForce (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim),</div><div class="line">  present_time (present_time),</div><div class="line">  end_time (end_time),</div><div class="line">  pressure (6e6),</div><div class="line">  height (200e-3)</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1.e-7 * height;</div></div><!-- fragment --><p>pressure should be imposed on the top surface, y = height</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(p[1]-(height/2)) &lt; eps, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">values = 0;</div><div class="line"></div><div class="line">values(1) = -pressure;</div></div><!-- fragment --><p>compute the fraction of imposed force</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frac = present_time/end_time;</div><div class="line"></div><div class="line">  values *= frac;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryForce&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryForce&lt;dim&gt;::vector_value (points[p], value_list[p]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BodyForce :  <span class="keyword">public</span> <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BodyForce () : <a class="code" href="classZeroFunction.html">ZeroFunction</a>&lt;dim&gt; (dim) {}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>IncrementalBoundaryValues :  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span> end_time);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">        end_time;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">IncrementalBoundaryValues (<span class="keyword">const</span> <span class="keywordtype">double</span> present_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> end_time)</div><div class="line">  :</div><div class="line">  <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (dim),</div><div class="line">  present_time (present_time),</div><div class="line">  end_time (end_time)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  values = 0.;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">IncrementalBoundaryValues&lt;dim&gt;::</div><div class="line">vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), n_points));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;n_points; ++p)</div><div class="line">    IncrementalBoundaryValues&lt;dim&gt;::vector_value (points[p], value_list[p]);</div><div class="line">}</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>DualFunctional</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DualFunctionalBase : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                  <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span> = 0;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PointValuesEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PointValuesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                  <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a> (ExcEvaluationPointNotFound,</div><div class="line">                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  PointValuesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div><div class="line">    :</div><div class="line">    evaluation_point (evaluation_point)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    rhs_dual.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_vertex = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a>;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell_dual!=endc_dual; ++cell_dual)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex=0;</div><div class="line">           vertex&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell;</div><div class="line">           ++vertex)</div><div class="line">        <span class="keywordflow">if</span> (cell_dual-&gt;vertex(vertex).distance(evaluation_point)</div><div class="line">            &lt; cell_dual-&gt;diameter()*1e-8)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dofs_per_vertex; ++id)</div><div class="line">              {</div><div class="line">                rhs_dual(cell_dual-&gt;vertex_dof_index(vertex,<span class="keywordtype">id</span>)) = 1;</div><div class="line">              }</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (<span class="keyword">false</span>, ExcEvaluationPointNotFound(evaluation_point));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PointXDerivativesEvaluation : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PointXDerivativesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                  <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a> (ExcEvaluationPointNotFound,</div><div class="line">                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PointXDerivativesEvaluation&lt;dim&gt;::</div><div class="line">  PointXDerivativesEvaluation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point)</div><div class="line">    :</div><div class="line">    evaluation_point (evaluation_point)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  PointXDerivativesEvaluation&lt;dim&gt;::</div><div class="line">  assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    rhs_dual.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_vertex = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(4);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>  fe_values (dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), quadrature,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> ( n_q_points==quadrature.size() , <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>() );</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs (dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> total_volume = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;center().distance(evaluation_point) &lt;=</div><div class="line">          cell-&gt;diameter())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">                  component_i = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line"></div><div class="line">                  cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q)[0] *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q);</div><div class="line">                }</div><div class="line"></div><div class="line">              total_volume += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q);</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              rhs_dual(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (total_volume &gt; 0,</div><div class="line">                 ExcEvaluationPointNotFound(evaluation_point));</div><div class="line"></div><div class="line">    rhs_dual.<a class="code" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (1./total_volume);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MeanDisplacementFace : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MeanDisplacementFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                          <span class="keyword">const</span> std::vector&lt;bool&gt; comp_mask);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                  <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;bool&gt; comp_mask;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MeanDisplacementFace&lt;dim&gt;::</div><div class="line">  MeanDisplacementFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                        <span class="keyword">const</span> std::vector&lt;bool&gt; comp_mask )</div><div class="line">    :</div><div class="line">    face_id (face_id),</div><div class="line">    comp_mask (comp_mask)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(comp_mask.size() == dim,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (comp_mask.size(), dim) );</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  MeanDisplacementFace&lt;dim&gt;::</div><div class="line">  assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    rhs_dual.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature(dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), face_quadrature,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_vertex = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_face_q_points = face_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(dofs_per_vertex == dim,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (dofs_per_vertex, dim) );</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; comp_vector(dofs_per_vertex);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dofs_per_vertex; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (comp_mask[i])</div><div class="line">          {</div><div class="line">            comp_vector[i] = 1;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>bound_size : size of the boundary, in 2d is the length and in the 3d case, area</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> bound_size = 0.;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">              &amp;&amp;</div><div class="line">              cell-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                {</div><div class="line">                  evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">              fe_face_values.reinit (cell, face);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                {</div><div class="line">                  bound_size += fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">                      component_i = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line"></div><div class="line">                      cell_rhs(i) += (fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                      comp_vector[component_i] *</div><div class="line">                                      fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          rhs_dual(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  rhs_dual /= bound_size;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MeanStressFace : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MeanStressFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                  <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;comp_stress);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt;  comp_stress;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MeanStressFace&lt;dim&gt;::</div><div class="line">MeanStressFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;comp_stress )</div><div class="line">  :</div><div class="line">  face_id (face_id),</div><div class="line">  comp_stress (comp_stress)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(comp_stress.size() == dim,</div><div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (comp_stress.size(), dim) );</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MeanStressFace&lt;dim&gt;::</div><div class="line">assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">              <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  rhs_dual.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature(dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), face_quadrature,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dual (dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), face_quadrature,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_face_q_points = face_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_face_q_points);</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>      cell_rhs (dofs_per_cell_dual);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell_dual);</div></div><!-- fragment --><p>bound_size : size of the boundary, in 2d is the length and in the 3d case, area</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> bound_size = 0.;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_dual!=endc_dual; ++cell_dual, ++cell)</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (cell_dual-&gt;face(face)-&gt;at_boundary()</div><div class="line">              &amp;&amp;</div><div class="line">              cell_dual-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                {</div><div class="line">                  evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">              fe_face_values.reinit (cell, face);</div><div class="line">              fe_face_values_dual.reinit (cell_dual, face);</div><div class="line"></div><div class="line">              fe_face_values[displacement].get_function_symmetric_gradients(solution,</div><div class="line">                  strain_tensor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                {</div><div class="line">                  bound_size += fe_face_values_dual.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">                  constitutive_law.get_stress_strain_tensor(strain_tensor[q_point],</div><div class="line">                                                            stress_strain_tensor);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_dual; ++i)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                      stress_phi_i = stress_strain_tensor</div><div class="line">                                     * fe_face_values_dual[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">                        {</div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                            {</div><div class="line">                              <span class="keywordflow">if</span> ( comp_stress[k][l] == 1 )</div><div class="line">                                {</div><div class="line">                                  cell_rhs(i) += stress_phi_i[k][l]</div><div class="line">                                                 *</div><div class="line">                                                 fe_face_values_dual.JxW(q_point);</div><div class="line">                                }</div><div class="line"></div><div class="line">                            }</div><div class="line">                        }</div><div class="line"></div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell_dual-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_dual; ++i)</div><div class="line">        {</div><div class="line">          rhs_dual(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  rhs_dual /= bound_size;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MeanStressDomain : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MeanStressDomain (<span class="keyword">const</span> std::string &amp;base_mesh,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;comp_stress);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">                <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> std::string base_mesh;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt;  comp_stress;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MeanStressDomain&lt;dim&gt;::</div><div class="line">MeanStressDomain (<span class="keyword">const</span> std::string &amp;base_mesh,</div><div class="line">                  <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &amp;comp_stress )</div><div class="line">  :</div><div class="line">  base_mesh (base_mesh),</div><div class="line">  comp_stress (comp_stress)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(comp_stress.size() == dim,</div><div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (comp_stress.size(), dim) );</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MeanStressDomain&lt;dim&gt;::</div><div class="line">assemble_rhs (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;solution,</div><div class="line">              <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; &amp;constitutive_law,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      &amp;dof_handler_dual,</div><div class="line">              <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;rhs_dual)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>Mean stress at the specified domain is of interest. The interest domains are located on the bottom and top of the flanges close to the clamped face, z = 0 top domain: height/2 - thickness_flange &lt;= y &lt;= height/2 0 &lt;= z &lt;= 2 * thickness_flange bottom domain: -height/2 &lt;= y &lt;= -height/2 + thickness_flange 0 &lt;= z &lt;= 2 * thickness_flange</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> height = 200e-3,</div><div class="line">             thickness_flange = 10e-3;</div><div class="line"></div><div class="line">rhs_dual.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1);</div><div class="line"></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), quadrature_formula,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dual (dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_q_points);</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>      cell_rhs (dofs_per_cell_dual);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell_dual);</div></div><!-- fragment --><p>domain_size : size of the interested domain, in 2d is the area and in the 3d case, volume</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> domain_size = 0.;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> evaluation_domain_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell_dual!=endc_dual; ++cell_dual, ++cell)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = cell-&gt;center()[1],</div><div class="line">                 z = cell-&gt;center()[2];</div></div><!-- fragment --><p>top domain: height/2 - thickness_flange &lt;= y &lt;= height/2 0 &lt;= z &lt;= 2 * thickness_flange bottom domain: -height/2 &lt;= y &lt;= -height/2 + thickness_flange 0 &lt;= z &lt;= 2 * thickness_flange</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> ( ((z &gt; 0) &amp;&amp; (z &lt; 2*thickness_flange)) &amp;&amp;</div><div class="line">           ( ((y &gt; height/2 - thickness_flange) &amp;&amp; (y &lt; height/2)) ||</div><div class="line">             ((y &gt; -height/2) &amp;&amp; (y &lt; -height/2 + thickness_flange)) ) )</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (!evaluation_domain_found)</div><div class="line">            {</div><div class="line">              evaluation_domain_found = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">          fe_values_dual.reinit(cell_dual);</div><div class="line"></div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(solution,</div><div class="line">                                                                   strain_tensor);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              domain_size += fe_values_dual.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">              constitutive_law.get_stress_strain_tensor(strain_tensor[q_point],</div><div class="line">                                                        stress_strain_tensor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_dual; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                  stress_phi_i = stress_strain_tensor</div><div class="line">                                 * fe_values_dual[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">                    {</div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                        {</div><div class="line">                          <span class="keywordflow">if</span> ( comp_stress[k][l] == 1 )</div><div class="line">                            {</div><div class="line">                              cell_rhs(i) += stress_phi_i[k][l]</div><div class="line">                                             *</div><div class="line">                                             fe_values_dual.JxW(q_point);</div><div class="line">                            }</div><div class="line"></div><div class="line">                        }</div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line"></div><div class="line">            }</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">      cell_dual-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_dual; ++i)</div><div class="line">        {</div><div class="line">          rhs_dual(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_domain_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  rhs_dual /= domain_size;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MeanStrainEnergyFace : <span class="keyword">public</span> DualFunctionalBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MeanStrainEnergyFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>      &amp;lambda_function,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>      &amp;mu_function );</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs_nonlinear (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;primal_dof_handler,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  &amp;primal_solution,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        &amp;rhs) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a> &gt;       lambda_function;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a> &gt;       mu_function;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MeanStrainEnergyFace&lt;dim&gt;::</div><div class="line">MeanStrainEnergyFace (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>      &amp;lambda_function,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>      &amp;mu_function )</div><div class="line">  :</div><div class="line">  face_id (face_id),</div><div class="line">  lambda_function (&amp;lambda_function),</div><div class="line">  mu_function (&amp;mu_function)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MeanStrainEnergyFace&lt;dim&gt;::</div><div class="line">assemble_rhs_nonlinear (<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;primal_dof_handler,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  &amp;primal_solution,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>Assemble right hand side of the dual problem when the quantity of interest is a nonlinear functinoal. In this case, the QoI should be linearized which depends on the solution of the primal problem. The extracter of the linearized QoI functional is the gradient of the the original QoI functional with the primal solution values.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature(dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1);</div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> primal_fe_face_values (primal_dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), face_quadrature,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>(), face_quadrature,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_vertex = primal_dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_face_q_points = face_quadrature.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  dofs_per_cell = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(dofs_per_vertex == dim,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (dofs_per_vertex, dim) );</div><div class="line"></div><div class="line">std::vector&lt; std::vector&lt; Tensor&lt;1,dim&gt; &gt; &gt; primal_solution_gradients;</div><div class="line">primal_solution_gradients.resize(n_face_q_points);</div><div class="line"></div><div class="line">std::vector&lt;std::vector&lt;Tensor&lt;2,dim&gt; &gt; &gt;   primal_solution_hessians;</div><div class="line">primal_solution_hessians.resize (n_face_q_points);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_face_q_points; ++i)</div><div class="line">  {</div><div class="line">    primal_solution_gradients[i].resize (dofs_per_vertex);</div><div class="line">    primal_solution_hessians[i].resize  (dofs_per_vertex);</div><div class="line">  }</div><div class="line"></div><div class="line">std::vector&lt;double&gt;   lambda_values (n_face_q_points);</div><div class="line">std::vector&lt;double&gt;   mu_values (n_face_q_points);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>      cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>bound_size : size of the boundary, in 2d is the length and in the 3d case, area</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> bound_size  = 0.;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    primal_cell = primal_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    primal_endc = primal_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++primal_cell)</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">                &amp;&amp;</div><div class="line">                cell-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                  {</div><div class="line">                    evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                  }</div><div class="line">                primal_fe_face_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (primal_cell, face);</div><div class="line"></div><div class="line">                primal_fe_face_values.get_function_grads (primal_solution,</div><div class="line">                                                          primal_solution_gradients);</div><div class="line"></div><div class="line">                primal_fe_face_values.get_function_hessians (primal_solution,</div><div class="line">                                                             primal_solution_hessians);</div><div class="line"></div><div class="line">                lambda_function-&gt;value_list (primal_fe_face_values.get_quadrature_points(), lambda_values);</div><div class="line">                mu_function-&gt;value_list     (primal_fe_face_values.get_quadrature_points(), mu_values);</div><div class="line"></div><div class="line">                fe_face_values.reinit (cell, face);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                  {</div><div class="line">                    bound_size += primal_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m&lt;dofs_per_cell; ++m)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">                        component_m = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(m).first;</div><div class="line"></div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dofs_per_vertex; ++i)</div><div class="line">                          {</div><div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dofs_per_vertex; ++j)</div><div class="line">                              {</div><div class="line">                                cell_rhs(m) += fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(m,q_point) *</div><div class="line">                                               (</div><div class="line">                                                 lambda_values[q_point] *</div><div class="line">                                                 (</div><div class="line">                                                   primal_solution_hessians[q_point][i][i][component_m] * primal_solution_gradients[q_point][j][j]</div><div class="line">                                                   +</div><div class="line">                                                   primal_solution_gradients[q_point][i][i] * primal_solution_hessians[q_point][j][j][component_m]</div><div class="line">                                                 )</div><div class="line">                                                 +</div><div class="line">                                                 mu_values[q_point] *</div><div class="line">                                                 (</div><div class="line">                                                   2*primal_solution_hessians[q_point][j][i][component_m] * primal_solution_gradients[q_point][j][i]</div><div class="line">                                                   +</div><div class="line">                                                   primal_solution_hessians[q_point][i][j][component_m] * primal_solution_gradients[q_point][j][i]</div><div class="line">                                                   +</div><div class="line">                                                   primal_solution_gradients[q_point][i][j] * primal_solution_hessians[q_point][j][i][component_m]</div><div class="line">                                                 )</div><div class="line">                                               ) *</div><div class="line">                                               primal_fe_face_values.JxW(q_point);</div><div class="line"></div><div class="line">                              }</div><div class="line">                          }</div><div class="line"></div><div class="line">                      } <span class="comment">// end loop DoFs</span></div><div class="line"></div><div class="line"></div><div class="line">                  }  <span class="comment">// end loop Gauss points</span></div><div class="line"></div><div class="line">              }  <span class="comment">// end if face</span></div><div class="line">          }  <span class="comment">// end loop face</span></div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">          }</div><div class="line"></div><div class="line">      }  <span class="comment">// end loop cell</span></div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    rhs.<a class="code" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (1./(2*bound_size));</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>DualSolver class</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DualSolver</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DualSolver (<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>                        &amp;triangulation,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                             &amp;fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                            &amp;solution,</div><div class="line">              <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt;                      &amp;constitutive_law,</div><div class="line">              <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt;   &amp;dual_functional,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                              &amp;timestep_no,</div><div class="line">              <span class="keyword">const</span> std::string                               &amp;output_dir,</div><div class="line">              <span class="keyword">const</span> std::string                               &amp;base_mesh,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>                                    &amp;present_time,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>                                    &amp;end_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> compute_error_DWR (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;estimated_error_per_cell);</div><div class="line"></div><div class="line">  ~DualSolver ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> compute_dirichlet_constraints ();</div><div class="line">  <span class="keywordtype">void</span> assemble_matrix ();</div><div class="line">  <span class="keywordtype">void</span> assemble_rhs ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>     fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>    solution;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      fe_degree;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      fe_degree_dual;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>           fe_dual;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dual;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>       quadrature_formula;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>        constraints_hanging_nodes_dual;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>        constraints_dirichlet_and_hanging_nodes_dual;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>         sparsity_pattern_dual;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>    system_matrix_dual;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>          system_rhs_dual;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>          solution_dual;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt; constitutive_law;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Triangulation&lt;dim&gt;</a> &gt; triangulation;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const DualFunctional::DualFunctionalBase&lt;dim&gt;</a> &gt; dual_functional;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            timestep_no;</div><div class="line">  std::string             output_dir;</div><div class="line">  <span class="keyword">const</span> std::string       base_mesh;</div><div class="line">  <span class="keywordtype">double</span>                  present_time;</div><div class="line">  <span class="keywordtype">double</span>                  end_time;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">DualSolver&lt;dim&gt;::</div><div class="line">DualSolver (<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>                        &amp;triangulation,</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                             &amp;fe,</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                            &amp;solution,</div><div class="line">            <span class="keyword">const</span> ConstitutiveLaw&lt;dim&gt;                      &amp;constitutive_law,</div><div class="line">            <span class="keyword">const</span> DualFunctional::DualFunctionalBase&lt;dim&gt;   &amp;dual_functional,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                              &amp;timestep_no,</div><div class="line">            <span class="keyword">const</span> std::string                               &amp;output_dir,</div><div class="line">            <span class="keyword">const</span> std::string                               &amp;base_mesh,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>                                    &amp;present_time,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>                                    &amp;end_time)</div><div class="line">  :</div><div class="line">  fe (fe),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  solution(solution),</div><div class="line">  fe_degree(fe.tensor_degree()),</div><div class="line">  fe_degree_dual(fe_degree + 1),</div><div class="line">  fe_dual(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(fe_degree_dual), dim),</div><div class="line">  dof_handler_dual (triangulation),</div><div class="line">  quadrature_formula (fe_degree_dual + 1),</div><div class="line">  face_quadrature_formula (fe_degree_dual + 1),</div><div class="line">  constitutive_law (constitutive_law),</div><div class="line">  triangulation (&amp;triangulation),</div><div class="line">  dual_functional (&amp;dual_functional),</div><div class="line">  timestep_no (timestep_no),</div><div class="line">  output_dir (output_dir),</div><div class="line">  base_mesh (base_mesh),</div><div class="line">  present_time (present_time),</div><div class="line">  end_time (end_time)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">DualSolver&lt;dim&gt;::~DualSolver()</div><div class="line">{</div><div class="line">  dof_handler_dual.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  dof_handler_dual.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_dual);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Number of degrees of freedom in dual problem:  &quot;</span></div><div class="line">            &lt;&lt; dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints_hanging_nodes_dual.clear ();</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_dual,</div><div class="line">                                           constraints_hanging_nodes_dual);</div><div class="line">  constraints_hanging_nodes_dual.close ();</div><div class="line"></div><div class="line">  compute_dirichlet_constraints();</div><div class="line"></div><div class="line">  sparsity_pattern_dual.reinit (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                dof_handler_dual.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler_dual, sparsity_pattern_dual);</div></div><!-- fragment --><p>constraints_hanging_nodes_dual.condense (sparsity_pattern_dual);</p>
<div class="fragment"><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.condense (sparsity_pattern_dual);</div><div class="line"></div><div class="line">  sparsity_pattern_dual.compress();</div><div class="line"></div><div class="line">  system_matrix_dual.reinit (sparsity_pattern_dual);</div><div class="line"></div><div class="line">  solution_dual.reinit (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs_dual.reinit (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">{</div><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.clear ();</div><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.merge(constraints_hanging_nodes_dual);</div><div class="line"></div><div class="line">  std::vector&lt;bool&gt; component_mask(dim);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_dual,</div><div class="line">                                               0,</div><div class="line">                                               EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                               constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">    {</div></div><!-- fragment --><p>the boundary x = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">true</span>;</div><div class="line">component_mask[1] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                          2,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = 0</p>
<div class="fragment"><div class="line">    component_mask[0] = <span class="keyword">false</span>;</div><div class="line">    component_mask[1] = <span class="keyword">true</span>;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                              3,</div><div class="line">                                              EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                              constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                              component_mask);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>the boundary x = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">true</span>;</div><div class="line">component_mask[1] = <span class="keyword">false</span>;</div><div class="line">component_mask[2] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                          4,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">false</span>;</div><div class="line">component_mask[1] = <span class="keyword">true</span>;</div><div class="line">component_mask[2] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                          1,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = imposed incremental displacement</p>
<div class="fragment"><div class="line">    component_mask[0] = <span class="keyword">false</span>;</div><div class="line">    component_mask[1] = <span class="keyword">true</span>;</div><div class="line">    component_mask[2] = <span class="keyword">false</span>;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                              3,</div><div class="line">                                              EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                              constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                              component_mask);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>the boundary x = y = z = 0</p>
<div class="fragment"><div class="line">      component_mask[0] = <span class="keyword">true</span>;</div><div class="line">      component_mask[1] = <span class="keyword">true</span>;</div><div class="line">      component_mask[2] = <span class="keyword">true</span>;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_dual,</div><div class="line">                                                1,</div><div class="line">                                                EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                                constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                                component_mask);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.close();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::assemble_matrix()</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dual(fe_dual, quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dual = fe_dual.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points         = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell_dual, dofs_per_cell_dual);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt;   local_dof_indices(dofs_per_cell_dual);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc_dual = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_dual != endc_dual; ++cell_dual, ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell_dual-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values_dual.reinit(cell_dual);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(solution,</div><div class="line">                                                                 strain_tensor);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            constitutive_law.get_linearized_stress_strain_tensors(strain_tensor[q_point],</div><div class="line">                                                                  stress_strain_tensor_linearized,</div><div class="line">                                                                  stress_strain_tensor);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dual; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                stress_phi_i = stress_strain_tensor_linearized</div><div class="line">                               * fe_values_dual[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dual; ++j)</div><div class="line">                  cell_matrix(i, j) += (stress_phi_i</div><div class="line">                                        * fe_values_dual[displacement].symmetric_gradient(j, q_point)</div><div class="line">                                        * fe_values_dual.JxW(q_point));</div><div class="line"></div><div class="line">              }</div><div class="line"></div><div class="line">          }</div><div class="line"></div><div class="line">        cell_dual-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes_dual.distribute_local_to_global(cell_matrix,</div><div class="line">            local_dof_indices,</div><div class="line">            system_matrix_dual);</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  dual_functional-&gt;assemble_rhs (dof_handler, solution, constitutive_law,</div><div class="line">                                 dof_handler_dual, system_rhs_dual);</div><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.condense (system_rhs_dual);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::solve()</div><div class="line">{</div></div><!-- fragment --><p>+++ direct solver +++++++++</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>   A_direct;</div><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix_dual);</div></div><!-- fragment --><p>After the decomposition, we can use A_direct like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution_dual, system_rhs_dual);</div></div><!-- fragment --><p>++++ iterative solver ++ CG ++++ doesn't work <a class="el" href="classSolverControl.html">SolverControl</a> solver_control (5000, 1e-12); SolverCG&lt;&gt; cg (solver_control);</p>
<p>PreconditionSSOR&lt;&gt; preconditioner; preconditioner.initialize(system_matrix_dual, 1.2);</p>
<p>cg.solve (system_matrix_dual, solution_dual, system_rhs_dual, preconditioner);</p>
<p>++++ iterative solver ++ BiCGStab ++++++ doesn't work <a class="el" href="classSolverControl.html">SolverControl</a> solver_control (5000, 1e-12); SolverBicgstab&lt;&gt; bicgstab (solver_control);</p>
<p>PreconditionJacobi&lt;&gt; preconditioner; preconditioner.initialize(system_matrix_dual, 1.0);</p>
<p>bicgstab.solve (system_matrix_dual, solution_dual, system_rhs_dual, preconditioner);</p>
<p>+++++++++++++++++++++++++++++++++++++++++++++++++</p>
<div class="fragment"><div class="line">  constraints_dirichlet_and_hanging_nodes_dual.distribute (solution_dual);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::output_results()</div><div class="line">{</div><div class="line">  std::string filename = (output_dir + <span class="stringliteral">&quot;dual-solution-&quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_dual);</div><div class="line">  std::vector&lt;std::string&gt; solution_names;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;z_displacement&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">  data_out.add_data_vector (solution_dual, solution_names);</div><div class="line">  data_out.build_patches ();</div><div class="line">  data_out.write_vtk (output);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DualSolver&lt;dim&gt;::compute_error_DWR (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;estimated_error_per_cell)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (estimated_error_per_cell.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == triangulation-&gt;<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (estimated_error_per_cell.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), triangulation-&gt;<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()));</div></div><!-- fragment --><p>solve the dual problem</p>
<div class="fragment"><div class="line">setup_system ();</div><div class="line">assemble_matrix ();</div><div class="line">assemble_rhs ();</div><div class="line">solve ();</div><div class="line">output_results ();</div></div><!-- fragment --><p>compuate the dual weights</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> primal_solution (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="namespaceFETools.html#a6eb5c7c53ff3461a80c39f34ed2913d0">FETools::interpolate</a> (dof_handler,</div><div class="line">                      solution,</div><div class="line">                      dof_handler_dual,</div><div class="line">                      constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                      primal_solution);</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints_hanging_nodes;</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                         constraints_hanging_nodes);</div><div class="line">constraints_hanging_nodes.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> dual_weights (dof_handler_dual.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">FETools::interpolation_difference</a> (dof_handler_dual,</div><div class="line">                                   constraints_dirichlet_and_hanging_nodes_dual,</div><div class="line">                                   solution_dual,</div><div class="line">                                   dof_handler,</div><div class="line">                                   constraints_hanging_nodes,</div><div class="line">                                   dual_weights);</div></div><!-- fragment --><p>estimate the error</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe_dual, quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>  |</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_q_points);</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a>          stress_strain_tensor_grad;</div><div class="line">std::vector&lt;std::vector&lt;Tensor&lt;2,dim&gt; &gt; &gt; cell_hessians (n_q_points);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_q_points; ++i)</div><div class="line">  {</div><div class="line">    cell_hessians[i].resize (dim);</div><div class="line">  }</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; dual_weights_cell_values (n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line"><span class="keyword">const</span> EquationData::BodyForce&lt;dim&gt; body_force;</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; body_force_values (n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_cell(fe_dual, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>           |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>        |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>       |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>),</div><div class="line">                                      fe_face_values_neighbor (fe_dual, face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>     |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>  |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>);</div><div class="line"><a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_subface_values_cell (fe_dual, face_quadrature_formula,</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; jump_residual (n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; dual_weights_face_values (n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt; cell_grads(n_face_q_points);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_face_q_points; ++i)</div><div class="line">  {</div><div class="line">    cell_grads[i].resize (dim);</div><div class="line">  }</div><div class="line">std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt; neighbor_grads(n_face_q_points);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_face_q_points; ++i)</div><div class="line">  {</div><div class="line">    neighbor_grads[i].resize (dim);</div><div class="line">  }</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> q_cell_strain_tensor;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> q_neighbor_strain_tensor;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> cell_stress_strain_tensor;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> neighbor_stress_strain_tensor;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typename</span> std::map&lt;typename DoFHandler&lt;dim&gt;::face_iterator, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">face_integrals;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler_dual.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">           face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">           ++face_no)</div><div class="line">        {</div><div class="line">          face_integrals[cell-&gt;face(face_no)].reinit (dim);</div><div class="line">          face_integrals[cell-&gt;face(face_no)] = -1e20;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">std::vector&lt;Vector&lt;float&gt; &gt; error_indicators_vector;</div><div class="line">error_indicators_vector.resize( triangulation-&gt;<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(),</div><div class="line">                                <a class="code" href="classVector.html">Vector&lt;float&gt;</a>(dim) );</div></div><!-- fragment --><p>--------------&mdash; estimate_some ----------------------&mdash;</p>
<div class="fragment"><div class="line">cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> present_cell = 0;</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++present_cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div></div><!-- fragment --><p>------------&mdash; integrate_over_cell ----------------&mdash;</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">body_force.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             body_force_values);</div><div class="line">fe_values[displacement].get_function_symmetric_gradients(primal_solution,</div><div class="line">                                                         strain_tensor);</div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians</a>(primal_solution, cell_hessians);</div><div class="line"></div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(dual_weights,</div><div class="line">                              dual_weights_cell_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    constitutive_law.get_linearized_stress_strain_tensors(strain_tensor[q_point],</div><div class="line">                                                          stress_strain_tensor_linearized,</div><div class="line">                                                          stress_strain_tensor);</div><div class="line">    constitutive_law.get_grad_stress_strain_tensor(strain_tensor[q_point],</div><div class="line">                                                   cell_hessians[q_point],</div><div class="line">                                                   stress_strain_tensor_grad);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        error_indicators_vector[present_cell](i) +=</div><div class="line">          body_force_values[q_point](i)*</div><div class="line">          dual_weights_cell_values[q_point](i)*</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                  {</div><div class="line">                    error_indicators_vector[present_cell](i) +=</div><div class="line">                      ( stress_strain_tensor[i][j][k][l]*</div><div class="line">                        0.5*(cell_hessians[q_point][k][l][j]</div><div class="line">                             +</div><div class="line">                             cell_hessians[q_point][l][k][j])</div><div class="line">                        + stress_strain_tensor_grad[i][j][k][l][j] * strain_tensor[q_point][k][l]</div><div class="line">                      ) *</div><div class="line">                      dual_weights_cell_values[q_point](i) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  }</div></div><!-- fragment --> <hr/>
<p> compute face_integrals</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">     face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face_no)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dim; ++id)</div><div class="line">          {</div><div class="line">            face_integrals[cell-&gt;face(face_no)](id) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">        (cell-&gt;neighbor(face_no)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">        (cell-&gt;neighbor(face_no)-&gt;index() &lt; cell-&gt;index()))</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no) == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;level() &lt; cell-&gt;level())</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>----------&mdash; integrate_over_regular_face --------&mdash;</p>
<div class="fragment"><div class="line">fe_face_values_cell.reinit(cell, face_no);</div><div class="line">fe_face_values_cell.get_function_grads (primal_solution,</div><div class="line">                                        cell_grads);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">neighbor_neighbor = cell-&gt;neighbor_of_neighbor (face_no);</div><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">neighbor = cell-&gt;neighbor(face_no);</div><div class="line"></div><div class="line">fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);</div><div class="line">fe_face_values_neighbor.get_function_grads (primal_solution,</div><div class="line">                                            neighbor_grads);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    q_cell_strain_tensor = 0.;</div><div class="line">    q_neighbor_strain_tensor = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            q_cell_strain_tensor[i][j] = 0.5*(cell_grads[q_point][i][j] +</div><div class="line">                                              cell_grads[q_point][j][i] );</div><div class="line">            q_neighbor_strain_tensor[i][j] = 0.5*(neighbor_grads[q_point][i][j] +</div><div class="line">                                                  neighbor_grads[q_point][j][i] );</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    constitutive_law.get_stress_strain_tensor (q_cell_strain_tensor,</div><div class="line">                                               cell_stress_strain_tensor);</div><div class="line">    constitutive_law.get_stress_strain_tensor (q_neighbor_strain_tensor,</div><div class="line">                                               neighbor_stress_strain_tensor);</div><div class="line"></div><div class="line">    jump_residual[q_point] = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                  {</div><div class="line">                    jump_residual[q_point](i) += (cell_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                  q_cell_strain_tensor[k][l]</div><div class="line">                                                  -</div><div class="line">                                                  neighbor_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                  q_neighbor_strain_tensor[k][l] )*</div><div class="line">                                                 fe_face_values_cell.normal_vector(q_point)[j];</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">fe_face_values_cell.get_function_values (dual_weights,</div><div class="line">                                         dual_weights_face_values);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> face_integral_vector(dim);</div><div class="line">face_integral_vector = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        face_integral_vector(i) += jump_residual[q_point](i) *</div><div class="line">                                   dual_weights_face_values[q_point](i) *</div><div class="line">                                   fe_face_values_cell.JxW(q_point);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals.find (cell-&gt;face(face_no)) != face_integrals.end(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals[cell-&gt;face(face_no)](i) == -1e20,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    face_integrals[cell-&gt;face(face_no)](i) = face_integral_vector(i);</div><div class="line"></div><div class="line">  }</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>----------&mdash; integrate_over_irregular_face ------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a></div><div class="line">face = cell-&gt;face(face_no);</div><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a></div><div class="line">neighbor = cell-&gt;neighbor(face_no);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor-&gt;has_children(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">neighbor_neighbor = cell-&gt;neighbor_of_neighbor (face_no);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">     subface_no&lt;face-&gt;n_children(); ++subface_no)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    neighbor_child = cell-&gt;neighbor_child_on_subface (face_no, subface_no);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_child-&gt;face(neighbor_neighbor) ==</div><div class="line">            cell-&gt;face(face_no)-&gt;child(subface_no),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    fe_subface_values_cell.reinit (cell, face_no, subface_no);</div><div class="line">    fe_subface_values_cell.get_function_grads (primal_solution,</div><div class="line">                                               cell_grads);</div><div class="line">    fe_face_values_neighbor.reinit (neighbor_child,</div><div class="line">                                    neighbor_neighbor);</div><div class="line">    fe_face_values_neighbor.get_function_grads (primal_solution,</div><div class="line">                                                neighbor_grads);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        q_cell_strain_tensor = 0.;</div><div class="line">        q_neighbor_strain_tensor = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">              {</div><div class="line">                q_cell_strain_tensor[i][j] = 0.5*(cell_grads[q_point][i][j] +</div><div class="line">                                                  cell_grads[q_point][j][i] );</div><div class="line">                q_neighbor_strain_tensor[i][j] = 0.5*(neighbor_grads[q_point][i][j] +</div><div class="line">                                                      neighbor_grads[q_point][j][i] );</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        constitutive_law.get_stress_strain_tensor (q_cell_strain_tensor,</div><div class="line">                                                   cell_stress_strain_tensor);</div><div class="line">        constitutive_law.get_stress_strain_tensor (q_neighbor_strain_tensor,</div><div class="line">                                                   neighbor_stress_strain_tensor);</div><div class="line"></div><div class="line">        jump_residual[q_point] = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                      {</div><div class="line">                        jump_residual[q_point](i) += (-cell_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                      q_cell_strain_tensor[k][l]</div><div class="line">                                                      +</div><div class="line">                                                      neighbor_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                      q_neighbor_strain_tensor[k][l] )*</div><div class="line">                                                     fe_face_values_neighbor.normal_vector(q_point)[j];</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">    fe_face_values_neighbor.get_function_values (dual_weights,</div><div class="line">                                                 dual_weights_face_values);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> face_integral_vector(dim);</div><div class="line">    face_integral_vector = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            face_integral_vector(i) += jump_residual[q_point](i) *</div><div class="line">                                       dual_weights_face_values[q_point](i) *</div><div class="line">                                       fe_face_values_neighbor.JxW(q_point);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        face_integrals[neighbor_child-&gt;face(neighbor_neighbor)](i) = face_integral_vector(i);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> (dim);</div><div class="line">sum = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">     subface_no&lt;face-&gt;n_children(); ++subface_no)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals.find(face-&gt;child(subface_no)) !=</div><div class="line">            face_integrals.end(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals[face-&gt;child(subface_no)](i) != -1e20,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>(i) += face_integrals[face-&gt;child(subface_no)](i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    face_integrals[face](i) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>(i);</div><div class="line">  }</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">  present_cell=0;</div><div class="line">  cell = dof_handler_dual.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++present_cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_no)</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(cell-&gt;face(face_no)) !=</div><div class="line">                   face_integrals.end(),</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dim; ++id)</div><div class="line">              {</div><div class="line">                error_indicators_vector[present_cell](id)</div><div class="line">                -= 0.5*face_integrals[cell-&gt;face(face_no)](id);</div><div class="line">              }</div><div class="line"></div><div class="line">          }</div><div class="line"></div><div class="line">        estimated_error_per_cell(present_cell) = error_indicators_vector[present_cell].l2_norm();</div><div class="line"></div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeclasstemplate"></a> </p><h3>The <code>PlasticityContactProblem</code> class template</h3>
<p>This is the main class of this program and supplies all functions and variables needed to describe the nonlinear contact problem. It is close to <a class="el" href="step_41.html">step-41</a> but with some additional features like handling hanging nodes, a Newton method, using Trilinos and p4est for parallel distributed computing. To deal with hanging nodes makes life a bit more complicated since we need another <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> now. We create a Newton method for the active set method for the contact situation and to handle the nonlinear operator for the constitutive law.</p>
<p>The general layout of this class is very much like for most other tutorial programs. To make our life a bit easier, this class reads a set of input parameters from an input file. These parameters, using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, are declared in the <code>declare_parameters</code> function (which is static so that it can be called before we even create an object of the current type), and a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that has been used to read an input file will then be passed to the constructor of this class.</p>
<p>The remaining member functions are by and large as we have seen in several of the other tutorial programs, though with additions for the current nonlinear system. We will comment on their purpose as we get to them further below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ElastoPlasticProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ElastoPlasticProblem (<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> compute_dirichlet_constraints ();</div><div class="line">  <span class="keywordtype">void</span> assemble_newton_system (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;delta_linearization_point);</div><div class="line">  <span class="keywordtype">void</span> compute_nonlinear_residual (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> solve_newton_system ();</div><div class="line">  <span class="keywordtype">void</span> solve_newton ();</div><div class="line">  <span class="keywordtype">void</span> compute_error ();</div><div class="line">  <span class="keywordtype">void</span> compute_error_residual (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;tmp_solution);</div><div class="line">  <span class="keywordtype">void</span> refine_grid ();</div><div class="line">  <span class="keywordtype">void</span> move_mesh (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> std::string &amp;filename_base);</div></div><!-- fragment --><p>Next are three functions that handle the history variables stored in each quadrature point. The first one is called before the first timestep to set up a pristine state for the history variables. It only works on those quadrature points on cells that belong to the present processor:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_quadrature_point_history ();</div></div><!-- fragment --><p>The second one updates the history variables at the end of each timestep:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_quadrature_point_history ();</div></div><!-- fragment --><p>As far as member variables are concerned, we start with ones that we use to indicate the MPI universe this program runs on, and then two numbers telling us how many participating processors there are, and where in this world we are., a stream we use to let exactly one processor produce output to the console (see <a class="el" href="step_17.html">step-17</a>) and a variable that is used to time the various sections of the program:</p>
<div class="fragment"><div class="line">MPI_Comm           mpi_communicator;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_mpi_processes;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> this_mpi_process;</div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div></div><!-- fragment --><p>The next group describes the mesh and the finite element space. In particular, for this parallel program, the finite element space has associated with it variables that indicate which degrees of freedom live on the current processor (the index sets, see also <a class="el" href="step_40.html">step-40</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> documentation module) as well as a variety of constraints: those imposed by hanging nodes, by Dirichlet boundary conditions, and by the active set of contact nodes. Of the three <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> variables defined here, the first only contains hanging node constraints, the second also those associated with Dirichlet boundary conditions, and the third these plus the contact constraints.</p>
<p>The variable <code>active_set</code> consists of those degrees of freedom constrained by the contact, and we use <code>fraction_of_plastic_q_points_per_cell</code> to keep track of the fraction of quadrature points on each cell where the stress equals the yield stress. The latter is only used to create graphical output showing the plastic zone, but not for any further computation; the variable is a member variable of this class since the information is computed as a by-product of computing the residual, but is used only much later. (Note that the vector is a vector of length equal to the number of active cells on the <em>local mesh</em>; it is never used to exchange information between processors and can therefore be a regular deal.II vector.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>           locally_owned_dofs;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>           locally_relevant_dofs;</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>   constraints_hanging_nodes;</div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>   constraints_dirichlet_and_hanging_nodes;</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a>      fraction_of_plastic_q_points_per_cell;</div></div><!-- fragment --><p>One difference of this program is that we declare the quadrature formula in the class declaration. The reason is that in all the other programs, it didn't do much harm if we had used different quadrature formulas when computing the matrix and the right hand side, for example. However, in the present case it does: we store information in the quadrature points, so we have to make sure all parts of the program agree on where they are and how many there are on each cell. Thus, let us first declare the quadrature formula that will be used throughout...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>          quadrature_formula;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;      face_quadrature_formula;</div></div><!-- fragment --><p>... and then also have a vector of history objects, one per quadrature point on those cells for which we are responsible (i.e. we don't store history data for quadrature points on cells that are owned by other processors).</p>
<div class="fragment"><div class="line">std::vector&lt;PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div></div><!-- fragment --><p>The way this object is accessed is through a <code>user pointer</code> that each cell, face, or edge holds: it is a <code>void*</code> pointer that can be used by application programs to associate arbitrary data to cells, faces, or edges. What the program actually does with this data is within its own responsibility, the library just allocates some space for these pointers, and application programs can set and read the pointers for each of these objects.</p>
<p>The next block of variables corresponds to the solution and the linear systems we need to form. In particular, this includes the Newton matrix and right hand side; the vector that corresponds to the residual (i.e., the Newton right hand side) but from which we have not eliminated the various constraints and that is used to determine which degrees of freedom need to be constrained in the next iteration; and a vector that corresponds to the diagonal of the <img class="formulaInl" alt="$B$" src="form_65.png"/> matrix briefly mentioned in the introduction and discussed in the accompanying paper.</p>
<div class="fragment"><div class="line">TrilinosWrappers::SparseMatrix    newton_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>     solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>     incremental_displacement;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>     newton_rhs;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>     newton_rhs_residual;</div></div><!-- fragment --><p>The next block of variables is then related to the time dependent nature of the problem: they denote the length of the time interval which we want to simulate, the present time and number of time step, and length of present timestep:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>       present_time;</div><div class="line"><span class="keywordtype">double</span>       present_timestep;</div><div class="line"><span class="keywordtype">double</span>       end_time;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_no;</div></div><!-- fragment --><p>The next block contains the variables that describe the material response:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, sigma_0, gamma;</div><div class="line">ConstitutiveLaw&lt;dim&gt; constitutive_law;</div></div><!-- fragment --><p>And then there is an assortment of other variables that are used to identify the mesh we are asked to build as selected by the parameter file, the obstacle that is being pushed into the deformable body, the mesh refinement strategy, whether to transfer the solution from one mesh to the next, and how many mesh refinement cycles to perform. As possible, we mark these kinds of variables as <code>const</code> to help the reader identify which ones may or may not be modified later on (the output directory being an exception &ndash; it is never modified outside the constructor but it is awkward to initialize in the member-initializer-list following the colon in the constructor since there we have only one shot at setting it; the same is true for the mesh refinement criterion):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string                                  base_mesh;</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>RefinementStrategy</div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> value</div><div class="line">    {</div><div class="line">      refine_global,</div><div class="line">      refine_percentage,</div><div class="line">      refine_fix_dofs</div><div class="line">    };</div><div class="line">  };</div><div class="line">  <span class="keyword">typename</span> RefinementStrategy::value                 refinement_strategy;</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>ErrorEstimationStrategy</div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> value</div><div class="line">    {</div><div class="line">      kelly_error,</div><div class="line">      residual_error,</div><div class="line">      weighted_residual_error,</div><div class="line">      weighted_kelly_error</div><div class="line">    };</div><div class="line">  };</div><div class="line">  <span class="keyword">typename</span> ErrorEstimationStrategy::value            error_estimation_strategy;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a>                                      estimated_error_per_cell;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>                                         transfer_solution;</div><div class="line">  std::string                                        output_dir;</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a>                                       table_results,</div><div class="line">                                                     table_results_2,</div><div class="line">                                                     table_results_3;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                       current_refinement_cycle;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                       max_relative_error;</div><div class="line">  <span class="keywordtype">float</span>                                              relative_error;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>                                         show_stresses;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodePlasticityContactProblemcodeclass"></a> </p><h3>Implementation of the <code>PlasticityContactProblem</code> class</h3>
<p><a class="anchor" id="PlasticityContactProblemdeclare_parameters"></a> </p><h4>PlasticityContactProblem::declare_parameters</h4>
<p>Let us start with the declaration of run-time parameters that can be selected in the input file. These values will be read back in the constructor of this class to initialize the member variables of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;polynomial degree&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>, <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the selected error estimator.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;error estimation strategy&quot;</span>, <span class="stringliteral">&quot;kelly_error&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;kelly_error|residual_error|weighted_residual_error&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Error estimation strategy:\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot; kelly_error: Kelly error estimator\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot; residual_error: residual-based error estimator\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot; weighted_residual_error: dual weighted residual (Goal-oriented) error estimator.\n&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;maximum relative error&quot;</span>,<span class="stringliteral">&quot;0.05&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                    <span class="stringliteral">&quot;maximum relative error which plays the role of a criteria for refinement.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;output directory&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;transfer solution&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>, <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Timoshenko beam|Thick_tube_internal_pressure|&quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;Perforated_strip_tension|Cantiliver_beam_3d&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;elasticity modulus&quot;</span>,<span class="stringliteral">&quot;2.e11&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Elasticity modulus of the material in MPa (N/mm2)&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Poissons ratio&quot;</span>,<span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Poisson&#39;s ratio of the material&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;yield stress&quot;</span>,<span class="stringliteral">&quot;2.e11&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Yield stress of the material in MPa (N/mm2)&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;isotropic hardening parameter&quot;</span>,<span class="stringliteral">&quot;0.&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Isotropic hardening parameter of the material&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;show stresses&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Whether illustrates the stresses and von Mises stresses or not.&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeconstructor"></a> </p><h4>The <code>PlasticityContactProblem</code> constructor</h4>
<p>Given the declarations of member variables as well as the declarations of run-time parameters that are read from the input file, there is nothing surprising in this constructor. In the body we initialize the mesh refinement strategy and the output directory, creating such a directory if necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ElastoPlasticProblem&lt;dim&gt;::</div><div class="line">ElastoPlasticProblem (<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  :</div><div class="line">  mpi_communicator(MPI_COMM_WORLD),</div><div class="line">  n_mpi_processes (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::n_mpi_processes(mpi_communicator)),</div><div class="line">  this_mpi_process (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::this_mpi_process(mpi_communicator)),</div><div class="line">  pcout(<a class="code" href="namespacestd.html">std</a>::cout, this_mpi_process == 0),</div><div class="line">  computing_timer(MPI_COMM_WORLD, pcout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times),</div><div class="line"></div><div class="line">  n_initial_global_refinements (prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>)),</div><div class="line">  triangulation(mpi_communicator),</div><div class="line">  fe_degree (prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>)),</div><div class="line">  fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree+1)), dim),</div><div class="line">  dof_handler(triangulation),</div><div class="line">  quadrature_formula (fe_degree + 1),</div><div class="line">  face_quadrature_formula (fe_degree + 1),</div><div class="line"></div><div class="line">  e_modulus (prm.get_double(<span class="stringliteral">&quot;elasticity modulus&quot;</span>)),</div><div class="line">  nu (prm.get_double(<span class="stringliteral">&quot;Poissons ratio&quot;</span>)),</div><div class="line">  sigma_0(prm.get_double(<span class="stringliteral">&quot;yield stress&quot;</span>)),</div><div class="line">  gamma (prm.get_double(<span class="stringliteral">&quot;isotropic hardening parameter&quot;</span>)),</div><div class="line">  constitutive_law (e_modulus,</div><div class="line">                    nu,</div><div class="line">                    sigma_0,</div><div class="line">                    gamma),</div><div class="line"></div><div class="line">  base_mesh (prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>)),</div><div class="line"></div><div class="line">  transfer_solution (prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>)),</div><div class="line">  table_results(),</div><div class="line">  table_results_2(),</div><div class="line">  table_results_3(),</div><div class="line">  max_relative_error (prm.get_double(<span class="stringliteral">&quot;maximum relative error&quot;</span>)),</div><div class="line">  show_stresses (prm.get_bool(<span class="stringliteral">&quot;show stresses&quot;</span>))</div><div class="line">{</div><div class="line">  std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;error estimation strategy&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;kelly_error&quot;</span>)</div><div class="line">    error_estimation_strategy = ErrorEstimationStrategy::kelly_error;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;residual_error&quot;</span>)</div><div class="line">    error_estimation_strategy = ErrorEstimationStrategy::residual_error;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;weighted_residual_error&quot;</span>)</div><div class="line">    error_estimation_strategy = ErrorEstimationStrategy::weighted_residual_error;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">    output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line">  mkdir(output_dir.c_str(), 0777);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span></div><div class="line">        &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>) &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmake_grid"></a> </p><h4>PlasticityContactProblem::make_grid</h4>
<p>The next block deals with constructing the starting mesh. We will use the following helper function and the first block of the <code>make_grid()</code> to construct a mesh that corresponds to a half sphere. deal.II has a function that creates such a mesh, but it is in the wrong location and facing the wrong direction, so we need to shift and rotate it a bit before using it.</p>
<p>For later reference, as described in the documentation of <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball()</a>, the flat surface of the halfsphere has boundary indicator zero, while the remainder has boundary indicator one.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">rotate_half_sphere (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(in(2), in(1), -in(0));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::make_grid ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> length = .48,</div><div class="line">                   depth  = .12;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_1(0, -depth/2),</div><div class="line">            point_2(length, depth/2);</div><div class="line"></div><div class="line">      std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">      repetitions[0] = 4;</div><div class="line">      repetitions[1] = 1;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation, repetitions, point_1, point_2);</div></div><!-- fragment --><p>give the indicators to boundaries for specification,</p>
<p>________100______ | | 0 | | 5 |________________| 100 0 to essential boundary conditions (left edge) which are as default 100 to the null boundaries (upper and lower edges) where we do not need to take care of them 5 to the natural boundaries (right edge) for imposing the traction force</p>
<div class="fragment"><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face!=<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a>; ++face)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ( std::fabs(cell-&gt;face(face)-&gt;center()(0)-length) &lt; 1e-12 )</div><div class="line">              {</div><div class="line">                cell-&gt;face(face)-&gt;set_boundary_indicator(5);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( std::fabs(cell-&gt;face(face)-&gt;center()(1)-(depth/2)) &lt; 1e-12 )</div><div class="line">                      ||</div><div class="line">                      ( std::fabs(cell-&gt;face(face)-&gt;center()(1)-(-depth/2)) &lt; 1e-12 ) )</div><div class="line">              {</div><div class="line">                cell-&gt;face(face)-&gt;set_boundary_indicator(100);</div><div class="line">              }</div><div class="line"></div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>Example 1 from the paper: Zhong Z., .... A new numerical method for determining collapse load-carrying capacity of structure made of elasto-plastic material, J. Cent. South Univ. (2014) 21: 398-404</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center(0, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = .1,</div><div class="line">             outer_radius = .2;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">GridGenerator::quarter_hyper_shell</a>(triangulation,</div><div class="line">                                   center, inner_radius, outer_radius,</div><div class="line">                                   0, <span class="keyword">true</span>);</div></div><!-- fragment --><p>give the indicators to boundaries for specification,</p>
<div class="fragment"><div class="line">/ *    _____</div><div class="line">     |     \</div><div class="line">     |       \</div><div class="line">   2 |         \ 1</div><div class="line">     |_          \</div><div class="line">       \          \</div><div class="line">      0 \         |</div><div class="line">         |________|</div><div class="line">             3</div><div class="line">* /</div></div><!-- fragment --><p>0 - inner boundary - natural boundary condition - impose the traction force 1 - outer boundary - free boundary - we do not need to take care of them 2 - left boundary - essential boundary condition - constrained to move along the x direction 3 - bottom boundary - essential boundary condition - constrained to move along the y direction</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> inner_boundary_description(center, inner_radius);</div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0, inner_boundary_description);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> outer_boundary_description(center, outer_radius);</div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (1, outer_boundary_description);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0);</div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (1);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>Example 2 from the paper: Zhong Z., .... A new numerical method for determining collapse load-carrying capacity of structure made of elasto-plastic material, J. Cent. South Univ. (2014) 21: 398-404</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim_2d = 2;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> center_2d(0, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.05,</div><div class="line">             outer_radius = 0.1,</div><div class="line">             height = 0.18,</div><div class="line">             thickness = 0.004;</div></div><!-- fragment --><p>thickness = 0.01;</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim_2d&gt;</a> triangulation_1,</div><div class="line">              triangulation_2,</div><div class="line">              triangulation_2d;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1e-7 * inner_radius;</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">GridGenerator::quarter_hyper_shell</a>(triangulation_1,</div><div class="line">                                     center_2d, inner_radius, outer_radius,</div><div class="line">                                     2);</div></div><!-- fragment --><p>Modify the triangulation_1</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim_2d&gt;::active_cell_iterator</a></div><div class="line">cell = triangulation_1.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">endc = triangulation_1.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">std::vector&lt;bool&gt; treated_vertices(triangulation_1.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim_2d&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() &amp;&amp; cell-&gt;face(f)-&gt;center()(0)&gt;eps &amp;&amp;</div><div class="line">          cell-&gt;face(f)-&gt;center()(1)&gt;eps )</div><div class="line">        {</div></div><!-- fragment --><p>distance of the face center from the center</p>
<div class="fragment"><div class="line">            point(0) = cell-&gt;face(f)-&gt;center()(0) - center_2d(0);</div><div class="line">            point(1) = cell-&gt;face(f)-&gt;center()(1) - center_2d(1);</div><div class="line">            <span class="keywordflow">if</span> ( point.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>() &gt; (inner_radius + eps) )</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v &lt; GeometryInfo&lt;dim_2d&gt;::vertices_per_face; ++v)</div><div class="line">                  {</div><div class="line">                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vv = cell-&gt;face(f)-&gt;vertex_index(v);</div><div class="line">                    <span class="keywordflow">if</span> (treated_vertices[vv] == <span class="keyword">false</span>)</div><div class="line">                      {</div><div class="line">                        treated_vertices[vv] = <span class="keyword">true</span>;</div><div class="line">                        <span class="keywordflow">if</span> (vv==1)</div><div class="line">                          {</div><div class="line">                            cell-&gt;face(f)-&gt;vertex(v) = center_2d+<a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a>(outer_radius,outer_radius);</div><div class="line">                          }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Make the triangulation_2, a rectangular above the triangulation_1</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point1 (0, outer_radius),</div><div class="line">        point2 (outer_radius, height);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation_2, point1, point2);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>make the triangulation_2d and refine it</p>
<div class="fragment"><div class="line">{</div></div><!-- fragment --><p>Merge the two triangulation_1 and triangulation_2</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a>(triangulation_1, triangulation_2, triangulation_2d);</div></div><!-- fragment --><p>Assign boundary indicators to the boundary faces</p>
<div class="fragment"><div class="line">  / *</div><div class="line">   *</div><div class="line">   *    /\ y</div><div class="line">   *     |</div><div class="line">   *      _____3_____</div><div class="line">   *     |          |</div><div class="line">   *     |          |</div><div class="line">   *   4 |          |</div><div class="line">   *     |          |</div><div class="line">   *     |          | 2</div><div class="line">   *     |_         |</div><div class="line">   *        \       |</div><div class="line">   *      10 \      |</div><div class="line">   *         |______|   ____________\  x</div><div class="line">   *            1                   /</div><div class="line">   * /</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim_2d&gt;::active_cell_iterator</a></div><div class="line">    cell = triangulation_2d.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation_2d.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim_2d&gt;::faces_per_cell; ++f)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> ( std::fabs(cell-&gt;face(f)-&gt;center()(1)) &lt; eps )</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;set_boundary_indicator(1);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(cell-&gt;face(f)-&gt;center()(0)-outer_radius) &lt; eps )</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;set_boundary_indicator(2);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(cell-&gt;face(f)-&gt;center()(1)-height) &lt; eps )</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;set_boundary_indicator(3);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(cell-&gt;face(f)-&gt;center()(0)) &lt; eps )</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;set_boundary_indicator(4);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;set_all_boundary_indicators(10);</div><div class="line">                  }</div><div class="line"></div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim_2d&gt;</a> inner_boundary_description(center_2d, inner_radius);</div><div class="line">  triangulation_2d.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10, inner_boundary_description);</div><div class="line"></div><div class="line">  triangulation_2d.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line"></div><div class="line">  triangulation_2d.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10);</div><div class="line">}</div></div><!-- fragment --><p>Extrude the triangulation_2d and make it 3d <a class="el" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation</a>(triangulation_2d, 2, thickness, triangulation);</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">extrude_triangulation</a>(triangulation_2d,</div><div class="line">                      2, thickness, triangulation);</div></div><!-- fragment --><p>Assign boundary indicators to the boundary faces</p>
<div class="fragment"><div class="line">    / *</div><div class="line">     *</div><div class="line">     *    /\ y</div><div class="line">     *     |</div><div class="line">     *      _____3_____</div><div class="line">     *     |          |</div><div class="line">     *     |          |</div><div class="line">     *   4 |          |</div><div class="line">     *     |    5|6   |</div><div class="line">     *     |          | 2</div><div class="line">     *     |_         |</div><div class="line">     *        \       |</div><div class="line">     *      10 \      |</div><div class="line">     *         |______|   ____________\  x</div><div class="line">     *            1                   /</div><div class="line">     * /</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> dist_vector;</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center(center_2d(0), center_2d(1), 0);</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">      endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">      <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">                {</div><div class="line">                  dist_vector = cell-&gt;face(f)-&gt;center() - center;</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> ( std::fabs(dist_vector(1)) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(1);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(0)-outer_radius) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(2);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(1)-height) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(3);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(0)) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(4);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(2)) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(5);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(2)-thickness) &lt; eps )</div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_boundary_indicator(6);</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      cell-&gt;face(f)-&gt;set_all_boundary_indicators(10);</div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;dim&gt;</a> inner_boundary_description(inner_radius, 2);</div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10, inner_boundary_description);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>A rectangular tube made of Aluminium <a href="http://www.google.de/imgres?imgurl=http%3A%2F%2Fwww.americanaluminum.com%2Fimages%2Fstockshape-rectangletube.gif&imgrefurl=http%3A%2F%2Fwww.americanaluminum.com%2Fstandard%2FrectangleTube&h=280&w=300&tbnid=VPDNh4-DJz4wyM%3A&zoom=1&docid=9DoGJCkOeFqiSM&ei=L1AuVfG5GMvtO7DggdAF&tbm=isch&client=ubuntu&iact=rc&uact=3&dur=419&page=1&start=0&ndsp=33&ved=0CGYQrQMwFQ">http://www.google.de/imgres?imgurl=http%3A%2F%2Fwww.americanaluminum.com%2Fimages%2Fstockshape-rectangletube.gif&amp;imgrefurl=http%3A%2F%2Fwww.americanaluminum.com%2Fstandard%2FrectangleTube&amp;h=280&amp;w=300&amp;tbnid=VPDNh4-DJz4wyM%3A&amp;zoom=1&amp;docid=9DoGJCkOeFqiSM&amp;ei=L1AuVfG5GMvtO7DggdAF&amp;tbm=isch&amp;client=ubuntu&amp;iact=rc&amp;uact=3&amp;dur=419&amp;page=1&amp;start=0&amp;ndsp=33&amp;ved=0CGYQrQMwFQ</a> approximation of beam 17250 units are in meter</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim_2d = 2;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> length = .7,</div><div class="line">             width = 80e-3,</div><div class="line">             height = 200e-3,</div><div class="line">             thickness_web = 10e-3,</div><div class="line">             thickness_flange = 10e-3;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim_2d&gt;</a> triangulation_b,</div><div class="line">              triangulation_t,</div><div class="line">              triangulation_l,</div><div class="line">              triangulation_r,</div><div class="line">              triangulation_2d;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1e-7 * width;</div></div><!-- fragment --><p>Make the triangulation_b, a rectangular at the bottom of rectangular tube</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point1 (-width/2, -height/2),</div><div class="line">        point2 (width/2, -(height/2)+thickness_flange);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(dim_2d);</div><div class="line">  repetitions[0] = 8;</div><div class="line">  repetitions[1] = 1;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation_b, repetitions, point1, point2);</div><div class="line">}</div></div><!-- fragment --><p>Make the triangulation_t, a rectangular at the top of rectangular tube</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point1 (-width/2, (height/2)-thickness_flange),</div><div class="line">        point2 (width/2, height/2);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(dim_2d);</div><div class="line">  repetitions[0] = 8;</div><div class="line">  repetitions[1] = 1;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation_t, repetitions, point1, point2);</div><div class="line">}</div></div><!-- fragment --><p>Make the triangulation_l, a rectangular at the left of rectangular tube</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point1 (-width/2, -(height/2)+thickness_flange),</div><div class="line">        point2 (-(width/2)+thickness_web, (height/2)-thickness_flange);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(dim_2d);</div><div class="line">  repetitions[0] = 1;</div><div class="line">  repetitions[1] = 18;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation_l, repetitions, point1, point2);</div><div class="line">}</div></div><!-- fragment --><p>Make the triangulation_r, a rectangular at the right of rectangular tube</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim_2d&gt;</a> point1 ((width/2)-thickness_web, -(height/2)+thickness_flange),</div><div class="line">        point2 (width/2, (height/2)-thickness_flange);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(dim_2d);</div><div class="line">  repetitions[0] = 1;</div><div class="line">  repetitions[1] = 18;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation_r, repetitions, point1, point2);</div><div class="line">}</div></div><!-- fragment --><p>make the triangulation_2d</p>
<div class="fragment"><div class="line">{</div></div><!-- fragment --><p>merging every two triangles to make triangulation_2d</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim_2d&gt;</a> triangulation_bl,</div><div class="line">                triangulation_blr;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a>(triangulation_b, triangulation_l, triangulation_bl);</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a>(triangulation_bl, triangulation_r, triangulation_blr);</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a>(triangulation_blr, triangulation_t, triangulation_2d);</div><div class="line">}</div></div><!-- fragment --><p>Extrude the triangulation_2d and make it 3d</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_slices = length*1000/20 + 1;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">extrude_triangulation</a>(triangulation_2d,</div><div class="line">                      n_slices, length, triangulation);</div></div><!-- fragment --><p>Assign boundary indicators to the boundary faces</p>
<div class="fragment"><div class="line">      / *</div><div class="line">       *</div><div class="line">       *                     A</div><div class="line">       *            ---------*----------</div><div class="line">       *           /                   /|</div><div class="line">       *          /                   / |</div><div class="line">       *         /                   /  |</div><div class="line">       *        /       2    length /   |</div><div class="line">       *       /                   /    |</div><div class="line">       *      /                   /     |</div><div class="line">       *     /                   /      |</div><div class="line">       *    /        width      /       |</div><div class="line">       *    --------------------        |</div><div class="line">       *    | --------1-------. |       |</div><div class="line">       *    | :               : |       |</div><div class="line">       *    | :               : |h      |</div><div class="line">       *    | :      y   z    : |e      |</div><div class="line">       *    | :       | /     : |i     /</div><div class="line">       *    |1:       |___ x  :1|g    /</div><div class="line">       *    | :               : |h   /</div><div class="line">       *    | :               : |t  /</div><div class="line">       *    | :               : |  /</div><div class="line">       *    | :               : | /</div><div class="line">       *    | ----------------- |/</div><div class="line">       *    ---------1----------/</div><div class="line">       *</div><div class="line">       *   face id:</div><div class="line">       *   Essential boundary condition:</div><div class="line">       *   1: z = 0: clamped, fixed in x, y and z directions</div><div class="line">       *   Natural/Newmann boundary condition:</div><div class="line">       *   2: y = height/2: traction face: pressure on the surface</div><div class="line">       *   Quantity of interest:</div><div class="line">       *   displacement at <a class="code" href="classPoint.html">Point</a> A (x=0, y=height/2, z=length)</div><div class="line">       * /</div><div class="line">      {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> dist_vector;</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center(0, 0, 0);</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">        endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">                  {</div><div class="line">                    dist_vector = cell-&gt;face(f)-&gt;center() - center;</div><div class="line"></div><div class="line">                    <span class="keywordflow">if</span> ( std::fabs(dist_vector(2)) &lt; eps )</div><div class="line">                      {</div><div class="line">                        cell-&gt;face(f)-&gt;set_boundary_indicator(1);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( std::fabs(dist_vector(1)-(height/2)) &lt; eps )</div><div class="line">                      {</div><div class="line">                        cell-&gt;face(f)-&gt;set_boundary_indicator(2);</div><div class="line">                      }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                      {</div><div class="line">                        cell-&gt;face(f)-&gt;set_all_boundary_indicators(0);</div><div class="line">                      }</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Number of active cells:       &quot;</span></div><div class="line">        &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsetup_system"></a> </p><h4>PlasticityContactProblem::setup_system</h4>
<p>The next piece in the puzzle is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, resize vectors and take care of various other status variables such as index sets and constraint matrices.</p>
<p>In the following, each group of operations is put into a brace-enclosed block that is being timed by the variable declared at the top of the block (the constructor of the <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable starts the timed section, the destructor that is called at the end of the block stops it again).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  / * setup dofs and <span class="keyword">get</span> index sets <span class="keywordflow">for</span> locally owned and relevant dofs * /</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">    locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">    <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                            locally_relevant_dofs);</div><div class="line">  }</div><div class="line"></div><div class="line">  / * setup hanging nodes and Dirichlet constraints * /</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">    constraints_hanging_nodes.<a class="code" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            constraints_hanging_nodes);</div><div class="line">    constraints_hanging_nodes.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    compute_dirichlet_constraints();</div><div class="line">  }</div><div class="line"></div><div class="line">  / * initialization of vectors* /</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (timestep_no==1 || current_refinement_cycle!=0)</div><div class="line">      {</div><div class="line">        solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(locally_relevant_dofs, mpi_communicator);</div><div class="line">      }</div><div class="line">    incremental_displacement.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">    newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    newton_rhs_residual.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    fraction_of_plastic_q_points_per_cell.reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we set up sparsity patterns and matrices. We temporarily (ab)use the system matrix to also build the (diagonal) matrix that we use in eliminating degrees of freedom that are in contact with the obstacle, but we then immediately set the Newton matrix back to zero.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler, sp,</div><div class="line">                                    constraints_dirichlet_and_hanging_nodes, <span class="keyword">false</span>,</div><div class="line">                                    this_mpi_process);</div><div class="line">    sp.compress();</div><div class="line">    newton_matrix.reinit(sp);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_dirichlet_constraints"></a> </p><h4>PlasticityContactProblem::compute_dirichlet_constraints</h4>
<p>This function, broken out of the preceding one, computes the constraints associated with Dirichlet-type boundary conditions and puts them into the <code>constraints_dirichlet_and_hanging_nodes</code> variable by merging with the constraints that come from hanging nodes.</p>
<p>As laid out in the introduction, we need to distinguish between two cases:</p><ul>
<li>If the domain is a box, we set the displacement to zero at the bottom, and allow vertical movement in z-direction along the sides. As shown in the <code>make_grid()</code> function, the former corresponds to boundary indicator 6, the latter to 8.</li>
<li>If the domain is a half sphere, then we impose zero displacement along the curved part of the boundary, associated with boundary indicator zero.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::compute_dirichlet_constraints ()</div><div class="line">{</div><div class="line">  constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">  constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">  std::vector&lt;bool&gt; component_mask(dim);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                               constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">    {</div></div><!-- fragment --><p>the boundary x = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">true</span>;</div><div class="line">component_mask[1] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          2,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = 0</p>
<div class="fragment"><div class="line">    component_mask[0] = <span class="keyword">false</span>;</div><div class="line">    component_mask[1] = <span class="keyword">true</span>;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              3,</div><div class="line">                                              EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                              constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                              component_mask);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>the boundary x = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">true</span>;</div><div class="line">component_mask[1] = <span class="keyword">false</span>;</div><div class="line">component_mask[2] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          4,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = 0</p>
<div class="fragment"><div class="line">component_mask[0] = <span class="keyword">false</span>;</div><div class="line">component_mask[1] = <span class="keyword">true</span>;</div><div class="line">component_mask[2] = <span class="keyword">false</span>;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          1,</div><div class="line">                                          EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                          constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                          component_mask);</div></div><!-- fragment --><p>the boundary y = imposed incremental displacement</p>
<div class="fragment"><div class="line">    component_mask[0] = <span class="keyword">false</span>;</div><div class="line">    component_mask[1] = <span class="keyword">true</span>;</div><div class="line">    component_mask[2] = <span class="keyword">false</span>;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              3,</div><div class="line">                                              EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                              constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                              component_mask);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>the boundary x = y = z = 0</p>
<div class="fragment"><div class="line">      component_mask[0] = <span class="keyword">true</span>;</div><div class="line">      component_mask[1] = <span class="keyword">true</span>;</div><div class="line">      component_mask[2] = <span class="keyword">true</span>;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                1,</div><div class="line">                                                EquationData::IncrementalBoundaryValues&lt;dim&gt;(present_time, end_time),</div><div class="line">                                                constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                                component_mask);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_newton_system"></a> </p><h4>PlasticityContactProblem::assemble_newton_system</h4>
<p>Given the complexity of the problem, it may come as a bit of a surprise that assembling the linear system we have to solve in each Newton iteration is actually fairly straightforward. The following function builds the Newton right hand side and Newton matrix. It looks fairly innocent because the heavy lifting happens in the call to <code>ConstitutiveLaw::get_linearized_stress_strain_tensors()</code> and in particular in <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a>, using the constraints we have previously computed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::</div><div class="line">assemble_newton_system (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;delta_linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> traction_surface_id;</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 5;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe, face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BodyForce&lt;dim&gt;     body_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt;           body_force_values(n_q_points,</div><div class="line">                                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::</div><div class="line">  IncrementalBoundaryForce&lt;dim&gt;          boundary_force(present_time, end_time);</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt;           boundary_force_values(n_face_q_points,</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                     cell_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                         cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt;   local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>std::vector&lt;<a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &gt; strain_tensor(n_q_points);</p>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; incremental_strain_tensor(n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      fe_values[displacement].get_function_symmetric_gradients(delta_linearization_point,</div><div class="line">                                                               incremental_strain_tensor);</div></div><!-- fragment --><p>For assembling the local right hand side contributions, we need to access the prior linearized stress value in this quadrature point. To get it, we use the user pointer of this cell that points into the global array to the quadrature point data corresponding to the first quadrature point of the present cell, and then add an offset corresponding to the index of the quadrature point we presently consider:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">  = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">        &amp;quadrature_point_history.front(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">        &amp;quadrature_point_history.back(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>In addition, we need the values of the external body forces at the quadrature points on this cell:</p>
<div class="fragment"><div class="line">body_force.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             body_force_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tmp_strain_tensor_qpoint;</div><div class="line">    tmp_strain_tensor_qpoint = local_quadrature_points_history[q_point].old_strain</div><div class="line">                               + incremental_strain_tensor[q_point];</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">    constitutive_law.get_linearized_stress_strain_tensors(tmp_strain_tensor_qpoint,</div><div class="line">                                                          stress_strain_tensor_linearized,</div><div class="line">                                                          stress_strain_tensor);</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values_body_force;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        rhs_values_body_force[i] = body_force_values[q_point][i];</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div></div><!-- fragment --><p>Having computed the stress-strain tensor and its linearization, we can now put together the parts of the matrix and right hand side. In both, we need the linearized stress-strain tensor times the symmetric gradient of <img class="formulaInl" alt="$\varphi_i$" src="form_531.png"/>, i.e. the term <img class="formulaInl" alt="$I_\Pi\varepsilon(\varphi_i)$" src="form_3439.png"/>, so we introduce an abbreviation of this term. Recall that the matrix corresponds to the bilinear form <img class="formulaInl" alt="$A_{ij}=(I_\Pi\varepsilon(\varphi_i),\varepsilon(\varphi_j))$" src="form_3440.png"/> in the notation of the accompanying publication, whereas the right hand side is <img class="formulaInl" alt="$F_i=([I_\Pi-P_\Pi C]\varepsilon(\varphi_i),\varepsilon(\mathbf u))$" src="form_3441.png"/> where <img class="formulaInl" alt="$u$" src="form_256.png"/> is the current linearization points (typically the last solution). This might suggest that the right hand side will be zero if the material is completely elastic (where <img class="formulaInl" alt="$I_\Pi=P_\Pi$" src="form_3442.png"/>) but this ignores the fact that the right hand side will also contain contributions from non-homogeneous constraints due to the contact.</p>
<p>The code block that follows this adds contributions that are due to boundary forces, should there be any.</p>
<div class="fragment"><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">                stress_phi_i = stress_strain_tensor_linearized</div><div class="line">                               * fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  cell_matrix(i, j) += (stress_phi_i</div><div class="line">                                        * fe_values[displacement].symmetric_gradient(j, q_point)</div><div class="line">                                        * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                cell_rhs(i) += (</div><div class="line">                                 ( stress_phi_i</div><div class="line">                                   * incremental_strain_tensor[q_point] )</div><div class="line">                                 -</div><div class="line">                                 ( ( stress_strain_tensor</div><div class="line">                                     * fe_values[displacement].symmetric_gradient(i, q_point))</div><div class="line">                                   * tmp_strain_tensor_qpoint )</div><div class="line">                                 +</div><div class="line">                                 ( fe_values[displacement].value(i, q_point)</div><div class="line">                                   * rhs_values_body_force )</div><div class="line">                               ) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">              &amp;&amp;</div><div class="line">              cell-&gt;face(face)-&gt;boundary_indicator() == traction_surface_id)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(fe_values_face.get_quadrature_points(),</div><div class="line">                                               boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">                    {</div><div class="line">                      rhs_values[i] = boundary_force_values[q_point][i];</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) += (fe_values_face[displacement].value(i, q_point)</div><div class="line">                                    * rhs_values</div><div class="line">                                    * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(cell_matrix, cell_rhs,</div><div class="line">            local_dof_indices,</div><div class="line">            newton_matrix,</div><div class="line">            newton_rhs,</div><div class="line">            <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_nonlinear_residual"></a> </p><h4>PlasticityContactProblem::compute_nonlinear_residual</h4>
<p>The following function computes the nonlinear residual of the equation given the current solution (or any other linearization point). This is needed in the linear search algorithm where we need to try various linear combinations of previous and current (trial) solution to compute the (real, globalized) solution of the current Newton step.</p>
<p>That said, in a slight abuse of the name of the function, it actually does significantly more. For example, it also computes the vector that corresponds to the Newton residual but without eliminating constrained degrees of freedom. We need this vector to compute contact forces and, ultimately, to compute the next active set. Likewise, by keeping track of how many quadrature points we encounter on each cell that show plastic yielding, we also compute the <code>fraction_of_plastic_q_points_per_cell</code> vector that we can later output to visualize the plastic zone. In both of these cases, the results are not necessary as part of the line search, and so we may be wasting a small amount of time computing them. At the same time, this information appears as a natural by-product of what we need to do here anyway, and we want to collect it once at the end of each Newton step, so we may as well do it here.</p>
<p>The actual implementation of this function should be rather obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::</div><div class="line">compute_nonlinear_residual (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> traction_surface_id;</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 5;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">    {</div><div class="line">      traction_surface_id = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe, face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BodyForce&lt;dim&gt;     body_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt;           body_force_values(n_q_points,</div><div class="line">                                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::</div><div class="line">  IncrementalBoundaryForce&lt;dim&gt;          boundary_force(present_time, end_time);</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt;           boundary_force_values(n_face_q_points,</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  newton_rhs_residual = 0;</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_number = 0;</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_number)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensors(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(linearization_point,</div><div class="line">                                                                 strain_tensors);</div><div class="line"></div><div class="line">        body_force.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                     body_force_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> q_point_is_plastic</div><div class="line">              = constitutive_law.get_stress_strain_tensor(strain_tensors[q_point],</div><div class="line">                                                          stress_strain_tensor);</div><div class="line">            <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">              ++fraction_of_plastic_q_points_per_cell(cell_number);</div><div class="line"></div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values_body_force;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              {</div><div class="line">                rhs_values_body_force[i] = body_force_values[q_point][i];</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                cell_rhs(i) += (fe_values[displacement].value(i, q_point)</div><div class="line">                                * rhs_values_body_force</div><div class="line">                                -</div><div class="line">                                strain_tensors[q_point]</div><div class="line">                                * stress_strain_tensor</div><div class="line">                                * fe_values[displacement].symmetric_gradient(i, q_point)</div><div class="line">                               )</div><div class="line">                               * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                rhs_values = 0;</div><div class="line">                cell_rhs(i) += (fe_values[displacement].value(i, q_point)</div><div class="line">                                * rhs_values</div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0; face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">              &amp;&amp; cell-&gt;face(face)-&gt;boundary_indicator() == traction_surface_id)</div><div class="line">            {</div><div class="line">              fe_values_face.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(fe_values_face.get_quadrature_points(),</div><div class="line">                                               boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">                    {</div><div class="line">                      rhs_values[i] = boundary_force_values[q_point][i];</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) += (fe_values_face[displacement].value(i, q_point) * rhs_values</div><div class="line">                                    * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(cell_rhs,</div><div class="line">            local_dof_indices,</div><div class="line">            newton_rhs_residual);</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  newton_rhs_residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton_system"></a> </p><h4>PlasticityContactProblem::solve_newton_system</h4>
<p>The last piece before we can discuss the actual Newton iteration on a single mesh is the solver for the linear systems. There are a couple of complications that slightly obscure the code, but mostly it is just setup then solve. Among the complications are:</p>
<ul>
<li>For the hanging nodes we have to apply the <a class="el" href="classConstraintMatrix.html#a5a4f1186dc10d707b933b6ff24f7cad8">ConstraintMatrix::set_zero</a> function to newton_rhs. This is necessary if a hanging node with solution value <img class="formulaInl" alt="$x_0$" src="form_32.png"/> has one neighbor with value <img class="formulaInl" alt="$x_1$" src="form_1006.png"/> which is in contact with the obstacle and one neighbor <img class="formulaInl" alt="$x_2$" src="form_29.png"/> which is not in contact. Because the update for the former will be prescribed, the hanging node constraint will have an inhomogeneity and will look like <img class="formulaInl" alt="$x_0 = x_1/2 + \text{gap}/2$" src="form_3443.png"/>. So the corresponding entries in the ride-hang-side are non-zero with a meaningless value. These values we have to to set to zero.</li>
<li>Like in <a class="el" href="step_40.html">step-40</a>, we need to shuffle between vectors that do and do do not have ghost elements when solving or using the solution.</li>
</ul>
<p>The rest of the function is similar to <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> except that we use a BiCGStab solver instead of CG. This is due to the fact that for very small hardening parameters <img class="formulaInl" alt="$\gamma$" src="form_932.png"/>, the linear system becomes almost semidefinite though still symmetric. BiCGStab appears to have an easier time with such linear systems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::solve_newton_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs, mpi_communicator);</div><div class="line">  distributed_solution = incremental_displacement;</div><div class="line"></div><div class="line">  constraints_hanging_nodes.<a class="code" href="classConstraintMatrix.html#a5a4f1186dc10d707b933b6ff24f7cad8">set_zero</a>(distributed_solution);</div><div class="line">  constraints_hanging_nodes.<a class="code" href="classConstraintMatrix.html#a5a4f1186dc10d707b933b6ff24f7cad8">set_zero</a>(newton_rhs);</div></div><!-- fragment --><p>----&mdash; <a class="el" href="classSolver.html">Solver</a> Bicgstab &mdash; Preconditioner AMG ----------------&mdash; <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a> preconditioner; { <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Solve: setup preconditioner");</p>
<p>std::vector&lt;std::vector&lt;bool&gt; &gt; constant_modes; <a class="el" href="namespaceDoFTools.html#a195771d57320e298e232e3b4aa922ff8">DoFTools::extract_constant_modes</a>(dof_handler, <a class="el" href="classComponentMask.html">ComponentMask()</a>, constant_modes);</p>
<p><a class="el" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data; additional_data.constant_modes = constant_modes; additional_data.elliptic = true; additional_data.n_cycles = 1; additional_data.w_cycle = false; additional_data.output_details = false; additional_data.smoother_sweeps = 2; additional_data.aggregation_threshold = 1e-2;</p>
<p>preconditioner.initialize(newton_matrix, additional_data); }</p>
<p>{ <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, "Solve: iterate");</p>
<p><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</p>
<p>// const double relative_accuracy = 1e-8; const double relative_accuracy = 1e-2; const double solver_tolerance = relative_accuracy</p><ul>
<li>newton_matrix.residual(tmp, distributed_solution, newton_rhs);</li>
</ul>
<p><a class="el" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance); SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt; solver(solver_control); solver.solve(newton_matrix, distributed_solution, newton_rhs, preconditioner);</p>
<p>pcout &lt;&lt; "         Error: " &lt;&lt; solver_control.initial_value() &lt;&lt; " -&gt; " &lt;&lt; solver_control.last_value() &lt;&lt; " in " &lt;&lt; solver_control.last_step() &lt;&lt; " Bicgstab iterations." &lt;&lt; std::endl; }</p>
<p>----&mdash; <a class="el" href="classSolver.html">Solver</a> CG &mdash; Preconditioner SSOR ----------------&mdash;</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1PreconditionSSOR.html">TrilinosWrappers::PreconditionSSOR</a> preconditioner;</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionSSOR_1_1AdditionalData.html">TrilinosWrappers::PreconditionSSOR::AdditionalData</a> additional_data;</div><div class="line">  preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionSSOR.html#a4d906893c6a1ae3c071c6a23abbdeeb1">initialize</a>(newton_matrix, additional_data);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div></div><!-- fragment --><p>const double relative_accuracy = 1e-8;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-2;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance  = relative_accuracy</div><div class="line">                                 * newton_matrix.residual(tmp, distributed_solution,</div><div class="line">                                                          newton_rhs);</div></div><!-- fragment --><p><a class="el" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(10*newton_matrix.m(),</div><div class="line">                               solver_tolerance);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">  solver.solve(newton_matrix, distributed_solution,</div><div class="line">               newton_rhs, preconditioner);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">        &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>........................................................</p>
<div class="fragment"><div class="line">  constraints_dirichlet_and_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">  incremental_displacement = distributed_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton"></a> </p><h4>PlasticityContactProblem::solve_newton</h4>
<p>This is, finally, the function that implements the damped Newton method on the current mesh. There are two nested loops: the outer loop for the Newton iteration and the inner loop for the line search which will be used only if necessary. To obtain a good and reasonable starting value we solve an elastic problem in very first Newton step on each mesh (or only on the first mesh if we transfer solutions between meshes). We do so by setting the yield stress to an unreasonably large value in these iterations and then setting it back to the correct value in subsequent iterations.</p>
<p>Other than this, the top part of this function should be reasonably obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::solve_newton ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(locally_relevant_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_solution(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> residual_norm;</div><div class="line">  <span class="keywordtype">double</span> previous_residual_norm = -std::numeric_limits&lt;double&gt;::max();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> disp_norm,</div><div class="line">         previous_disp_norm = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_newton_iter = 100;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= max_newton_iter; ++newton_step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (newton_step == 1</div><div class="line">          &amp;&amp;</div><div class="line">          ((transfer_solution &amp;&amp; timestep_no == 1)</div><div class="line">           ||</div><div class="line">           !transfer_solution))</div><div class="line">        constitutive_law.set_sigma_0(1e+10);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      newton_matrix       = 0;</div><div class="line">      newton_rhs          = 0;</div><div class="line">      newton_rhs_residual = 0;</div><div class="line"></div><div class="line">      tmp_solution = solution;</div><div class="line">      tmp_solution += incremental_displacement;</div><div class="line">      assemble_newton_system(tmp_solution,</div><div class="line">                             incremental_displacement);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      solve_newton_system();</div></div><!-- fragment --><p>It gets a bit more hairy after we have computed the trial solution <img class="formulaInl" alt="$\tilde{\mathbf u}$" src="form_3444.png"/> of the current Newton step. We handle a highly nonlinear problem so we have to damp Newton's method using a line search. To understand how we do this, recall that in our formulation, we compute a trial solution in each Newton step and not the update between old and new solution. Since the solution set is a convex set, we will use a line search that tries linear combinations of the previous and the trial solution to guarantee that the damped solution is in our solution set again. At most we apply 5 damping steps.</p>
<p>There are exceptions to when we use a line search. First, if this is the first Newton step on any mesh, then we don't have any point to compare the residual to, so we always accept a full step. Likewise, if this is the second Newton step on the first mesh (or the second on any mesh if we don't transfer solutions from mesh to mesh), then we have computed the first of these steps using just an elastic model (see how we set the yield stress sigma to an unreasonably large value above). In this case, the first Newton solution was a purely elastic one, the second one a plastic one, and any linear combination would not necessarily be expected to lie in the feasible set &ndash; so we just accept the solution we just got.</p>
<p>In either of these two cases, we bypass the line search and just update residual and other vectors as necessary.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((newton_step==1)</div><div class="line">    ||</div><div class="line">    (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp; current_refinement_cycle == 0)</div><div class="line">    ||</div><div class="line">    (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">  {</div><div class="line">    tmp_solution = solution;</div><div class="line">    tmp_solution += incremental_displacement;</div><div class="line">    compute_nonlinear_residual(tmp_solution);</div><div class="line">    old_solution = incremental_displacement;</div><div class="line"></div><div class="line">    residual = newton_rhs_residual;</div><div class="line"></div><div class="line">    residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">          &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; i++)</div><div class="line">      {</div><div class="line">        distributed_solution = incremental_displacement;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = std::pow(0.5, static_cast&lt;double&gt;(i));</div><div class="line">        tmp_vector = old_solution;</div><div class="line">        tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">        locally_relevant_tmp_vector = tmp_vector;</div><div class="line">        tmp_solution = solution;</div><div class="line">        tmp_solution += locally_relevant_tmp_vector;</div><div class="line">        compute_nonlinear_residual(tmp_solution);</div><div class="line">        residual = newton_rhs_residual;</div><div class="line"></div><div class="line">        residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">        residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Residual of the system: &quot;</span></div><div class="line">              &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    incremental_displacement = tmp_vector;</div><div class="line">    old_solution = incremental_displacement;</div><div class="line">  }</div><div class="line"></div><div class="line">disp_norm = incremental_displacement.l2_norm();</div></div><!-- fragment --><p>The final step is to check for convergence. If the residual is less than a threshold of <img class="formulaInl" alt="$10^{-10}$" src="form_3445.png"/>, then we terminate the iteration on the current mesh: if (residual_norm &lt; 1e-10)</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (residual_norm &lt; 1e-7)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;    difference of two consecutive incremental displacement l2 norm : &quot;</span></div><div class="line">            &lt;&lt; std::abs(disp_norm - previous_disp_norm) &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">if</span> ( std::abs(disp_norm - previous_disp_norm) &lt; 1e-10 &amp;&amp;</div><div class="line">           (residual_norm &lt; 1e-5 || std::abs(residual_norm - previous_residual_norm)&lt;1e-9) )</div><div class="line">        {</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot; Convergence by difference of two consecutive solution! &quot;</span> &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      previous_residual_norm = residual_norm;</div><div class="line">      previous_disp_norm = disp_norm;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_error"></a> </p><h4>PlasticityContactProblem::compute_error</h4>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::compute_error ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>   tmp_solution(locally_owned_dofs, mpi_communicator);</div><div class="line">  tmp_solution = solution;</div><div class="line">  tmp_solution += incremental_displacement;</div><div class="line"></div><div class="line">  estimated_error_per_cell.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">if</span> (error_estimation_strategy == ErrorEstimationStrategy::kelly_error)</div><div class="line">    {</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                         <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                         tmp_solution,</div><div class="line">                                         estimated_error_per_cell);</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_estimation_strategy == ErrorEstimationStrategy::residual_error)</div><div class="line">    {</div><div class="line">      compute_error_residual(tmp_solution);</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_estimation_strategy == ErrorEstimationStrategy::weighted_residual_error)</div><div class="line">    {</div></div><!-- fragment --><p>make a non-parallel copy of tmp_solution</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> copy_solution(tmp_solution);</div></div><!-- fragment --><p>the dual function definition (it should be defined previously, e.g. input file)</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> length = .48,</div><div class="line">           depth  = .12;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point(length, -depth/2);</div><div class="line"></div><div class="line">    DualFunctional::PointValuesEvaluation&lt;dim&gt; dual_functional(evaluation_point);</div><div class="line"></div><div class="line">    DualSolver&lt;dim&gt; dual_solver(triangulation, fe,</div><div class="line">                                copy_solution,</div><div class="line">                                constitutive_law, dual_functional,</div><div class="line">                                timestep_no, output_dir, base_mesh,</div><div class="line">                                present_time, end_time);</div><div class="line"></div><div class="line">    dual_solver.compute_error_DWR (estimated_error_per_cell);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id = 0;</div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt; &gt; comp_stress(dim);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        comp_stress[i].resize(dim);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            comp_stress[i][j] = 1;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    DualFunctional::MeanStressFace&lt;dim&gt; dual_functional(face_id, comp_stress);</div><div class="line"></div><div class="line">    DualSolver&lt;dim&gt; dual_solver(triangulation, fe,</div><div class="line">                                copy_solution,</div><div class="line">                                constitutive_law, dual_functional,</div><div class="line">                                timestep_no, output_dir, base_mesh,</div><div class="line">                                present_time, end_time);</div><div class="line"></div><div class="line">    dual_solver.compute_error_DWR (estimated_error_per_cell);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>......................................... Mean stress_yy over the bottom boundary</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id = 1;</div><div class="line">std::vector&lt;std::vector&lt;unsigned int&gt; &gt; comp_stress(dim);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    comp_stress[i].resize(dim);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">      {</div><div class="line">        comp_stress[i][j] = 0;</div><div class="line">      }</div><div class="line">  }</div><div class="line">comp_stress[1][1] = 1;</div><div class="line"></div><div class="line">DualFunctional::MeanStressFace&lt;dim&gt; dual_functional(face_id, comp_stress);</div></div><!-- fragment --><p>.........................................</p>
<div class="fragment"><div class="line">    DualSolver&lt;dim&gt; dual_solver(triangulation, fe,</div><div class="line">                                copy_solution,</div><div class="line">                                constitutive_law, dual_functional,</div><div class="line">                                timestep_no, output_dir, base_mesh,</div><div class="line">                                present_time, end_time);</div><div class="line"></div><div class="line">    dual_solver.compute_error_DWR (estimated_error_per_cell);</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><h2>Quantity of interest: </h2>
<p>displacement at <a class="el" href="classPoint.html">Point</a> A (x=0, y=height/2, z=length)</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> length = .7,</div><div class="line">             height = 200e-3;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point(0, height/2, length);</div><div class="line"></div><div class="line">DualFunctional::PointValuesEvaluation&lt;dim&gt; dual_functional(evaluation_point);</div><div class="line">* /</div></div><!-- fragment --> <hr/>
<p> Mean stress at the specified domain is of interest. The interest domains are located on the bottom and top of the flanges close to the clamped face, z = 0 top domain: height/2 - thickness_flange &lt;= y &lt;= height/2 0 &lt;= z &lt;= 2 * thickness_flange bottom domain: -height/2 &lt;= y &lt;= -height/2 + thickness_flange 0 &lt;= z &lt;= 2 * thickness_flange</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;unsigned int&gt; &gt; comp_stress(dim);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    comp_stress[i].resize(dim);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">      {</div><div class="line">        comp_stress[i][j] = 1;</div><div class="line">      }</div><div class="line">  }</div><div class="line">DualFunctional::MeanStressDomain&lt;dim&gt; dual_functional(base_mesh, comp_stress);</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">          DualSolver&lt;dim&gt; dual_solver(triangulation, fe,</div><div class="line">                                      copy_solution,</div><div class="line">                                      constitutive_law, dual_functional,</div><div class="line">                                      timestep_no, output_dir, base_mesh,</div><div class="line">                                      present_time, end_time);</div><div class="line"></div><div class="line">          dual_solver.compute_error_DWR (estimated_error_per_cell);</div><div class="line"></div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  relative_error = estimated_error_per_cell.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() / tmp_solution.l2_norm();</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Estimated relative error = &quot;</span> &lt;&lt; relative_error &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::compute_error_residual (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;tmp_solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>  |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_q_points);</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a>          stress_strain_tensor_grad;</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;2,dim&gt; &gt; &gt; cell_hessians (n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_q_points; ++i)</div><div class="line">    {</div><div class="line">      cell_hessians[i].resize (dim);</div><div class="line">    }</div><div class="line">  <span class="keyword">const</span> EquationData::BodyForce&lt;dim&gt; body_force;</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; body_force_values (n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_cell(fe, face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>           |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>        |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>       |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>),</div><div class="line">                                        fe_face_values_neighbor (fe, face_quadrature_formula,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>     |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>  |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_subface_values_cell (fe, face_quadrature_formula,</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; jump_residual (n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt; cell_grads(n_face_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_face_q_points; ++i)</div><div class="line">    {</div><div class="line">      cell_grads[i].resize (dim);</div><div class="line">    }</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt; neighbor_grads(n_face_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=n_face_q_points; ++i)</div><div class="line">    {</div><div class="line">      neighbor_grads[i].resize (dim);</div><div class="line">    }</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> q_cell_strain_tensor;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> q_neighbor_strain_tensor;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> cell_stress_strain_tensor;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> neighbor_stress_strain_tensor;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> std::map&lt;typename DoFHandler&lt;dim&gt;::face_iterator, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">  face_integrals;</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">             face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_no)</div><div class="line">          {</div><div class="line">            face_integrals[cell-&gt;face(face_no)].reinit (dim);</div><div class="line">            face_integrals[cell-&gt;face(face_no)] = -1e20;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;float&gt; &gt; error_indicators_vector;</div><div class="line">  error_indicators_vector.resize( triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(),</div><div class="line">                                  <a class="code" href="classVector.html">Vector&lt;float&gt;</a>(dim) );</div></div><!-- fragment --><p>--------------&mdash; estimate_some ----------------------&mdash;</p>
<div class="fragment"><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> present_cell = 0;</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++present_cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div></div><!-- fragment --><p>------------&mdash; integrate_over_cell ----------------&mdash;</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">body_force.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             body_force_values);</div><div class="line">fe_values[displacement].get_function_symmetric_gradients(tmp_solution,</div><div class="line">                                                         strain_tensor);</div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians</a>(tmp_solution, cell_hessians);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    constitutive_law.get_linearized_stress_strain_tensors(strain_tensor[q_point],</div><div class="line">                                                          stress_strain_tensor_linearized,</div><div class="line">                                                          stress_strain_tensor);</div><div class="line">    constitutive_law.get_grad_stress_strain_tensor(strain_tensor[q_point],</div><div class="line">                                                   cell_hessians[q_point],</div><div class="line">                                                   stress_strain_tensor_grad);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        error_indicators_vector[present_cell](i) +=</div><div class="line">          body_force_values[q_point](i)*fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                  {</div><div class="line">                    error_indicators_vector[present_cell](i) +=</div><div class="line">                      ( stress_strain_tensor[i][j][k][l]*</div><div class="line">                        0.5*(cell_hessians[q_point][k][l][j]</div><div class="line">                             +</div><div class="line">                             cell_hessians[q_point][l][k][j])</div><div class="line">                        + stress_strain_tensor_grad[i][j][k][l][j] * strain_tensor[q_point][k][l]</div><div class="line">                      ) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  }</div></div><!-- fragment --> <hr/>
<p> compute face_integrals</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">     face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face_no)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dim; ++id)</div><div class="line">          {</div><div class="line">            face_integrals[cell-&gt;face(face_no)](id) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">        (cell-&gt;neighbor(face_no)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">        (cell-&gt;neighbor(face_no)-&gt;index() &lt; cell-&gt;index()))</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no) == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;level() &lt; cell-&gt;level())</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>----------&mdash; integrate_over_regular_face --------&mdash;</p>
<div class="fragment"><div class="line">fe_face_values_cell.reinit(cell, face_no);</div><div class="line">fe_face_values_cell.get_function_grads (tmp_solution,</div><div class="line">                                        cell_grads);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">neighbor_neighbor = cell-&gt;neighbor_of_neighbor (face_no);</div><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">neighbor = cell-&gt;neighbor(face_no);</div><div class="line"></div><div class="line">fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);</div><div class="line">fe_face_values_neighbor.get_function_grads (tmp_solution,</div><div class="line">                                            neighbor_grads);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    q_cell_strain_tensor = 0.;</div><div class="line">    q_neighbor_strain_tensor = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            q_cell_strain_tensor[i][j] = 0.5*(cell_grads[q_point][i][j] +</div><div class="line">                                              cell_grads[q_point][j][i] );</div><div class="line">            q_neighbor_strain_tensor[i][j] = 0.5*(neighbor_grads[q_point][i][j] +</div><div class="line">                                                  neighbor_grads[q_point][j][i] );</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    constitutive_law.get_stress_strain_tensor (q_cell_strain_tensor,</div><div class="line">                                               cell_stress_strain_tensor);</div><div class="line">    constitutive_law.get_stress_strain_tensor (q_neighbor_strain_tensor,</div><div class="line">                                               neighbor_stress_strain_tensor);</div><div class="line"></div><div class="line">    jump_residual[q_point] = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                  {</div><div class="line">                    jump_residual[q_point](i) += (cell_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                  q_cell_strain_tensor[k][l]</div><div class="line">                                                  -</div><div class="line">                                                  neighbor_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                  q_neighbor_strain_tensor[k][l] )*</div><div class="line">                                                 fe_face_values_cell.normal_vector(q_point)[j];</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> face_integral_vector(dim);</div><div class="line">face_integral_vector = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        face_integral_vector(i) += jump_residual[q_point](i) *</div><div class="line">                                   fe_face_values_cell.JxW(q_point);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals.find (cell-&gt;face(face_no)) != face_integrals.end(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals[cell-&gt;face(face_no)](i) == -1e20,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    face_integrals[cell-&gt;face(face_no)](i) = face_integral_vector(i);</div><div class="line"></div><div class="line">  }</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>----------&mdash; integrate_over_irregular_face ------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a></div><div class="line">face = cell-&gt;face(face_no);</div><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a></div><div class="line">neighbor = cell-&gt;neighbor(face_no);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor-&gt;has_children(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">neighbor_neighbor = cell-&gt;neighbor_of_neighbor (face_no);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">     subface_no&lt;face-&gt;n_children(); ++subface_no)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    neighbor_child = cell-&gt;neighbor_child_on_subface (face_no, subface_no);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_child-&gt;face(neighbor_neighbor) ==</div><div class="line">            cell-&gt;face(face_no)-&gt;child(subface_no),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    fe_subface_values_cell.reinit (cell, face_no, subface_no);</div><div class="line">    fe_subface_values_cell.get_function_grads (tmp_solution,</div><div class="line">                                               cell_grads);</div><div class="line">    fe_face_values_neighbor.reinit (neighbor_child,</div><div class="line">                                    neighbor_neighbor);</div><div class="line">    fe_face_values_neighbor.get_function_grads (tmp_solution,</div><div class="line">                                                neighbor_grads);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        q_cell_strain_tensor = 0.;</div><div class="line">        q_neighbor_strain_tensor = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">              {</div><div class="line">                q_cell_strain_tensor[i][j] = 0.5*(cell_grads[q_point][i][j] +</div><div class="line">                                                  cell_grads[q_point][j][i] );</div><div class="line">                q_neighbor_strain_tensor[i][j] = 0.5*(neighbor_grads[q_point][i][j] +</div><div class="line">                                                      neighbor_grads[q_point][j][i] );</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        constitutive_law.get_stress_strain_tensor (q_cell_strain_tensor,</div><div class="line">                                                   cell_stress_strain_tensor);</div><div class="line">        constitutive_law.get_stress_strain_tensor (q_neighbor_strain_tensor,</div><div class="line">                                                   neighbor_stress_strain_tensor);</div><div class="line"></div><div class="line">        jump_residual[q_point] = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j!=dim; ++j)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k!=dim; ++k)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l!=dim; ++l)</div><div class="line">                      {</div><div class="line">                        jump_residual[q_point](i) += (-cell_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                      q_cell_strain_tensor[k][l]</div><div class="line">                                                      +</div><div class="line">                                                      neighbor_stress_strain_tensor[i][j][k][l]*</div><div class="line">                                                      q_neighbor_strain_tensor[k][l] )*</div><div class="line">                                                     fe_face_values_neighbor.normal_vector(q_point)[j];</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> face_integral_vector(dim);</div><div class="line">    face_integral_vector = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">          {</div><div class="line">            face_integral_vector(i) += jump_residual[q_point](i) *</div><div class="line">                                       fe_face_values_neighbor.JxW(q_point);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        face_integrals[neighbor_child-&gt;face(neighbor_neighbor)](i) = face_integral_vector(i);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> (dim);</div><div class="line">sum = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">     subface_no&lt;face-&gt;n_children(); ++subface_no)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals.find(face-&gt;child(subface_no)) !=</div><div class="line">            face_integrals.end(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (face_integrals[face-&gt;child(subface_no)](i) != -1e20,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>(i) += face_integrals[face-&gt;child(subface_no)](i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i!=dim; ++i)</div><div class="line">  {</div><div class="line">    face_integrals[face](i) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>(i);</div><div class="line">  }</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">  present_cell=0;</div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++present_cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_no)</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(face_integrals.find(cell-&gt;face(face_no)) !=</div><div class="line">                   face_integrals.end(),</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>!=dim; ++id)</div><div class="line">              {</div><div class="line">                error_indicators_vector[present_cell](id)</div><div class="line">                -= 0.5*face_integrals[cell-&gt;face(face_no)](id);</div><div class="line">              }</div><div class="line"></div><div class="line">          }</div><div class="line"></div><div class="line">        estimated_error_per_cell(present_cell) = error_indicators_vector[present_cell].l2_norm();</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrefine_grid"></a> </p><h4>PlasticityContactProblem::refine_grid</h4>
<p>If you've made it this far into the deal.II tutorial, the following function refining the mesh should not pose any challenges to you any more. It refines the mesh, either globally or using the Kelly error estimator, and if so asked also transfers the solution from the previous to the next mesh. In the latter case, we also need to compute the active set and other quantities again, for which we need the information computed by <code>compute_nonlinear_residual()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::refine_grid ()</div><div class="line">{</div></div><!-- fragment --> <hr/>
<p> Make a field variable for history varibales to be able to transfer the data to the quadrature points of the new mesh</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> history_fe (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> history_dof_handler (triangulation);</div><div class="line">history_dof_handler.distribute_dofs (history_fe);</div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_stress_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_values_at_qpoints (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_fe_values (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_strain_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_strain_values_at_qpoints (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_strain_fe_values (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      history_stress_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">      local_history_stress_values_at_qpoints[i][j].reinit(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line">      local_history_stress_fe_values[i][j].reinit(history_fe.dofs_per_cell);</div><div class="line"></div><div class="line">      history_strain_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">      local_history_strain_values_at_qpoints[i][j].reinit(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line">      local_history_strain_fe_values[i][j].reinit(history_fe.dofs_per_cell);</div><div class="line">    }</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> qpoint_to_dof_matrix (history_fe.dofs_per_cell,</div><div class="line">                                         quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line"><a class="code" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a></div><div class="line">(history_fe,</div><div class="line"> quadrature_formula, quadrature_formula,</div><div class="line"> qpoint_to_dof_matrix);</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">dg_cell = history_dof_handler.begin_active();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">        = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">              &amp;quadrature_point_history.front(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">              &amp;quadrature_point_history.back(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">              {</div><div class="line">                local_history_stress_values_at_qpoints[i][j](q)</div><div class="line">                  = local_quadrature_points_history[q].old_stress[i][j];</div><div class="line"></div><div class="line">                local_history_strain_values_at_qpoints[i][j](q)</div><div class="line">                  = local_quadrature_points_history[q].old_strain[i][j];</div><div class="line">              }</div><div class="line">            qpoint_to_dof_matrix.vmult (local_history_stress_fe_values[i][j],</div><div class="line">                                        local_history_stress_values_at_qpoints[i][j]);</div><div class="line">            dg_cell-&gt;set_dof_values (local_history_stress_fe_values[i][j],</div><div class="line">                                     history_stress_field[i][j]);</div><div class="line"></div><div class="line">            qpoint_to_dof_matrix.vmult (local_history_strain_fe_values[i][j],</div><div class="line">                                        local_history_strain_values_at_qpoints[i][j]);</div><div class="line">            dg_cell-&gt;set_dof_values (local_history_strain_fe_values[i][j],</div><div class="line">                                     history_strain_field[i][j]);</div><div class="line">          }</div><div class="line">    }</div></div><!-- fragment --> <hr/>
<p> Refine the mesh</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        cell-&gt;set_refine_flag ();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_fraction_cells = .3,</div><div class="line">                 coarsen_fraction_cells = .03;</div></div><!-- fragment --><p>const double refine_fraction_cells = .1, coarsen_fraction_cells = .3;</p>
<div class="fragment"><div class="line">    parallel::distributed::GridRefinement</div><div class="line">    ::refine_and_coarsen_fixed_number(triangulation,</div><div class="line">                                      estimated_error_per_cell,</div><div class="line">                                      refine_fraction_cells, coarsen_fraction_cells);</div><div class="line">  }</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">         <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt; solution_transfer(dof_handler);</div><div class="line">solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">         <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt; incremental_displacement_transfer(dof_handler);</div><div class="line"><span class="keywordflow">if</span> (transfer_solution)</div><div class="line">  incremental_displacement_transfer.prepare_for_coarsening_and_refinement(incremental_displacement);</div><div class="line"></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, Vector&lt;double&gt;</a> &gt; history_stress_field_transfer0(history_dof_handler),</div><div class="line">                 history_stress_field_transfer1(history_dof_handler),</div><div class="line">                 history_stress_field_transfer2(history_dof_handler);</div><div class="line">history_stress_field_transfer0.prepare_for_coarsening_and_refinement(history_stress_field[0]);</div><div class="line"><span class="keywordflow">if</span> ( dim &gt; 1)</div><div class="line">  {</div><div class="line">    history_stress_field_transfer1.prepare_for_coarsening_and_refinement(history_stress_field[1]);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> ( dim == 3)</div><div class="line">  {</div><div class="line">    history_stress_field_transfer2.prepare_for_coarsening_and_refinement(history_stress_field[2]);</div><div class="line">  }</div><div class="line"></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, Vector&lt;double&gt;</a> &gt; history_strain_field_transfer0(history_dof_handler),</div><div class="line">                 history_strain_field_transfer1(history_dof_handler),</div><div class="line">                 history_strain_field_transfer2(history_dof_handler);</div><div class="line">history_strain_field_transfer0.prepare_for_coarsening_and_refinement(history_strain_field[0]);</div><div class="line"><span class="keywordflow">if</span> ( dim &gt; 1)</div><div class="line">  {</div><div class="line">    history_strain_field_transfer1.prepare_for_coarsening_and_refinement(history_strain_field[1]);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> ( dim == 3)</div><div class="line">  {</div><div class="line">    history_strain_field_transfer2.prepare_for_coarsening_and_refinement(history_strain_field[2]);</div><div class="line">  }</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;    Number of active cells:       &quot;</span></div><div class="line">      &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">      &lt;&lt; std::endl;</div><div class="line"></div><div class="line">setup_system();</div><div class="line">setup_quadrature_point_history ();</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs, mpi_communicator);</div></div><!-- fragment --><p>distributed_solution = solution;</p>
<div class="fragment"><div class="line">solution_transfer.interpolate(distributed_solution);</div><div class="line">solution = distributed_solution;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (transfer_solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_incremental_displacement(locally_owned_dofs, mpi_communicator);</div></div><!-- fragment --><p>distributed_incremental_displacement = incremental_displacement;</p>
<div class="fragment"><div class="line">incremental_displacement_transfer.interpolate(distributed_incremental_displacement);</div><div class="line">incremental_displacement = distributed_incremental_displacement;</div></div><!-- fragment --><p>compute_nonlinear_residual(incremental_displacement);</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">history_dof_handler.distribute_dofs (history_fe);</div></div><!-- fragment --><p>stress</p>
<div class="fragment"><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">distributed_history_stress_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      distributed_history_stress_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line">history_stress_field_transfer0.interpolate(history_stress_field[0], distributed_history_stress_field[0]);</div><div class="line"><span class="keywordflow">if</span> ( dim &gt; 1)</div><div class="line">  {</div><div class="line">    history_stress_field_transfer1.interpolate(history_stress_field[1], distributed_history_stress_field[1]);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> ( dim == 3)</div><div class="line">  {</div><div class="line">    history_stress_field_transfer2.interpolate(history_stress_field[2], distributed_history_stress_field[2]);</div><div class="line">  }</div><div class="line"></div><div class="line">history_stress_field = distributed_history_stress_field;</div></div><!-- fragment --><p>strain</p>
<div class="fragment"><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">distributed_history_strain_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      distributed_history_strain_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line">history_strain_field_transfer0.interpolate(history_strain_field[0], distributed_history_strain_field[0]);</div><div class="line"><span class="keywordflow">if</span> ( dim &gt; 1)</div><div class="line">  {</div><div class="line">    history_strain_field_transfer1.interpolate(history_strain_field[1], distributed_history_strain_field[1]);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> ( dim == 3)</div><div class="line">  {</div><div class="line">    history_strain_field_transfer2.interpolate(history_strain_field[2], distributed_history_strain_field[2]);</div><div class="line">  }</div><div class="line"></div><div class="line">history_strain_field = distributed_history_strain_field;</div></div><!-- fragment --> <hr/>
<p> Transfer the history data to the quadrature points of the new mesh In a final step, we have to get the data back from the now interpolated global field to the quadrature points on the new mesh. The following code will do that:</p>
<div class="fragment"><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> dof_to_qpoint_matrix (quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(),</div><div class="line">                                           history_fe.dofs_per_cell);</div><div class="line">  <a class="code" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></div><div class="line">  (history_fe,</div><div class="line">   quadrature_formula,</div><div class="line">   dof_to_qpoint_matrix);</div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  dg_cell = history_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++dg_cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">          = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">                &amp;quadrature_point_history.front(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">                &amp;quadrature_point_history.back(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">            {</div><div class="line">              dg_cell-&gt;get_dof_values (history_stress_field[i][j],</div><div class="line">                                       local_history_stress_fe_values[i][j]);</div><div class="line">              dof_to_qpoint_matrix.vmult (local_history_stress_values_at_qpoints[i][j],</div><div class="line">                                          local_history_stress_fe_values[i][j]);</div><div class="line"></div><div class="line">              dg_cell-&gt;get_dof_values (history_strain_field[i][j],</div><div class="line">                                       local_history_strain_fe_values[i][j]);</div><div class="line">              dof_to_qpoint_matrix.vmult (local_history_strain_values_at_qpoints[i][j],</div><div class="line">                                          local_history_strain_fe_values[i][j]);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">                {</div><div class="line">                  local_quadrature_points_history[q].old_stress[i][j]</div><div class="line">                    = local_history_stress_values_at_qpoints[i][j](q);</div><div class="line"></div><div class="line">                  local_quadrature_points_history[q].old_strain[i][j]</div><div class="line">                    = local_history_strain_values_at_qpoints[i][j](q);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ElastoPlasticProblemsetup_quadrature_point_history"></a> </p><h4>ElastoPlasticProblem::setup_quadrature_point_history</h4>
<p>At the beginning of our computations, we needed to set up initial values of the history variables, such as the existing stresses in the material, that we store in each quadrature point. As mentioned above, we use the <code>user_pointer</code> for this that is available in each cell.</p>
<p>To put this into larger perspective, we note that if we had previously available stresses in our model (which we assume do not exist for the purpose of this program), then we would need to interpolate the field of preexisting stresses to the quadrature points. Likewise, if we were to simulate elasto-plastic materials with hardening/softening, then we would have to store additional history variables like the present yield stress of the accumulated plastic strains in each quadrature points. Pre-existing hardening or weakening would then be implemented by interpolating these variables in the present function as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ElastoPlasticProblem&lt;dim&gt;::setup_quadrature_point_history ()</div><div class="line">{</div></div><!-- fragment --><p>What we need to do here is to first count how many quadrature points are within the responsibility of this processor. This, of course, equals the number of cells that belong to this processor times the number of quadrature points our quadrature formula has on each cell.</p>
<p>For good measure, we also set all user pointers of all cells, whether ours of not, to the null pointer. This way, if we ever access the user pointer of a cell which we should not have accessed, a segmentation fault will let us know that this should not have happened:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> our_cells = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    ++our_cells;</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a>();</div></div><!-- fragment --><p>Next, allocate as many quadrature objects as we need. Since the <code>resize</code> function does not actually shrink the amount of allocated memory if the requested new size is smaller than the old size, we resort to a trick to first free all memory, and then reallocate it: we declare an empty vector as a temporary variable and then swap the contents of the old vector and this temporary variable. This makes sure that the <code>quadrature_point_history</code> is now really empty, and we can let the temporary variable that now holds the previous contents of the vector go out of scope and be destroyed. In the next step. we can then re-allocate as many elements as we need, with the vector default-initializing the <code>PointHistory</code> objects, which includes setting the stress variables to zero.</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;PointHistory&lt;dim&gt; &gt; tmp;</div><div class="line">  tmp.swap (quadrature_point_history);</div><div class="line">}</div><div class="line">quadrature_point_history.resize (our_cells *</div><div class="line">                                 quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div></div><!-- fragment --><p>Finally loop over all cells again and set the user pointers from the cells that belong to the present processor to point to the first quadrature point objects corresponding to this cell in the vector of such objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> history_index = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      cell-&gt;set_user_pointer (&amp;quadrature_point_history[history_index]);</div><div class="line">      history_index += quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    }</div></div><!-- fragment --><p>At the end, for good measure make sure that our count of elements was correct and that we have both used up all objects we allocated previously, and not point to any objects beyond the end of the vector. Such defensive programming strategies are always good checks to avoid accidental errors and to guard against future changes to this function that forget to update all uses of a variable at the same time. Recall that constructs using the <code>Assert</code> macro are optimized away in optimized mode, so do not affect the run time of optimized runs:</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (history_index == quadrature_point_history.size(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ElastoPlasticProblemupdate_quadrature_point_history"></a> </p><h4>ElastoPlasticProblem::update_quadrature_point_history</h4>
<p>At the end of each time step, we should have computed an incremental displacement update so that the material in its new configuration accommodates for the difference between the external body and boundary forces applied during this time step minus the forces exerted through preexisting internal stresses. In order to have the preexisting stresses available at the next time step, we therefore have to update the preexisting stresses with the stresses due to the incremental displacement computed during the present time step. Ideally, the resulting sum of internal stresses would exactly counter all external forces. Indeed, a simple experiment can make sure that this is so: if we choose boundary conditions and body forces to be time independent, then the forcing terms (the sum of external forces and internal stresses) should be exactly zero. If you make this experiment, you will realize from the output of the norm of the right hand side in each time step that this is almost the case: it is not exactly zero, since in the first time step the incremental displacement and stress updates were computed relative to the undeformed mesh, which was then deformed. In the second time step, we again compute displacement and stress updates, but this time in the deformed mesh &ndash; there, the resulting updates are very small but not quite zero. This can be iterated, and in each such iteration the residual, i.e. the norm of the right hand side vector, is reduced; if one makes this little experiment, one realizes that the norm of this residual decays exponentially with the number of iterations, and after an initial very rapid decline is reduced by roughly a factor of about 3.5 in each iteration (for one testcase I looked at, other testcases, and other numbers of unknowns change the factor, but not the exponential decay).</p>
<p>In a sense, this can then be considered as a quasi-timestepping scheme to resolve the nonlinear problem of solving large-deformation elasticity on a mesh that is moved along in a Lagrangian manner.</p>
<p>Another complication is that the existing (old) stresses are defined on the old mesh, which we will move around after updating the stresses. If this mesh update involves rotations of the cell, then we need to also rotate the updated stress, since it was computed relative to the coordinate system of the old cell.</p>
<p>Thus, what we need is the following: on each cell which the present processor owns, we need to extract the old stress from the data stored with each quadrature point, compute the stress update, add the two together, and then rotate the result together with the incremental rotation computed from the incremental displacement at the present quadrature point. We will detail these steps below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ElastoPlasticProblem&lt;dim&gt;::</div><div class="line">update_quadrature_point_history ()</div><div class="line">{</div></div><!-- fragment --><p>First, set up an <code><a class="el" href="classFEValues.html">FEValues</a></code> object by which we will evaluate the displacements and the gradients thereof at the quadrature points, together with a vector that will hold this information:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; incremental_strain_tensor(n_q_points);</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div></div><!-- fragment --><p>Then loop over all cells and do the job in the cells that belong to our subdomain:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (;  cell != endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div></div><!-- fragment --><p>Next, get a pointer to the quadrature point history data local to the present cell, and, as a defensive measure, make sure that this pointer is within the bounds of the global array:</p>
<div class="fragment"><div class="line">PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">  = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">        &amp;quadrature_point_history.front(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">        &amp;quadrature_point_history.back(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then initialize the <code><a class="el" href="classFEValues.html">FEValues</a></code> object on the present cell, and extract the strains of the displacement at the quadrature points</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">fe_values[displacement].get_function_symmetric_gradients(incremental_displacement,</div><div class="line">                                                         incremental_strain_tensor);</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">  {</div><div class="line">    local_quadrature_points_history[q].old_strain +=</div><div class="line">      incremental_strain_tensor[q];</div><div class="line"></div><div class="line">    constitutive_law.get_stress_strain_tensor(local_quadrature_points_history[q].old_strain,</div><div class="line">                                              stress_strain_tensor);</div></div><!-- fragment --><p>The result of these operations is then written back into the original place:</p>
<div class="fragment"><div class="line">            local_quadrature_points_history[q].old_stress</div><div class="line">              = stress_strain_tensor *  local_quadrature_points_history[q].old_strain;</div><div class="line"></div><div class="line">            local_quadrature_points_history[q].point</div><div class="line">              = fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a> ()[q];</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmove_mesh"></a> </p><h4>PlasticityContactProblem::move_mesh</h4>
<p>The remaining three functions before we get to <code>run()</code> have to do with generating output. The following one is an attempt at showing the deformed body in its deformed configuration. To this end, this function takes a displacement vector field and moves every vertex of the (local part) of the mesh by the previously computed displacement. We will call this function with the current displacement field before we generate graphical output, and we will call it again after generating graphical output with the negative displacement field to undo the changes to the mesh so made.</p>
<p>The function itself is pretty straightforward. All we have to do is keep track which vertices we have already touched, as we encounter the same vertices multiple times as we loop over cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::</div><div class="line">move_mesh (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">         dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++d)</div><div class="line">              vertex_displacement[d] = displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">            cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_results"></a> </p><h4>PlasticityContactProblem::output_results</h4>
<p>Next is the function we use to actually generate graphical output. The function is a bit tedious, but not actually particularly complicated. It moves the mesh at the top (and moves it back at the end), then computes the contact forces along the contact surface. We can do so (as shown in the accompanying paper) by taking the untreated residual vector and identifying which degrees of freedom correspond to those with contact by asking whether they have an inhomogeneous constraints associated with them. As always, we need to be mindful that we can only write into completely distributed vectors (i.e., vectors without ghost elements) but that when we want to generate output, we need vectors that do indeed have ghost entries for all locally relevant degrees of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> std::string &amp;filename_base)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> magnified_solution(solution);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> magnified_factor = 3;</div><div class="line">  magnified_solution *= magnified_factor;</div><div class="line"></div><div class="line">  move_mesh(magnified_solution);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">data_component_interpretation(dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution,</div><div class="line">                         std::vector&lt;std::string&gt; (dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>, data_component_interpretation);</div></div><!-- fragment --><div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line"></div><div class="line"><span class="keywordflow">switch</span> (dim)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> 1:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 2:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 3:</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;x_displacement&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;y_displacement&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;z_displacement&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names);</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">  subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div></div><!-- fragment --><div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                         <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div></div><!-- fragment --><div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div></div><!-- fragment --><p>In the remainder of the function, we generate one VTU file on every processor, indexed by the subdomain id of this processor. On the first processor, we then also create a <code>.pvtu</code> file that indexes <em>all</em> of the VTU files so that the entire set of output files can be read at once. These <code>.pvtu</code> are used by Paraview to describe an entire parallel computation's output files. We then do the same again for the competitor of Paraview, the Visit visualization program, by creating a matching <code>.visit</code> file.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename =</div><div class="line">  (output_dir + filename_base + <span class="stringliteral">&quot;-&quot;</span></div><div class="line">   + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line"></div><div class="line">std::ofstream output_vtu((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output_vtu);</div><div class="line">pcout &lt;&lt; output_dir + filename_base &lt;&lt; <span class="stringliteral">&quot;.pvtu&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (this_mpi_process == 0)</div><div class="line">  {</div><div class="line">    std::vector&lt;std::string&gt; filenames;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mpi_processes; ++i)</div><div class="line">      filenames.push_back(filename_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                          <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">    std::ofstream pvtu_master_output((output_dir + filename_base + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(pvtu_master_output, filenames);</div><div class="line"></div><div class="line">    std::ofstream visit_master_output((output_dir + filename_base + <span class="stringliteral">&quot;.visit&quot;</span>).c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">write_visit_record</a>(visit_master_output, filenames);</div></div><!-- fragment --><p>produce eps files for mesh illustration</p>
<div class="fragment"><div class="line">  std::ofstream output_eps((filename + <span class="stringliteral">&quot;.eps&quot;</span>).c_str());</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a>(triangulation, output_eps);</div><div class="line">}</div></div><!-- fragment --><p>Extrapolate the stresses from Gauss point to the nodes</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_at_qpoint;</div><div class="line"></div><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> history_fe (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> history_dof_handler (triangulation);</div><div class="line">history_dof_handler.distribute_dofs (history_fe);</div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_stress_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_values_at_qpoints (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_fe_values (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      history_stress_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">      local_history_stress_values_at_qpoints[i][j].reinit(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line">      local_history_stress_fe_values[i][j].reinit(history_fe.dofs_per_cell);</div><div class="line">    }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  VM_stress_field (history_dof_handler.n_dofs()),</div><div class="line">       local_VM_stress_values_at_qpoints (quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>()),</div><div class="line">       local_VM_stress_fe_values (history_fe.dofs_per_cell);</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> qpoint_to_dof_matrix (history_fe.dofs_per_cell,</div><div class="line">                                         quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line"><a class="code" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a></div><div class="line">(history_fe,</div><div class="line"> quadrature_formula, quadrature_formula,</div><div class="line"> qpoint_to_dof_matrix);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">dg_cell = history_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">        = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">              &amp;quadrature_point_history.front(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">              &amp;quadrature_point_history.back(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">    {</div><div class="line">      stress_at_qpoint = local_quadrature_points_history[q].old_stress;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i; j&lt;dim; j++)</div><div class="line">          {</div><div class="line">            local_history_stress_values_at_qpoints[i][j](q) = stress_at_qpoint[i][j];</div><div class="line">          }</div><div class="line"></div><div class="line">      local_VM_stress_values_at_qpoints(q) = Evaluation::get_von_Mises_stress(stress_at_qpoint);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i; j&lt;dim; j++)</div><div class="line">      {</div><div class="line">        qpoint_to_dof_matrix.vmult (local_history_stress_fe_values[i][j],</div><div class="line">                                    local_history_stress_values_at_qpoints[i][j]);</div><div class="line">        dg_cell-&gt;set_dof_values (local_history_stress_fe_values[i][j],</div><div class="line">                                 history_stress_field[i][j]);</div><div class="line">      }</div><div class="line"></div><div class="line">  qpoint_to_dof_matrix.vmult (local_VM_stress_fe_values,</div><div class="line">                              local_VM_stress_values_at_qpoints);</div><div class="line">  dg_cell-&gt;set_dof_values (local_VM_stress_fe_values,</div><div class="line">                           VM_stress_field);</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Save stresses on nodes by nodal averaging construct a <a class="el" href="classDoFHandler.html">DoFHandler</a> object based on <a class="el" href="classFE__Q.html">FE_Q</a> with 1 degree of freedom in order to compute stresses on nodes (by applying nodal averaging) Therefore, each vertex has one degree of freedom</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe_1 (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler_1 (triangulation);</div><div class="line">dof_handler_1.distribute_dofs (fe_1);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(dof_handler_1.n_dofs() == triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(dof_handler_1.n_dofs(),triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>()));</div><div class="line"></div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_stress_on_vertices (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      history_stress_on_vertices[i][j].reinit(dof_handler_1.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  VM_stress_on_vertices (dof_handler_1.n_dofs()),</div><div class="line">       counter_on_vertices (dof_handler_1.n_dofs());</div><div class="line">VM_stress_on_vertices = 0;</div><div class="line">counter_on_vertices = 0;</div><div class="line"></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">dg_cell = history_dof_handler.begin_active();</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell, ++cell_1)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      dg_cell-&gt;get_dof_values (VM_stress_field,</div><div class="line">                               local_VM_stress_fe_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">          {</div><div class="line">            dg_cell-&gt;get_dof_values (history_stress_field[i][j],</div><div class="line">                                     local_history_stress_fe_values[i][j]);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span>  (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex = cell_1-&gt;vertex_dof_index(v, 0);</div></div><!-- fragment --><p>begin check <a class="el" href="classPoint.html">Point&lt;dim&gt;</a> point1, point2; point1 = cell_1-&gt;vertex(v); point2 = dg_cell-&gt;vertex(v); AssertThrow(point1.distance(point2) &lt; cell-&gt;diameter()*1e-8, <a class="el" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError()</a>); end check</p>
<div class="fragment"><div class="line">          counter_on_vertices (dof_1_vertex) += 1;</div><div class="line"></div><div class="line">          VM_stress_on_vertices (dof_1_vertex) += local_VM_stress_fe_values (v);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">              {</div><div class="line">                history_stress_on_vertices[i][j](dof_1_vertex) +=</div><div class="line">                  local_history_stress_fe_values[i][j](v);</div><div class="line">              }</div><div class="line"></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>&lt;dof_handler_1.n_dofs(); ++id)</div><div class="line">  {</div><div class="line">    VM_stress_on_vertices(<span class="keywordtype">id</span>) /= counter_on_vertices(<span class="keywordtype">id</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">        {</div><div class="line">          history_stress_on_vertices[i][j](id) /= counter_on_vertices(<span class="keywordtype">id</span>);</div><div class="line">        }</div><div class="line">  }</div></div><!-- fragment --><p>Save figures of stresses</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (show_stresses)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>  data_out;</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (history_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[0][0], <span class="stringliteral">&quot;stress_xx&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[1][1], <span class="stringliteral">&quot;stress_yy&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[0][1], <span class="stringliteral">&quot;stress_xy&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (VM_stress_field, <span class="stringliteral">&quot;Von_Mises_stress&quot;</span>);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dim == 3)</div><div class="line">        {</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[0][2], <span class="stringliteral">&quot;stress_xz&quot;</span>);</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[1][2], <span class="stringliteral">&quot;stress_yz&quot;</span>);</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[2][2], <span class="stringliteral">&quot;stress_zz&quot;</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string filename_base_stress = (<span class="stringliteral">&quot;stress-&quot;</span> + filename_base);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string filename =</div><div class="line">        (output_dir + filename_base_stress + <span class="stringliteral">&quot;-&quot;</span></div><div class="line">         + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line"></div><div class="line">      std::ofstream output_vtu((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output_vtu);</div><div class="line">      pcout &lt;&lt; output_dir + filename_base_stress &lt;&lt; <span class="stringliteral">&quot;.pvtu&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (this_mpi_process == 0)</div><div class="line">        {</div><div class="line">          std::vector&lt;std::string&gt; filenames;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mpi_processes; ++i)</div><div class="line">            filenames.push_back(filename_base_stress + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                                <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">          std::ofstream pvtu_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">          data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(pvtu_master_output, filenames);</div><div class="line"></div><div class="line">          std::ofstream visit_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.visit&quot;</span>).c_str());</div><div class="line">          data_out.<a class="code" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">write_visit_record</a>(visit_master_output, filenames);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>  data_out;</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_1);</div><div class="line"></div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[0][0], <span class="stringliteral">&quot;stress_xx_averaged&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[1][1], <span class="stringliteral">&quot;stress_yy_averaged&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[0][1], <span class="stringliteral">&quot;stress_xy_averaged&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (VM_stress_on_vertices, <span class="stringliteral">&quot;Von_Mises_stress_averaged&quot;</span>);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dim == 3)</div><div class="line">        {</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[0][2], <span class="stringliteral">&quot;stress_xz_averaged&quot;</span>);</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[1][2], <span class="stringliteral">&quot;stress_yz_averaged&quot;</span>);</div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[2][2], <span class="stringliteral">&quot;stress_zz_averaged&quot;</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string filename_base_stress = (<span class="stringliteral">&quot;averaged-stress-&quot;</span> + filename_base);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string filename =</div><div class="line">        (output_dir + filename_base_stress + <span class="stringliteral">&quot;-&quot;</span></div><div class="line">         + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line"></div><div class="line">      std::ofstream output_vtu((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output_vtu);</div><div class="line">      pcout &lt;&lt; output_dir + filename_base_stress &lt;&lt; <span class="stringliteral">&quot;.pvtu&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (this_mpi_process == 0)</div><div class="line">        {</div><div class="line">          std::vector&lt;std::string&gt; filenames;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mpi_processes; ++i)</div><div class="line">            filenames.push_back(filename_base_stress + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                                <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">          std::ofstream pvtu_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">          data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(pvtu_master_output, filenames);</div><div class="line"></div><div class="line">          std::ofstream visit_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.visit&quot;</span>).c_str());</div><div class="line">          data_out.<a class="code" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">write_visit_record</a>(visit_master_output, filenames);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    }</div></div><!-- fragment --><p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>
<div class="fragment"><div class="line">  }</div><div class="line"></div><div class="line">magnified_solution *= -1;</div><div class="line">move_mesh(magnified_solution);</div></div><!-- fragment --><p>Timoshenko beam</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Timoshenko beam&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> length = .48,</div><div class="line">                 depth  = .12;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> intersted_point(length, -depth/2);</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">    <span class="keywordtype">bool</span> vertex_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">           dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned() &amp;&amp; !vertex_found)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">          <span class="keywordflow">if</span> ( std::fabs(cell-&gt;vertex(v)[0] - intersted_point[0])&lt;1e-6 &amp;&amp;</div><div class="line">               std::fabs(cell-&gt;vertex(v)[1] - intersted_point[1])&lt;1e-6)</div><div class="line">            {</div><div class="line">              vertex_found = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++d)</div><div class="line">                vertex_displacement[d] = solution(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(vertex_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Displacement at the point (&quot;</span> &lt;&lt; intersted_point[0]</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; intersted_point[1] &lt;&lt; <span class="stringliteral">&quot;) is &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; vertex_displacement[0]</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; vertex_displacement[1] &lt;&lt; <span class="stringliteral">&quot;).\n&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> vertex_exact_displacement(dim);</div><div class="line">    EquationData::IncrementalBoundaryValues&lt;dim&gt; incremental_boundary_values(present_time, end_time);</div><div class="line">    incremental_boundary_values.vector_value (intersted_point, vertex_exact_displacement);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Exact displacement at the point (&quot;</span> &lt;&lt; intersted_point[0]</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; intersted_point[1] &lt;&lt; <span class="stringliteral">&quot;) is &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; vertex_exact_displacement[0]</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; vertex_exact_displacement[1] &lt;&lt; <span class="stringliteral">&quot;).\n\n&quot;</span>;</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pressure (0.6*2.4e8),</div><div class="line">          inner_radius (.1);</div></div><!-- fragment --><p>const double pressure (1.94e8), inner_radius (.1);</p>
<p>Plane stress const double mu (((e_modulus*(1+2*nu)) / (std::pow((1+nu),2))) / (2 * (1 + (nu / (1+nu))))); 3d and plane strain</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> mu (e_modulus / (2 * (1 + nu)));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_A(inner_radius, 0.);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>   disp_A(dim);</div></div><!-- fragment --><p>make a non-parallel copy of solution</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> copy_solution(solution);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> Evaluation::PointValuesEvaluation&lt;dim&gt;::</div><div class="line">PointValuesEvaluation point_values_evaluation(point_A);</div><div class="line"></div><div class="line">point_values_evaluation.compute (dof_handler, copy_solution, disp_A);</div><div class="line"></div><div class="line">table_results.add_value(<span class="stringliteral">&quot;time step&quot;</span>, timestep_no);</div><div class="line">table_results.add_value(<span class="stringliteral">&quot;Cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>());</div><div class="line">table_results.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">table_results.add_value(<span class="stringliteral">&quot;pressure/sigma_0&quot;</span>, (pressure*present_time/end_time)/sigma_0);</div><div class="line">table_results.add_value(<span class="stringliteral">&quot;4*mu*u_A/(sigma_0*a)&quot;</span>, 4*mu*disp_A(0)/(sigma_0*inner_radius));</div></div><!-- fragment --><p>Compute stresses in the POLAR coordinates, 1- save it on Gauss points, 2- extrapolate them to nodes and taking their avarages (nodal avaraging)</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (dim == 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>we define a rotation matrix to be able to transform the stress from the Cartesian coordinate to the polar coordinate</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> rotation_matrix; <span class="comment">// [cos sin; -sin cos]    , sigma_r = rot * sigma * rot^T</span></div><div class="line"></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; strain_tensor(n_q_points);</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>  stress_at_qpoint;</div><div class="line"></div><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> history_fe (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> history_dof_handler (triangulation);</div><div class="line">history_dof_handler.distribute_dofs (history_fe);</div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_stress_field (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_values_at_qpoints (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim)),</div><div class="line">                     local_history_stress_fe_values (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      history_stress_field[i][j].reinit(history_dof_handler.n_dofs());</div><div class="line">      local_history_stress_values_at_qpoints[i][j].reinit(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line">      local_history_stress_fe_values[i][j].reinit(history_fe.dofs_per_cell);</div><div class="line">    }</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> qpoint_to_dof_matrix (history_fe.dofs_per_cell,</div><div class="line">                                         quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line"><a class="code" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a></div><div class="line">(history_fe,</div><div class="line"> quadrature_formula, quadrature_formula,</div><div class="line"> qpoint_to_dof_matrix);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">dg_cell = history_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">        = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">              &amp;quadrature_point_history.front(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">              &amp;quadrature_point_history.back(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">  {</div><div class="line">    stress_at_qpoint = local_quadrature_points_history[q].old_stress;</div></div><!-- fragment --><p>transform the stress from the Cartesian coordinate to the polar coordinate</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point = local_quadrature_points_history[q].point;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> radius = point.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a> ();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> theta = std::atan2(point(1),point(0));</div></div><!-- fragment --><p>rotation matrix</p>
<div class="fragment"><div class="line">rotation_matrix[0][0] = std::cos(theta);</div><div class="line">rotation_matrix[0][1] = std::sin(theta);</div><div class="line">rotation_matrix[1][0] = -std::sin(theta);</div><div class="line">rotation_matrix[1][1] = std::cos(theta);</div></div><!-- fragment --><p>stress in polar coordinate</p>
<div class="fragment"><div class="line">          stress_at_qpoint = rotation_matrix * stress_at_qpoint * <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(rotation_matrix);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i; j&lt;dim; j++)</div><div class="line">              {</div><div class="line">                local_history_stress_values_at_qpoints[i][j](q) = stress_at_qpoint[i][j];</div><div class="line">              }</div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i; j&lt;dim; j++)</div><div class="line">          {</div><div class="line">            qpoint_to_dof_matrix.vmult (local_history_stress_fe_values[i][j],</div><div class="line">                                        local_history_stress_values_at_qpoints[i][j]);</div><div class="line">            dg_cell-&gt;set_dof_values (local_history_stress_fe_values[i][j],</div><div class="line">                                     history_stress_field[i][j]);</div><div class="line">          }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>  data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (history_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[0][0], <span class="stringliteral">&quot;stress_rr&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[1][1], <span class="stringliteral">&quot;stress_tt&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_field[0][1], <span class="stringliteral">&quot;stress_rt&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename_base_stress = (<span class="stringliteral">&quot;stress-polar-&quot;</span> + filename_base);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (output_dir + filename_base_stress + <span class="stringliteral">&quot;-&quot;</span></div><div class="line">     + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line"></div><div class="line">  std::ofstream output_vtu((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output_vtu);</div><div class="line">  pcout &lt;&lt; output_dir + filename_base_stress &lt;&lt; <span class="stringliteral">&quot;.pvtu&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (this_mpi_process == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mpi_processes; ++i)</div><div class="line">        filenames.push_back(filename_base_stress + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                            <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">      std::ofstream pvtu_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(pvtu_master_output, filenames);</div><div class="line"></div><div class="line">      std::ofstream visit_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.visit&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">write_visit_record</a>(visit_master_output, filenames);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ construct a <a class="el" href="classDoFHandler.html">DoFHandler</a> object based on <a class="el" href="classFE__Q.html">FE_Q</a> with 1 degree of freedom in order to compute stresses on nodes (by applying nodal averaging) Therefore, each vertex has one degree of freedom</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe_1 (1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler_1 (triangulation);</div><div class="line">dof_handler_1.distribute_dofs (fe_1);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(dof_handler_1.n_dofs() == triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(dof_handler_1.n_dofs(),triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>()));</div><div class="line"></div><div class="line">std::vector&lt; std::vector&lt; Vector&lt;double&gt; &gt; &gt;</div><div class="line">history_stress_on_vertices (dim, std::vector&lt; <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;(dim));</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">    {</div><div class="line">      history_stress_on_vertices[i][j].reinit(dof_handler_1.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>  counter_on_vertices (dof_handler_1.n_dofs());</div><div class="line">counter_on_vertices = 0;</div><div class="line"></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">dg_cell = history_dof_handler.begin_active();</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell, ++cell_1)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">          {</div><div class="line">            dg_cell-&gt;get_dof_values (history_stress_field[i][j],</div><div class="line">                                     local_history_stress_fe_values[i][j]);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span>  (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex = cell_1-&gt;vertex_dof_index(v, 0);</div></div><!-- fragment --><p>begin check <a class="el" href="classPoint.html">Point&lt;dim&gt;</a> point1, point2; point1 = cell_1-&gt;vertex(v); point2 = dg_cell-&gt;vertex(v); AssertThrow(point1.distance(point2) &lt; cell-&gt;diameter()*1e-8, <a class="el" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError()</a>); end check</p>
<div class="fragment"><div class="line">          counter_on_vertices (dof_1_vertex) += 1;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">              {</div><div class="line">                history_stress_on_vertices[i][j](dof_1_vertex) +=</div><div class="line">                  local_history_stress_fe_values[i][j](v);</div><div class="line">              }</div><div class="line"></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>=0; <span class="keywordtype">id</span>&lt;dof_handler_1.n_dofs(); ++id)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">        {</div><div class="line">          history_stress_on_vertices[i][j](id) /= counter_on_vertices(<span class="keywordtype">id</span>);</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>  data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_1);</div><div class="line"></div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[0][0], <span class="stringliteral">&quot;stress_rr_averaged&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[1][1], <span class="stringliteral">&quot;stress_tt_averaged&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (history_stress_on_vertices[0][1], <span class="stringliteral">&quot;stress_rt_averaged&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename_base_stress = (<span class="stringliteral">&quot;averaged-stress-polar-&quot;</span> + filename_base);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (output_dir + filename_base_stress + <span class="stringliteral">&quot;-&quot;</span></div><div class="line">     + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line"></div><div class="line">  std::ofstream output_vtu((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output_vtu);</div><div class="line">  pcout &lt;&lt; output_dir + filename_base_stress &lt;&lt; <span class="stringliteral">&quot;.pvtu&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (this_mpi_process == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mpi_processes; ++i)</div><div class="line">        filenames.push_back(filename_base_stress + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                            <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">      std::ofstream pvtu_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(pvtu_master_output, filenames);</div><div class="line"></div><div class="line">      std::ofstream visit_master_output((output_dir + filename_base_stress + <span class="stringliteral">&quot;.visit&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">write_visit_record</a>(visit_master_output, filenames);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( std::abs( (present_time/end_time)*(pressure/sigma_0) - 0.6 ) &lt;</div><div class="line">     .501*(present_timestep/end_time)*(pressure/sigma_0) )</div><div class="line">  {</div></div><!-- fragment --><p>table_results_2: presenting the stress_rr and stress_tt on the nodes of bottom edge</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id = 3;</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; vertices_found (dof_handler_1.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell, ++cell_1)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">              &amp;&amp;</div><div class="line">              cell-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                {</div><div class="line">                  evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                {</div><div class="line">                  <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex =</div><div class="line">                    cell_1-&gt;face(face)-&gt;vertex_dof_index(v, 0);</div><div class="line">                  <span class="keywordflow">if</span> (!vertices_found[dof_1_vertex])</div><div class="line">                    {</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_coordinate = cell_1-&gt;face(face)-&gt;vertex(v);</div><div class="line"></div><div class="line">                      table_results_2.add_value(<span class="stringliteral">&quot;x coordinate&quot;</span>, vertex_coordinate[0]);</div><div class="line">                      table_results_2.add_value(<span class="stringliteral">&quot;stress_rr&quot;</span>, history_stress_on_vertices[0][0](dof_1_vertex));</div><div class="line">                      table_results_2.add_value(<span class="stringliteral">&quot;stress_tt&quot;</span>, history_stress_on_vertices[1][1](dof_1_vertex));</div><div class="line">                      table_results_2.add_value(<span class="stringliteral">&quot;pressure/sigma_0&quot;</span>, (pressure*present_time/end_time)/sigma_0);</div><div class="line"></div><div class="line">                      vertices_found[dof_1_vertex] = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>table_results_3: presenting the mean stress_rr of the nodes on the inner radius</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id_2 = 0;</div><div class="line"></div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> stress_node,</div><div class="line">               mean_stress_polar;</div><div class="line">        mean_stress_polar = 0;</div><div class="line"></div><div class="line">        std::vector&lt;bool&gt; vertices_found_2 (dof_handler_1.n_dofs(), <span class="keyword">false</span>);</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> no_vertices_found = 0;</div><div class="line"></div><div class="line">        evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">        cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++cell_1)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">                      &amp;&amp;</div><div class="line">                      cell-&gt;face(face)-&gt;boundary_indicator() == face_id_2)</div><div class="line">                    {</div><div class="line">                      <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                        {</div><div class="line">                          evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                        }</div><div class="line"></div><div class="line"></div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                        {</div><div class="line">                          <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex =</div><div class="line">                            cell_1-&gt;face(face)-&gt;vertex_dof_index(v, 0);</div><div class="line">                          <span class="keywordflow">if</span> (!vertices_found_2[dof_1_vertex])</div><div class="line">                            {</div><div class="line">                              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ir=0; ir&lt;dim; ++ir)</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ic=0; ic&lt;dim; ++ic)</div><div class="line">                                  stress_node[ir][ic] = history_stress_on_vertices[ir][ic](dof_1_vertex);</div><div class="line"></div><div class="line">                              mean_stress_polar += stress_node;</div><div class="line"></div><div class="line">                              vertices_found_2[dof_1_vertex] = <span class="keyword">true</span>;</div><div class="line">                              ++no_vertices_found;</div><div class="line">                            }</div><div class="line">                        }</div><div class="line"></div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">            }</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        mean_stress_polar /= no_vertices_found;</div><div class="line"></div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;time step&quot;</span>, timestep_no);</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;pressure/sigma_0&quot;</span>, (pressure*present_time/end_time)/sigma_0);</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;Cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>());</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;radius&quot;</span>, inner_radius);</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;mean stress_rr&quot;</span>, mean_stress_polar[0][0]);</div><div class="line">        table_results_3.add_value(<span class="stringliteral">&quot;mean stress_tt&quot;</span>, mean_stress_polar[1][1]);</div><div class="line"></div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> imposed_displacement (0.00055),</div><div class="line">          inner_radius (0.05),</div><div class="line">          height (0.18);</div></div><!-- fragment --><p>Plane stress const double mu (((e_modulus*(1+2*nu)) / (std::pow((1+nu),2))) / (2 * (1 + (nu / (1+nu))))); 3d and plane strain</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> mu (e_modulus / (2 * (1 + nu)));</div></div><!-- fragment --><p>table_results: Demonstrates the result of displacement at the top left corner versus imposed tension</p>
<div class="fragment"><div class="line">/ *</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_C(0., height);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   disp_C(dim);</div></div><!-- fragment --><p>make a non-parallel copy of solution</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> copy_solution(solution);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Evaluation::PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  PointValuesEvaluation point_values_evaluation(point_C);</div><div class="line"></div><div class="line">  point_values_evaluation.compute (dof_handler, copy_solution, disp_C);</div><div class="line"></div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;time step&quot;</span>, timestep_no);</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;Cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>());</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;4*mu*u_C/(sigma_0*r)&quot;</span>, 4*mu*disp_C(1)/(sigma_0*inner_radius));</div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --><p>compute average sigma_yy on the bottom edge</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> stress_yy_av;</div><div class="line">{</div><div class="line">  stress_yy_av = 0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id = 1;</div><div class="line"></div><div class="line">  std::vector&lt;bool&gt; vertices_found (dof_handler_1.n_dofs(), <span class="keyword">false</span>);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> no_vertices_in_face = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++cell_1)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">                &amp;&amp;</div><div class="line">                cell-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                  {</div><div class="line">                    evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                  }</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex =</div><div class="line">                      cell_1-&gt;face(face)-&gt;vertex_dof_index(v, 0);</div><div class="line">                    <span class="keywordflow">if</span> (!vertices_found[dof_1_vertex])</div><div class="line">                      {</div><div class="line">                        stress_yy_av += history_stress_on_vertices[1][1](dof_1_vertex);</div><div class="line">                        ++no_vertices_in_face;</div><div class="line"></div><div class="line">                        vertices_found[dof_1_vertex] = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line"></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  stress_yy_av /= no_vertices_in_face;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>table_results_2: Demonstrate the stress_yy on the nodes of bottom edge</p>
<p>if ( std::abs( (stress_yy_av/sigma_0) - .91 ) &lt; .2 )</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( (timestep_no) % 19 == 0 )</div></div><!-- fragment --><p>if ( true )</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_id = 1;</div><div class="line"></div><div class="line">  std::vector&lt;bool&gt; vertices_found (dof_handler_1.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> evaluation_face_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  cell_1 = dof_handler_1.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++cell_1)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">                &amp;&amp;</div><div class="line">                cell-&gt;face(face)-&gt;boundary_indicator() == face_id)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (!evaluation_face_found)</div><div class="line">                  {</div><div class="line">                    evaluation_face_found = <span class="keyword">true</span>;</div><div class="line">                  }</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> dof_1_vertex =</div><div class="line">                      cell_1-&gt;face(face)-&gt;vertex_dof_index(v, 0);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_coordinate = cell_1-&gt;face(face)-&gt;vertex(v);</div><div class="line"></div><div class="line">                    <span class="keywordflow">if</span> (!vertices_found[dof_1_vertex] &amp;&amp; std::abs(vertex_coordinate[2])&lt;1.e-8)</div><div class="line">                      {</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;x&quot;</span>, vertex_coordinate[0]);</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;x/r&quot;</span>, vertex_coordinate[0]/inner_radius);</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;stress_xx/sigma_0&quot;</span>, history_stress_on_vertices[0][0](dof_1_vertex)/sigma_0);</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;stress_yy/sigma_0&quot;</span>, history_stress_on_vertices[1][1](dof_1_vertex)/sigma_0);</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;stress_yy_av/sigma_0&quot;</span>, stress_yy_av/sigma_0);</div><div class="line">                        table_results_2.add_value(<span class="stringliteral">&quot;Imposed u_y&quot;</span>, (imposed_displacement*present_time/end_time));</div><div class="line"></div><div class="line">                        vertices_found[dof_1_vertex] = <span class="keyword">true</span>;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line"></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_face_found, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>table_results_3: Demonstrate the Stress_mean (average tensile stress) on the bottom edge versus epsilon_yy on the bottom left corner</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> strain_yy_A;</div></div><!-- fragment --><p>compute strain_yy_A Since the point A is the node on the bottom left corner, we need to work just with one element</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_A(inner_radius, 0, 0);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  local_strain_yy_values_at_qpoints (quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>()),</div><div class="line">         local_strain_yy_fe_values (history_fe.dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_at_qpoint;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  dg_cell = history_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> cell_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell, ++dg_cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned() &amp;&amp; !cell_found)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">          <span class="keywordflow">if</span> ( std::fabs(cell-&gt;vertex(v)[0] - point_A[0])&lt;1e-6 &amp;&amp;</div><div class="line">               std::fabs(cell-&gt;vertex(v)[1] - point_A[1])&lt;1e-6 &amp;&amp;</div><div class="line">               std::fabs(cell-&gt;vertex(v)[2] - point_A[2])&lt;1e-6)</div><div class="line">            {</div><div class="line">              PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">                = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">                      &amp;quadrature_point_history.front(),</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">                      &amp;quadrature_point_history.back(),</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">                      {</div><div class="line">                        strain_at_qpoint = local_quadrature_points_history[q].old_strain;</div><div class="line"></div><div class="line">                        local_strain_yy_values_at_qpoints(q) = strain_at_qpoint[1][1];</div><div class="line">                      }</div><div class="line"></div><div class="line">                    qpoint_to_dof_matrix.vmult (local_strain_yy_fe_values,</div><div class="line">                                                local_strain_yy_values_at_qpoints);</div><div class="line"></div><div class="line">                    strain_yy_A = local_strain_yy_fe_values (v);</div><div class="line"></div><div class="line">                    cell_found = <span class="keyword">true</span>;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line"></div><div class="line">            }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;time step&quot;</span>, timestep_no);</div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;Cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>());</div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;Imposed u_y&quot;</span>, (imposed_displacement*present_time/end_time));</div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;mean_tensile_stress/sigma_0&quot;</span>, stress_yy_av/sigma_0);</div><div class="line">      table_results_3.add_value(<span class="stringliteral">&quot;E*strain_yy-A/sigma_0&quot;</span>, e_modulus*strain_yy_A/sigma_0);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (std::abs(present_time-end_time) &lt; 1.e-7)</div><div class="line">      {</div><div class="line">        table_results_2.set_precision(<span class="stringliteral">&quot;Imposed u_y&quot;</span>, 6);</div><div class="line">        table_results_3.set_precision(<span class="stringliteral">&quot;Imposed u_y&quot;</span>, 6);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Cantiliver_beam_3d&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pressure (6e6),</div><div class="line">          length (.7),</div><div class="line">          height (200e-3);</div></div><!-- fragment --><p>table_results: Demonstrates the result of displacement at the top front point, <a class="el" href="classPoint.html">Point</a> A</p>
<div class="fragment"><div class="line">{</div></div><!-- fragment --><p>Quantity of interest: displacement at <a class="el" href="classPoint.html">Point</a> A (x=0, y=height/2, z=length)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_A(0, height/2, length);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>   disp_A(dim);</div></div><!-- fragment --><p>make a non-parallel copy of solution</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> copy_solution(solution);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Evaluation::PointValuesEvaluation&lt;dim&gt;::</div><div class="line">  PointValuesEvaluation point_values_evaluation(point_A);</div><div class="line"></div><div class="line">  point_values_evaluation.compute (dof_handler, copy_solution, disp_A);</div><div class="line"></div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;time step&quot;</span>, timestep_no);</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;Cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>());</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;pressure&quot;</span>, pressure*present_time/end_time);</div><div class="line">  table_results.add_value(<span class="stringliteral">&quot;u_A&quot;</span>, disp_A(1));</div><div class="line">}</div><div class="line"></div><div class="line">{</div></div><!-- fragment --><p>demonstrate the location and maximum von-Mises stress in the specified domain close to the clamped face, z = 0 top domain: height/2 - thickness_flange &lt;= y &lt;= height/2 0 &lt;= z &lt;= 2 * thickness_flange bottom domain: -height/2 &lt;= y &lt;= -height/2 + thickness_flange 0 &lt;= z &lt;= 2 * thickness_flange</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> VM_stress_max (0);</div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> point_max;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_at_qpoint;</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      PointHistory&lt;dim&gt; *local_quadrature_points_history</div><div class="line">        = <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &gt;=</div><div class="line">              &amp;quadrature_point_history.front(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (local_quadrature_points_history &lt;</div><div class="line">              &amp;quadrature_point_history.back(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Then loop over the quadrature points of this cell:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">                {</div><div class="line">                  stress_at_qpoint = local_quadrature_points_history[q].old_stress;</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> VM_stress = Evaluation::get_von_Mises_stress(stress_at_qpoint);</div><div class="line">                  <span class="keywordflow">if</span> (VM_stress &gt; VM_stress_max)</div><div class="line">                    {</div><div class="line">                      VM_stress_max = VM_stress;</div><div class="line">                      point_max = local_quadrature_points_history[q].point;</div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        table_results.add_value(<span class="stringliteral">&quot;maximum von_Mises stress&quot;</span>, VM_stress_max);</div><div class="line">        table_results.add_value(<span class="stringliteral">&quot;x&quot;</span>, point_max[0]);</div><div class="line">        table_results.add_value(<span class="stringliteral">&quot;y&quot;</span>, point_max[1]);</div><div class="line">        table_results.add_value(<span class="stringliteral">&quot;z&quot;</span>, point_max[2]);</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrun"></a> </p><h4>PlasticityContactProblem::run</h4>
<p>As in all other tutorial programs, the <code>run()</code> function contains the overall logic. There is not very much to it here: in essence, it performs the loops over all mesh refinement cycles, and within each, hands things over to the Newton solver in <code>solve_newton()</code> on the current mesh and calls the function that creates graphical output for the so-computed solution. It then outputs some statistics concerning both run times and memory consumption that has been collected over the course of computations on this mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ElastoPlasticProblem&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  computing_timer.reset();</div><div class="line"></div><div class="line">  present_time = 0;</div><div class="line">  present_timestep = 1;</div><div class="line">  end_time = 10;</div><div class="line">  timestep_no = 0;</div><div class="line"></div><div class="line">  make_grid();</div></div><!-- fragment --> <hr/>
<p> base_mesh == "Thick_tube_internal_pressure"</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> center(0, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = .1,</div><div class="line">    outer_radius = .2;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> inner_boundary_description(center, inner_radius);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0, inner_boundary_description);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classHyperBallBoundary.html">HyperBallBoundary&lt;dim&gt;</a> outer_boundary_description(center, outer_radius);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (1, outer_boundary_description);</div><div class="line">* /</div></div><!-- fragment --> <hr/>
<p> base_mesh == "Perforated_strip_tension"</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.05;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;dim&gt;</a> inner_boundary_description(inner_radius, 2);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10, inner_boundary_description);</div><div class="line">* /</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">setup_quadrature_point_history ();</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (present_time &lt; end_time)</div><div class="line">  {</div><div class="line">    present_time += present_timestep;</div><div class="line">    ++timestep_no;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (present_time &gt; end_time)</div><div class="line">      {</div><div class="line">        present_timestep -= (present_time - end_time);</div><div class="line">        present_time = end_time;</div><div class="line">      }</div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_no &lt;&lt; <span class="stringliteral">&quot; at time &quot;</span> &lt;&lt; present_time</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    relative_error = max_relative_error * 10;</div><div class="line">    current_refinement_cycle = 0;</div><div class="line"></div><div class="line">    setup_system();</div></div><!-- fragment --><p>---------------------&mdash; Refinement based on the relative error ----------------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (relative_error &gt;= max_relative_error)</div><div class="line">  {</div><div class="line">    solve_newton();</div><div class="line">    compute_error();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( (timestep_no &gt; 1) &amp;&amp; (current_refinement_cycle&gt;0) &amp;&amp; (relative_error &gt;= max_relative_error) )</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;The relative error, &quot;</span> &lt;&lt; relative_error</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; , is still more than maximum relative error, &quot;</span></div><div class="line">              &lt;&lt; max_relative_error &lt;&lt; <span class="stringliteral">&quot;, but we move to the next increment.\n&quot;</span>;</div><div class="line">        relative_error = .1 * max_relative_error;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (relative_error &gt;= max_relative_error)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">        ++current_refinement_cycle;</div><div class="line">        refine_grid();</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div></div><!-- fragment --><p>---------------------&mdash; Refinement based on the number of refinement -----------------------&mdash;</p>
<div class="fragment"><div class="line">/ *</div><div class="line"><span class="keywordtype">bool</span> continue_loop = <span class="keyword">true</span>;</div><div class="line"><span class="keywordflow">while</span> (continue_loop)</div><div class="line">{</div><div class="line">  solve_newton();</div><div class="line">  compute_error();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( (timestep_no == 1) &amp;&amp; (current_refinement_cycle &lt; 1) )</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">    ++current_refinement_cycle;</div><div class="line">    refine_grid();</div><div class="line">  }<span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    continue_loop = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line">* /</div></div><!-- fragment --> <hr/>
<div class="fragment"><div class="line">        solution += incremental_displacement;</div><div class="line"></div><div class="line">        update_quadrature_point_history ();</div><div class="line"></div><div class="line">        output_results((std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                        <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_no, 4)).c_str());</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">              &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (std::abs(present_time-end_time) &lt; 1.e-7)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> std::string filename = (output_dir + <span class="stringliteral">&quot;Results&quot;</span>);</div><div class="line"></div><div class="line">            std::ofstream output_txt((filename + <span class="stringliteral">&quot;.txt&quot;</span>).c_str());</div><div class="line"></div><div class="line">            pcout &lt;&lt; std::endl;</div><div class="line">            table_results.write_text(output_txt);</div><div class="line">            pcout &lt;&lt; std::endl;</div><div class="line">            table_results_2.write_text(output_txt);</div><div class="line">            pcout &lt;&lt; std::endl;</div><div class="line">            table_results_3.write_text(output_txt);</div><div class="line">            pcout &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Thick_tube_internal_pressure&quot;</span>)</div><div class="line">      {</div><div class="line">        triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0);</div><div class="line">        triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (1);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;Perforated_strip_tension&quot;</span>)</div><div class="line">      {</div><div class="line">        triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (10);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>There really isn't much to the <code>main()</code> function. It looks like they always do:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>ElastoPlastic;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line">      ElastoPlasticProblem&lt;dim&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./elastoplastic input.prm&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#abc4fe419ccc4b128ec2bad5e0dec62ac">read_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv);</div><div class="line">      {</div><div class="line">        ElastoPlasticProblem&lt;dim&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
