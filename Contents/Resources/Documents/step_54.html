<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-54 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-54 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#CADsurfaces"> CAD surfaces </a>
        <li><a href="#Theboundaryprojectorclasses"> The boundary projector classes </a>
        <li><a href="#Thetestcase"> The testcase </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheTriangulationOnCADclass">The TriangulationOnCAD class</a>
      <ul>
        <li><a href="#TriangulationOnCADTriangulationOnCAD">TriangulationOnCAD::TriangulationOnCAD</a>
        <li><a href="#TriangulationOnCADread_domain">TriangulationOnCAD::read_domain</a>
        <li><a href="#TriangulationOnCADrefine_mesh">TriangulationOnCAD::refine_mesh</a>
        <li><a href="#TriangulationOnCADoutput_results">TriangulationOnCAD::output_results</a>
        <li><a href="#TriangulationOnCADrun">TriangulationOnCAD::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Andrea Mola and Luca Heltai.</em></p>
<dl class="section note"><dt>Note</dt><dd>This program elaborates on concepts of industrial geometry, using tools that interface with the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> library (<a href="http://www.opencascade.org">http://www.opencascade.org</a>) that allow the specification of arbitrary IGES files to describe the boundaries for your geometries.</dd>
<dd>
If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.546220"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.546220.svg" alt="10.5281/zenodo.546220"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>In some of the previous tutorial programs (<a class="el" href="step_1.html">step-1</a>, <a class="el" href="step_3.html">step-3</a>, <a class="el" href="step_5.html">step-5</a>, <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_49.html">step-49</a> among others) we have learned how to use the mesh refinement methods provided in deal.II. These tutorials have shown how to employ such tools to produce a fine grid for a single simulation, as done in <a class="el" href="step_3.html">step-3</a>; or to start from a coarse grid and carry out a series of simulations on adaptively refined grids, as is the case of <a class="el" href="step_6.html">step-6</a>. Regardless of which approach is taken, the mesh refinement requires a suitable geometrical description of the computational domain boundary in order to place, at each refinement, the new mesh nodes onto the boundary surface. For instance, <a class="el" href="step_5.html">step-5</a> shows how to assign a circular shape to the boundary of the computational domain, so that the faces lying on the boundary are refined onto the circle. <a class="el" href="step_53.html">step-53</a> shows how to do this with a boundary defined by experimentally obtained data. But, at least as far as elementary boundary shapes are concerned, deal.II really only provides circles, spheres, boxes and various combinations. In this tutorial, we will show how to use a set of classes developed to import arbitrary CAD geometries, assign them to the desired boundary of the computational domain, and refine a computational grid on such complex shapes.</p>
<p><a class="anchor" id="CADsurfaces"></a></p><h3>CAD surfaces </h3>
<p>In the most common industrial practice, the geometrical models of arbitrarily shaped objects are realized by means of Computer Aided Design (CAD) tools. The use of CAD modelers has spread in the last decades, as they allow for the generation of a full virtual model of each designed object, which through a computer can be visualized, inspected, and analyzed in its finest details well before it is physically crafted. From a mathematical perspective, the engine lying under the hood of CAD modelers is represented by analytical geometry, and in particular by parametric curves and surfaces such as B-splines and NURBS that are rich enough that they can represent most surfaces of practical interest. Once a virtual model is ready, all the geometrical features of the desired object are stored in files which materially contain the coefficients of the parametric surfaces and curves composing the object. Depending on the specific CAD tool used to define the geometrical model, there are of course several different file formats in which the information of a CAD model can be organized. To provide a common ground to exchange data across CAD tools, the U.S. National Bureau of Standards published in 1980 the Initial Graphics Exchange Representation (IGES) neutral file format, which is used in this example.</p>
<p><a class="anchor" id="Theboundaryprojectorclasses"></a></p><h3>The boundary projector classes </h3>
<p>To import and interrogate CAD models, the deal.II library contains a series of wrapper functions for the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> open source library for CAD modeling. These functions allow to import IGES files into <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> native objects, and wrap them inside a series of <a class="el" href="classManifold.html">Manifold</a> classes.</p>
<p>Once imported from an IGES file, the model is stored in a <code>TopoDS_Shape</code>, which is the generic topological entity defined in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> framework. From a <code>TopoDS_Shape</code>, it is then possible to access all the sub-shapes (such as vertices, edges and faces) composing it, along with their geometrical description. In the deal.II framework, the topological entities composing a shape are used to create objects of the <a class="el" href="classManifold.html">Manifold</a> or <a class="el" href="classBoundary.html">Boundary</a> classes. In <a class="el" href="step_6.html">step-6</a> we saw how to build a <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a> and assign it to a set of faces (or cells, for co-dimension 1) of a <a class="el" href="classTriangulation.html">Triangulation</a>, to have cells and faces refined on a sphere or circle. The functions of the CAD modeling interface have been designed to retain the same structure, allowing the user to build a projector object using the imported CAD shapes, maintaining the very same procedure we use with <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>, i.e., assigning such projector object to cells, faces or edges of a coarse mesh. At each refinement cycle, the new mesh nodes will be then automatically generated by projecting a midpoint of an existing object onto the specified geometry.</p>
<p>Differently from a spherical or circular boundary, a boundary with a complex geometry poses problems as to where it is best to place the new nodes created upon refinement on the prescribed shape. <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a> first creates the new nodes on the face or edge to be refined by averaging the surrounding points in the same way as <a class="el" href="classFlatManifold.html">FlatManifold</a> does. Then, it goes on to project such nodes on the circle or sphere along the radial direction. On such a geometry, the radial direction ensures that the newly generated nodes remain evenly spaced when remaining on a given refinement level.</p>
<p>In the case of an arbitrary and complex shape though, the best direction of the projection cannot be identified that easily. The <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> wrappers in deal.II provide several projector classes that employ different projection strategies. A first projector, implemented in the <a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a> class, is to be used only for edge refinement. It is built assigning it a topological shape of dimension one, either a <code>TopoDS_Edge</code> or a <code>TopoDS_Wire</code> (which is a compound shape, made of several connected <code>TopoDS_Edge</code>s) and refines a mesh edge finding the new vertex as the point splitting in two even parts the curvilinear length of the CAD curve portion that lies between the vertices of the original edge.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.CurveSplit.png" width="500"/>
</div>
<p>A different projection strategy has been implemented in the <a class="el" href="classOpenCASCADE_1_1NormalProjectionBoundary.html">OpenCASCADE::NormalProjectionBoundary</a> class. The <code>TopoDS_Shape</code> assigned at construction time can be arbitrary (a collection of shapes, faces, edges or a single face or edge will all work). The new cell nodes are first computed by averaging the surrounding points in the same way as <a class="el" href="classFlatManifold.html">FlatManifold</a> does. In a second step, all the new nodes will be projected onto the <code>TopoDS_Shape</code> along the direction normal to the shape. If no normal projection is available, the point which is closest to the shape&mdash;typically lying on the shape boundary&mdash;is selected. If the shape is composed of several sub-shapes, the projection is carried out onto every single sub-shape, and the closest projection point point is selected.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjectionEdge.png" width="500"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.NormalProjection.png" width="500"/>
</div>
<p>As we are about to experience, for some shapes, setting the projection direction as that normal to the CAD surface will not lead to surface mesh elements of suitable quality. This is because the direction normal to the CAD surface has in principle nothing to do with the direction along which the mesh needs the new nodes to be located. The <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">OpenCASCADE::DirectionalProjectionBoundary</a> class, in this case, can help. This class is constructed assigning a <code>TopoDS_Shape</code> (containing at least a face) and a direction along which all the projections will be carried out. New points will be computed by first averaging the surrounding points (as in the <a class="el" href="classFlatManifold.html">FlatManifold</a> case), and then taking the closest intersection between the topological shape and the line passing through the resulting point, along the direction used at construction time. In this way, the user will have a higher control on the projection direction to be enforced to ensure good mesh quality.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.DirectionalProjection.png" width="500"/>
</div>
<p>Of course the latter approach is effective only when the orientation of the surface is rather uniform, so that a single projection direction can be identified. In cases in which the surface direction is approaching the projection direction, it is even possible that the directional projection is not found. To overcome these problems, the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary</a> class implements a third projection algorithm. The <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary</a> class is built assigning a <code>TopoDS_Shape</code> (containing at least one face) to the constructor, and works exactly like a OpenCASCADE::DirectionalProjection. But, as the name of the class suggests, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary</a> tries to come up with a suitable estimate of the direction normal to the mesh elements to be refined, and uses it for the projection of the new nodes onto the CAD surface. If we consider a mesh edge in a 2D space, the direction of its axis is a direction along which to split it in order to give rise to two new cells of the same length. We here extended this concept in 3D, and project all new nodes in a direction that approximates the cell normal.</p>
<p>In the next figure, which is inspired by the geometry considered in this tutorial, we make an attempt to compare the behavior of the three projectors considered. As can be seen on the left, given the original cell (in blue), the new point found with the normal projection is in a position which does not allow for the generation of evenly spaced new elements (in red). The situation will get worse in further refinement steps. Since the geometry we considered is somehow perpendicular to the horizontal direction, the directional projection (central image) defined with horizontal direction as the projection direction, does a rather good job in getting the new mesh point. Yet, since the surface is almost horizontal at the bottom of the picture, we can expect problems in those regions when further refinement steps are carried out. Finally, the picture on the right shows that a node located on the cell axis will result in two new cells having the same length. Of course the situation in 3D gets a little more complicated than that described in this simple 2D case. Nevertheless, the results of this test confirm that the normal to the mesh direction is the best approach among the three tested, when arbitrarily shaped surfaces are considered, and unless you have a geometry for which a more specific approach is known to be appropriate.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.ProjectionComparisons.png" width="700"/>
</div>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>In this program, we will consider creating a surface mesh for a real geometry describing the bow of a ship (this geometry is frequently used in CAD and mesh generation comparisons and is freely available). The surface mesh we get from this could then be used to solve a boundary element equation to simulate the flow of water around the ship (in a way similar to <a class="el" href="step_34.html">step-34</a>) but we will not try to do this here. To already give you an idea of the geometry we consider, here is a picture:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.bare.png" width="500"/>
</div>
<p>In the program, we read both the geometry and a coarse mesh from files, and then employ several of the options discussed above to place new vertices for a sequence of mesh refinement steps. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with including a bunch of files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div></div><!-- fragment --><p>These are the headers of the opencascade support classes and functions. Notice that these will contain sensible data only if you compiled your deal.II library with support for <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a>, i.e., specifying <code>-DDEAL_II_WITH_OPENCASCADE=ON</code> and <code>-DOPENCASCADE_DIR=/path/to/your/opencascade/installation</code> when calling <code>cmake</code> during deal.II configuration.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/opencascade/boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/opencascade/utilities.h&gt;</span></div></div><!-- fragment --><p>Finally, a few C++ standard header files</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>We isolate the rest of the program in its own namespace</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheTriangulationOnCADclass"></a> </p><h3>The TriangulationOnCAD class</h3>
<p>This is the main class. All it really does is store names for input and output files, and a triangulation. It then provides a function that generates such a triangulation from a coarse mesh, using one of the strategies discussed in the introduction and listed in the enumeration type at the top of the class.</p>
<p>The member functions of this class are similar to what you can find in most of the other tutorial programs in the setup stage of the grid for the simulations.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TriangulationOnCAD</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> ProjectionType</div><div class="line">  {</div><div class="line">    NormalProjection = 0,</div><div class="line">    DirectionalProjection = 1,</div><div class="line">    NormalToMeshProjection = 2</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD(<span class="keyword">const</span> std::string &amp;initial_mesh_filename,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;cad_file_name,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;output_filename,</div><div class="line">                     <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line"></div><div class="line">  ~TriangulationOnCAD();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a>   tria;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string     initial_mesh_filename;</div><div class="line">  <span class="keyword">const</span> std::string     cad_file_name;</div><div class="line">  <span class="keyword">const</span> std::string     output_filename;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ProjectionType  surface_projection_kind;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADTriangulationOnCAD"></a> </p><h4>TriangulationOnCAD::TriangulationOnCAD</h4>
<p>The constructor of the TriangulationOnCAD class is very simple. The input arguments are strings for the input and output file names, and the enumeration type that determines which kind of surface projector is used in the mesh refinement cycles (see below for details).</p>
<div class="fragment"><div class="line">TriangulationOnCAD::TriangulationOnCAD(<span class="keyword">const</span> std::string &amp;initial_mesh_filename,</div><div class="line">                                       <span class="keyword">const</span> std::string &amp;cad_file_name,</div><div class="line">                                       <span class="keyword">const</span> std::string &amp;output_filename,</div><div class="line">                                       <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">  :</div><div class="line">  initial_mesh_filename(initial_mesh_filename),</div><div class="line">  cad_file_name(cad_file_name),</div><div class="line">  output_filename(output_filename),</div><div class="line">  surface_projection_kind(surface_projection_kind)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line">TriangulationOnCAD::~TriangulationOnCAD()</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADread_domain"></a> </p><h4>TriangulationOnCAD::read_domain</h4>
<p>The following function represents the core of this program. In this function we import the CAD shape upon which we want to generate and refine our triangulation. We assume that the CAD surface is contained in the <code>cad_file_name</code> file (we provide an example IGES file in the input directory called "input/DTMB-5415_bulbous_bow.iges" that represents the bulbous bow of a ship). The presence of several convex and concave high curvature regions makes the geometry we provided a particularly meaningful example.</p>
<p>After importing the hull bow surface, we extract some of the curves and surfaces composing it, and use them to generate a set of projectors. Such projectors define the rules the <a class="el" href="classTriangulation.html">Triangulation</a> has to follow to position each new node during cell refinement.</p>
<p>To initialize the <a class="el" href="classTriangulation.html">Triangulation</a>, as done in previous tutorial programs, we import a pre-existing grid saved in VTK format. We assume here that the user has generated a coarse mesh externally, which matches the IGES geometry. At the moment of writing this tutorial, the deal.II library does not automatically support generation of such meshes, but there are several tools which can provide you with reasonable initial meshes starting from CAD files. In our example, the imported mesh is composed of a single quadrilateral cell whose vertices have been placed on the CAD shape.</p>
<p>After importing both the IGES geometry and the initial mesh, we assign the projectors previously discussed to each of the edges and cells which will have to be refined on the CAD surface.</p>
<p>In this tutorial, we will test the three different CAD surface projectors described in the introduction, and will analyze the results obtained with each of them. As mentioned, each of these projection strategies has been implemented in a different class, and objects of these types can be assigned to a triangulation using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> method.</p>
<p>The following function then first imports the given CAD file. The function arguments are a string containing the desired file name, and a scale factor. In this example, the scale factor is set to 1e-3, as the original geometry is written in millimeters (which is the typical unit of measure for most IGES files), while we prefer to work in meters. The output of the function is an object of <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> generic topological shape class, namely a <code>TopoDS_Shape</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">{</div><div class="line">  TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div></div><!-- fragment --><p>Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance <code>tol</code> of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius <code>tol</code>. While projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built.</p>
<p>The following method extracts the tolerance of the given shape and makes it a bit bigger to stay our of trouble:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div></div><!-- fragment --><p>We now want to extract a set of composite sub-shapes from the generic shape. In particular, each face of the CAD file is composed of a trimming curve of type <code>TopoDS_Wire</code>, which is the collection of <code>TopoDS_Edges</code> that compose the boundary of a surface, and a NURBS description of the surface itself. We will use a line projector to associate the boundary of our <a class="el" href="classTriangulation.html">Triangulation</a> to the wire delimiting the surface. To extract all compound sub-shapes, like wires, shells, or solids, we resort to a method of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace. The input of <a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a> is a shape and a set of empty std::vectors of subshapes, which will be filled with all compound shapes found in the given topological shape:</p>
<div class="fragment"><div class="line">std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line"><a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(bow_surface,</div><div class="line">                                     compounds,</div><div class="line">                                     compsolids,</div><div class="line">                                     solids,</div><div class="line">                                     shells,</div><div class="line">                                     wires);</div></div><!-- fragment --><p>The next few steps are more familiar, and allow us to import an existing mesh from an external VTK file, and convert it to a deal triangulation.</p>
<div class="fragment"><div class="line">std::ifstream in;</div><div class="line"></div><div class="line">in.open(initial_mesh_filename.c_str());</div><div class="line"></div><div class="line"><a class="code" href="classGridIn.html">GridIn&lt;2,3&gt;</a> gi;</div><div class="line">gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">gi.<a class="code" href="classGridIn.html#a058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div></div><!-- fragment --><p>We output this initial mesh saving it as the refinement step 0.</p>
<div class="fragment"><div class="line">output_results(0);</div></div><!-- fragment --><p>The mesh imported has a single, two-dimensional cell located in three-dimensional space. We now want to ensure that it is refined according to the CAD geometry imported above. This this end, we get an iterator to that cell and assign to it the manifold_id 1 (see <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">this glossary entry</a>). We also get an iterator to its four faces, and assign each of them the manifold_id 2:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2,3&gt;::active_cell_iterator</a> cell = tria.begin_active();</div><div class="line">cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;2&gt;::faces_per_cell; ++f)</div><div class="line">  cell-&gt;face(f)-&gt;set_manifold_id(2);</div></div><!-- fragment --><p>Once both the CAD geometry and the initial mesh have been imported and digested, we use the CAD surfaces and curves to define the projectors and assign them to the manifold ids just specified.</p>
<p>A first projector is defined using the single wire contained in our CAD file. The ArclengthProjectionLineManifold will make sure that every mesh edge located on the wire is refined with a point that lies on the wire and splits it into two equal arcs lying between the edge vertices. We first check that the wires vector contains at least one element and then create a boundary object for it. (The object is marked as <code>static</code> to ensure that it survives past the end of the current function, as we want to attach it to the triangulation object for later use).</p>
<p>Once the projector is created, we then assign it to all the parts of the triangulation with manifold_id = 2:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(wires.size() &gt; 0,</div><div class="line">       <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2,3&gt;</a></div><div class="line">line_projector (wires[0], tolerance);</div><div class="line"></div><div class="line">tria.set_manifold(2, line_projector);</div></div><!-- fragment --><p>The surface projector is created according to what is specified with the <code>surface_projection_kind</code> option of the constructor. In particular, if the surface_projection_kind value equals <code>NormalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalProjectionBoundary.html">OpenCASCADE::NormalProjectionBoundary</a>. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along its normal direction. The NormalProjectionBoundary constructor only needs a shape and a tolerance, and we then assign it to the triangulation for use with all parts that manifold having id 1:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> NormalProjection:</div><div class="line">    <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1NormalProjectionBoundary.html">OpenCASCADE::NormalProjectionBoundary&lt;2,3&gt;</a></div><div class="line">    normal_projector(bow_surface, tolerance);</div><div class="line"></div><div class="line">    tria.set_manifold(1,normal_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div></div><!-- fragment --><p><code>If</code> surface_projection_kind value is <code>DirectionalProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">OpenCASCADE::DirectionalProjectionBoundary</a> class. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is specified to the <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">OpenCASCADE::DirectionalProjectionBoundary</a> constructor. In this case, the projection is done along the y-axis.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">  <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">OpenCASCADE::DirectionalProjectionBoundary&lt;2,3&gt;</a></div><div class="line">  directional_projector(bow_surface, <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0,1.0,0.0), tolerance);</div><div class="line"></div><div class="line">  tria.set_manifold(1,directional_projector);</div><div class="line"></div><div class="line">  <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>As a third option, if <code>surface_projection_kind</code> value is <code>NormalToMeshProjection</code>, we select the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary</a>. The new mesh points will again initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is an estimate of the mesh normal direction. The <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary</a> constructor only requires a shape (containing at least a face) and a tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">  <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary&lt;2,3&gt;</a></div><div class="line">  normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line"></div><div class="line">  tria.set_manifold(1,normal_to_mesh_projector);</div><div class="line"></div><div class="line">  <span class="keywordflow">break</span>;</div></div><!-- fragment --><p>Finally, we use good software cleanliness by ensuring that this really covers all possible options of the <code>case</code> statement. If we get any other value, we simply abort the program:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrefine_mesh"></a> </p><h4>TriangulationOnCAD::refine_mesh</h4>
<p>This function globally refines the mesh. In other tutorials, it would typically also distribute degrees of freedom, and resize matrices and vectors. These tasks are not carried out here, since we are not running any simulation on the <a class="el" href="classTriangulation.html">Triangulation</a> produced.</p>
<p>While the function looks innocent, this is where most of the work we are interested in for this tutorial program actually happens. In particular, when refining the quads and lines that define the surface of the ship's hull, the <a class="el" href="classTriangulation.html">Triangulation</a> class will ask the various objects we have assigned to handle individual manifold ids for where the new vertices should lie.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">{</div><div class="line">  tria.refine_global(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADoutput_results"></a> </p><h4>TriangulationOnCAD::output_results</h4>
<p>Outputting the results of our computations is a rather mechanical task. All the components of this function have been discussed before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = ( output_filename + <span class="stringliteral">&quot;_&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtk&quot;</span> );</div><div class="line">  std::ofstream logfile(filename.c_str());</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TriangulationOnCADrun"></a> </p><h4>TriangulationOnCAD::run</h4>
<p>This is the main function. It should be self explanatory in its briefness:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::run()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle+1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is the main function of this program. It is in its basic structure like all previous tutorial programs, but runs the main class through the three possibilities of new vertex placement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      std::string out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(in_mesh_filename,</div><div class="line">                                         cad_file_name,</div><div class="line">                                         out_mesh_filename,</div><div class="line">                                         TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(in_mesh_filename,</div><div class="line">                                                  cad_file_name,</div><div class="line">                                                  out_mesh_filename,</div><div class="line">                                                  TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program execution produces a series of mesh files <code>3d_mesh_*.vtk</code> that we can visualize with any of the usual visualization programs that can read the VTK file format.</p>
<p>The following table illustrates the results obtained employing the normal projection strategy. The first two rows of the table show side views of the grids obtained for progressive levels of refinement, overlain on a very fine rendering of the exact geometry. The dark and light red areas simply indicate whether the current mesh or the fine geometry is closer to the observer; the distinction does not carry any particularly deep meaning. The last row of pictures depict front views (mirrored to both sides of the geometry) of the same grids shown in the second row.</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>As can be seen in the pictures&mdash;and as we anticipated&mdash;the normal refinement strategy is unable to produce nicely shaped elements when applied to surfaces with significant curvature changes. This is particularly apparent at the bulb of the hull where all new points have been placed in the upper part of the bulb and the lower part remains completely unresolved.</p>
<p>The following table, which is arranged as the previous one, illustrates the results obtained adopting the directional projection approach, in which the projection direction selected was the y-axis (which is indicated with a small yellow arrow at the bottom left of each image).</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.directional_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The images confirm that the quality of the mesh obtained with a directional projection is sensibly higher than that obtained projecting along the surface normal. Yet, a number of elements elongated in the y-direction are observed around the bottom of the bulb, where the surface is almost parallel to the direction chosen for the projection.</p>
<p>The final test shows results using instead the projection normal to the faces:</p>
<table style="width:90%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.common_0.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_1.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_2.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_5.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_3.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_4.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-54.normal_to_mesh_front_5.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The pictures confirm that the normal to mesh projection approach leads to grids that remain evenly spaced throughtout the refinement steps. At the same time, these meshes represent rather well the original geometry even in the bottom region of the bulb, which is not well recovered employing the directional projector or the normal projector.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *  Authors: Andrea Mola, Luca Heltai, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/opencascade/boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/opencascade/utilities.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step54</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>TriangulationOnCAD</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> ProjectionType</div><div class="line">    {</div><div class="line">      NormalProjection = 0,</div><div class="line">      DirectionalProjection = 1,</div><div class="line">      NormalToMeshProjection = 2</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    TriangulationOnCAD(<span class="keyword">const</span> std::string &amp;initial_mesh_filename,</div><div class="line">                       <span class="keyword">const</span> std::string &amp;cad_file_name,</div><div class="line">                       <span class="keyword">const</span> std::string &amp;output_filename,</div><div class="line">                       <span class="keyword">const</span> ProjectionType surface_projection_kind = NormalProjection);</div><div class="line"></div><div class="line"></div><div class="line">    ~TriangulationOnCAD();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> read_domain();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2, 3&gt;</a>   tria;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string     initial_mesh_filename;</div><div class="line">    <span class="keyword">const</span> std::string     cad_file_name;</div><div class="line">    <span class="keyword">const</span> std::string     output_filename;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ProjectionType  surface_projection_kind;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  TriangulationOnCAD::TriangulationOnCAD(<span class="keyword">const</span> std::string &amp;initial_mesh_filename,</div><div class="line">                                         <span class="keyword">const</span> std::string &amp;cad_file_name,</div><div class="line">                                         <span class="keyword">const</span> std::string &amp;output_filename,</div><div class="line">                                         <span class="keyword">const</span> ProjectionType surface_projection_kind)</div><div class="line">    :</div><div class="line">    initial_mesh_filename(initial_mesh_filename),</div><div class="line">    cad_file_name(cad_file_name),</div><div class="line">    output_filename(output_filename),</div><div class="line">    surface_projection_kind(surface_projection_kind)</div><div class="line">  {</div><div class="line">  }</div><div class="line"></div><div class="line">  TriangulationOnCAD::~TriangulationOnCAD()</div><div class="line">  {</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::read_domain()</div><div class="line">  {</div><div class="line">    TopoDS_Shape bow_surface = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name, 1e-3);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">OpenCASCADE::get_shape_tolerance</a>(bow_surface) * 5;</div><div class="line"></div><div class="line">    std::vector&lt;TopoDS_Compound&gt;  compounds;</div><div class="line">    std::vector&lt;TopoDS_CompSolid&gt; compsolids;</div><div class="line">    std::vector&lt;TopoDS_Solid&gt;     solids;</div><div class="line">    std::vector&lt;TopoDS_Shell&gt;     shells;</div><div class="line">    std::vector&lt;TopoDS_Wire&gt;      wires;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">OpenCASCADE::extract_compound_shapes</a>(bow_surface,</div><div class="line">                                         compounds,</div><div class="line">                                         compsolids,</div><div class="line">                                         solids,</div><div class="line">                                         shells,</div><div class="line">                                         wires);</div><div class="line"></div><div class="line">    std::ifstream in;</div><div class="line"></div><div class="line">    in.open(initial_mesh_filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;2,3&gt;</a> gi;</div><div class="line">    gi.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    gi.<a class="code" href="classGridIn.html#a058cd187cea704428ac1118410cd0fb8">read_vtk</a>(in);</div><div class="line"></div><div class="line">    output_results(0);</div><div class="line"></div><div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2,3&gt;::active_cell_iterator</a> cell = tria.begin_active();</div><div class="line">    cell-&gt;set_manifold_id(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;2&gt;::faces_per_cell; ++f)</div><div class="line">      cell-&gt;face(f)-&gt;set_manifold_id(2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(wires.size() &gt; 0,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;I could not find any wire in the CAD file you gave me. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;2,3&gt;</a></div><div class="line">    line_projector (wires[0], tolerance);</div><div class="line"></div><div class="line">    tria.set_manifold(2, line_projector);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (surface_projection_kind)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> NormalProjection:</div><div class="line">        <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1NormalProjectionBoundary.html">OpenCASCADE::NormalProjectionBoundary&lt;2,3&gt;</a></div><div class="line">        normal_projector(bow_surface, tolerance);</div><div class="line"></div><div class="line">        tria.set_manifold(1,normal_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> DirectionalProjection:</div><div class="line">        <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">OpenCASCADE::DirectionalProjectionBoundary&lt;2,3&gt;</a></div><div class="line">        directional_projector(bow_surface, <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0.0,1.0,0.0), tolerance);</div><div class="line"></div><div class="line">        tria.set_manifold(1,directional_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> NormalToMeshProjection:</div><div class="line">        <span class="keyword">static</span> <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">OpenCASCADE::NormalToMeshProjectionBoundary&lt;2,3&gt;</a></div><div class="line">        normal_to_mesh_projector(bow_surface, tolerance);</div><div class="line"></div><div class="line">        tria.set_manifold(1,normal_to_mesh_projector);</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::refine_mesh()</div><div class="line">  {</div><div class="line">    tria.refine_global(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string filename = ( output_filename + <span class="stringliteral">&quot;_&quot;</span> +</div><div class="line">                                   <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) +</div><div class="line">                                   <span class="stringliteral">&quot;.vtk&quot;</span> );</div><div class="line">    std::ofstream logfile(filename.c_str());</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">write_vtk</a>(tria, logfile);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> TriangulationOnCAD::run()</div><div class="line">  {</div><div class="line">    read_domain();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = 5;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        refine_mesh();</div><div class="line">        output_results(cycle+1);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step54;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string in_mesh_filename = <span class="stringliteral">&quot;input/initial_mesh_3d.vtk&quot;</span>;</div><div class="line">      <span class="keyword">const</span> std::string cad_file_name = <span class="stringliteral">&quot;input/DTMB-5415_bulbous_bow.iges&quot;</span>;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to CAD surface&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      std::string out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_normal_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,</div><div class="line">                                          cad_file_name,</div><div class="line">                                          out_mesh_filename,</div><div class="line">                                          TriangulationOnCAD::NormalProjection);</div><div class="line">      tria_on_cad_norm.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in y-axis direction&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_directional_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_dir(in_mesh_filename,</div><div class="line">                                         cad_file_name,</div><div class="line">                                         out_mesh_filename,</div><div class="line">                                         TriangulationOnCAD::DirectionalProjection);</div><div class="line">      tria_on_cad_dir.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Testing projection in direction normal to mesh elements&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      out_mesh_filename = ( <span class="stringliteral">&quot;3d_mesh_normal_to_mesh_projection&quot;</span> );</div><div class="line">      TriangulationOnCAD tria_on_cad_norm_to_mesh(in_mesh_filename,</div><div class="line">                                                  cad_file_name,</div><div class="line">                                                  out_mesh_filename,</div><div class="line">                                                  TriangulationOnCAD::NormalToMeshProjection);</div><div class="line">      tria_on_cad_norm_to_mesh.run();</div><div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------------&quot;</span> &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">      cout &lt;&lt; endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
