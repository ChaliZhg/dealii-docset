<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-5 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-5 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeStep5codeclasstemplate">The <code>Step5</code> class template</a>
        <li><a href="#Workingwithnonconstantcoefficients">Working with nonconstant coefficients</a>
        <li><a href="#ThecodeStep5codeclassimplementation">The <code>Step5</code> class implementation</a>
      <ul>
        <li><a href="#Step5Step5">Step5::Step5</a>
        <li><a href="#Step5setup_system">Step5::setup_system</a>
        <li><a href="#Step5assemble_system">Step5::assemble_system</a>
        <li><a href="#Step5solve">Step5::solve</a>
        <li><a href="#Step5output_resultsandsettingoutputflags">Step5::output_results and setting output flags</a>
        <li><a href="#Step5run">Step5::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.14.html">video lecture 14</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>This example does not show revolutionary new things, but it shows many small improvements over the previous examples, and also many small things that can usually be found in finite element programs. Among them are: </p><ul>
<li>
Computations on successively refined grids. At least in the mathematical sciences, it is common to compute solutions on a hierarchy of grids, in order to get a feeling for the accuracy of the solution; if you only have one solution on a single grid, you usually can't guess the accuracy of the solution. Furthermore, deal.II is designed to support adaptive algorithms where iterative solution on successively refined grids is at the heart of algorithms. Although adaptive grids are not used in this example, the foundations for them is laid here. </li>
<li>
In practical applications, the domains are often subdivided into triangulations by automatic mesh generators. In order to use them, it is important to read coarse grids from a file. In this example, we will read a coarse grid in UCD (unstructured cell data) format. When this program was first written around 2000, UCD format was what the AVS Explorer used &ndash; a program reasonably widely used at the time but now no longer of importance. (Nonetheless, the file format has survived and is still understood by a number of programs.) </li>
<li>
Finite element programs usually use extensive amounts of computing time, so some optimizations are sometimes necessary. We will show some of them. </li>
<li>
On the other hand, finite element programs tend to be rather complex, so debugging is an important aspect. We support safe programming by using assertions that check the validity of parameters and internal states in a debug mode, but are removed in optimized mode. (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.18.html">video lecture 18</a>.) </li>
<li>
Regarding the mathematical side, we show how to support a variable coefficient in the elliptic operator and how to use preconditioned iterative solvers for the linear systems of equations. </li>
</ul>
<p>The equation to solve here is as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\nabla \cdot a(\mathbf x) \nabla u(\mathbf x) &amp;= 1 \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}" src="form_3887.png"/>
</p>
<p> If <img class="formulaInl" alt="$a(\mathbf x)$" src="form_3145.png"/> was a constant coefficient, this would simply be the Poisson equation. However, if it is indeed spatially variable, it is a more complex equation (often referred to as the "extended Poisson equation"). Depending on what the variable <img class="formulaInl" alt="$u$" src="form_256.png"/> refers to it models a variety of situations with wide applicability:</p>
<ul>
<li>If <img class="formulaInl" alt="$u$" src="form_256.png"/> is the electric potential, then <img class="formulaInl" alt="$-a\nabla u$" src="form_3888.png"/> is the electric current in a medium and the coefficient <img class="formulaInl" alt="$a$" src="form_523.png"/> is the conductivity of the medium at any given point. (In this situation, the right hand side of the equation would be the electric source density and would usually be zero or consist of localized, Delta-like, functions.)</li>
<li>If <img class="formulaInl" alt="$u$" src="form_256.png"/> is the vertical deflection of a thin membrane, then <img class="formulaInl" alt="$a$" src="form_523.png"/> would be a measure of the local stiffness. This is the interpretation that will allow us to interpret the images shown in the results section below.</li>
</ul>
<p>Since the Laplace/Poisson equation appears in so many contexts, there are many more interpretations than just the two listed above.</p>
<p>When assembling the linear system for this equation, we need the weak form which here reads as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (a \nabla \varphi, \nabla u) &amp;= (\varphi, 1) \qquad \qquad \forall \varphi. \end{align*}" src="form_3889.png"/>
</p>
<p> The implementation in the <code>assemble_system</code> function follows immediately from this. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div></div><!-- fragment --><p>This one is new. We want to read a triangulation from disk, and the class which does this is declared in the following file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div></div><!-- fragment --><p>We will use a circular domain, and the object describing the boundary of it comes from this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div></div><!-- fragment --><p>This is C++ ...</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>... and this is too: We will convert integers to strings using the C++ stringstream class <code>ostringstream</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div></div><!-- fragment --><p>Finally, this has been discussed in previous tutorial programs before:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep5codeclasstemplate"></a> </p><h3>The <code>Step5</code> class template</h3>
<p>The main class is mostly as in the previous example. The most visible change is that the function <code>make_grid_and_dofs</code> has been removed, since creating the grid is now done in the <code>run</code> function and the rest of its functionality is now in <code>setup_system</code>. Apart from this, everything is as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step5</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step5 ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Workingwithnonconstantcoefficients"></a> </p><h3>Working with nonconstant coefficients</h3>
<p>In <a class="el" href="step_4.html">step-4</a>, we showed how to use non-constant boundary values and right hand side. In this example, we want to use a variable coefficient in the elliptic operator instead. Since we have a function which just depends on the point in space we can do things a bit more simply and use a plain function instead of inheriting from <a class="el" href="classFunction.html">Function</a>.</p>
<p>This is the implementation of the coefficient function for a single point. We let it return 20 if the distance to the origin is less than 0.5, and 1 otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> coefficient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>() &lt; 0.5*0.5)</div><div class="line">    <span class="keywordflow">return</span> 20;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep5codeclassimplementation"></a> </p><h3>The <code>Step5</code> class implementation</h3>
<p><a class="anchor" id="Step5Step5"></a> </p><h4>Step5::Step5</h4>
<p>This function is as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step5&lt;dim&gt;::Step5 () :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step5setup_system"></a> </p><h4>Step5::setup_system</h4>
<p>This is the function <code>make_grid_and_dofs</code> from the previous example, minus the generation of the grid. Everything else is unchanged:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step5assemble_system"></a> </p><h4>Step5::assemble_system</h4>
<p>As in the previous examples, this function is not changed much with regard to its functionality, but there are still some optimizations which we will show. For this, it is important to note that if efficient solvers are used (such as the preconditioned CG method), assembling the matrix and right hand side can take a comparable time, and you should think about using one or two optimizations at some places.</p>
<p>What we will show here is how we can avoid calls to the shape_value, shape_grad, and quadrature_point functions of the <a class="el" href="classFEValues.html">FEValues</a> object. The way to do so will be explained in the following, while those parts of this function that are not changed with respect to the previous example are not commented on.</p>
<p>The first parts of the function are completely unchanged from before:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>Next is the typical loop over all cells to compute local contributions and then to transfer them into the global matrix and vector. The only change in this part, compared to <a class="el" href="step_4.html">step-4</a>, is that we will use the <code>coefficient</code> function defined above to compute the coefficient value at each quadrature point.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line">    cell_rhs = 0;</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index=0; q_index&lt;n_q_points; ++q_index)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient = coefficient&lt;dim&gt;</div><div class="line">                                           (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (q_index));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              cell_matrix(i,j) += (current_coefficient *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_index) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_index) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line"></div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_index) *</div><div class="line">                            1.0 *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add (local_dof_indices[i],</div><div class="line">                             local_dof_indices[j],</div><div class="line">                             cell_matrix(i,j));</div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>With the matrix so built, we use zero boundary values again:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                            boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step5solve"></a> </p><h4>Step5::solve</h4>
<p>The solution process again looks mostly like in the previous examples. However, we will now use a preconditioned conjugate gradient algorithm. It is not very difficult to make this change. In fact, the only thing we have to alter is that we need an object which will act as a preconditioner. We will use SSOR (symmetric successive overrelaxation), with a relaxation factor of 1.2. For this purpose, the <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> class has a function which does one SSOR step, and we need to package the address of this function together with the matrix on which it should act (which is the matrix to be inverted) and the relaxation factor into one object. The <code><a class="el" href="classPreconditionSSOR.html">PreconditionSSOR</a></code> class does this for us. (<code><a class="el" href="classPreconditionSSOR.html">PreconditionSSOR</a></code> class takes a template argument denoting the matrix type it is supposed to work on. The default value is <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;double&gt;</code>, which is exactly what we need here, so we simply stick with the default and do not specify anything in the angle brackets.)</p>
<p>Note that for the present case, SSOR doesn't really perform much better than most other preconditioners (though better than no preconditioning at all). A brief comparison of different preconditioners is presented in the Results section of the next tutorial program, <a class="el" href="step_6.html">step-6</a>.</p>
<p>With this, the rest of the function is trivial: instead of the <code><a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a></code> object we have created before, we now use the preconditioner we have declared, and the CG solver will do the rest for us:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step5output_resultsandsettingoutputflags"></a> </p><h4>Step5::output_results and setting output flags</h4>
<p>Writing output to a file is mostly the same as for the previous example, but here we will show how to modify some output options and how to construct a different filename for each refinement cycle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div></div><!-- fragment --><p>For this example, we would like to write the output directly to a file in Encapsulated Postscript (EPS) format. The library supports this, but things may be a bit more difficult sometimes, since EPS is a printing format, unlike most other supported formats which serve as input for graphical tools. Therefore, you can't scale or rotate the image after it has been written to disk, and you have to decide about the viewpoint or the scaling in advance.</p>
<p>The defaults in the library are usually quite reasonable, and regarding viewpoint and scaling they coincide with the defaults of Gnuplot. However, since this is a tutorial, we will demonstrate how to change them. For this, we first have to generate an object describing the flags for EPS output (similar flag classes exist for all supported output formats):</p>
<div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1EpsFlags.html">DataOutBase::EpsFlags</a> eps_flags;</div></div><!-- fragment --><p>They are initialized with the default values, so we only have to change those that we don't like. For example, we would like to scale the z-axis differently (stretch each data point in z-direction by a factor of four):</p>
<div class="fragment"><div class="line">eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#aae56c32425575726b67b106edef3787b">z_scaling</a> = 4;</div></div><!-- fragment --><p>Then we would also like to alter the viewpoint from which we look at the solution surface. The default is at an angle of 60 degrees down from the vertical axis, and 30 degrees rotated against it in mathematical positive sense. We raise our viewpoint a bit and look more along the y-axis:</p>
<div class="fragment"><div class="line">eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#afb565808367b204a1abbc5ecdf68278b">azimut_angle</a> = 40;</div><div class="line">eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#a3afae76795cf33c76a3f65af902abf41">turn_angle</a>   = 10;</div></div><!-- fragment --><p>That shall suffice. There are more flags, for example whether to draw the mesh lines, which data vectors to use for colorization of the interior of the cells, and so on. You may want to take a look at the documentation of the EpsFlags structure to get an overview of what is possible.</p>
<p>The only thing still to be done, is to tell the output object to use these flags:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (eps_flags);</div></div><!-- fragment --><p>The above way to modify flags requires recompilation each time we would like to use different flags. This is inconvenient, and we will see more advanced ways in <a class="el" href="step_19.html">step-19</a> where the output flags are determined at run time using an input file (<a class="el" href="step_19.html">step-19</a> doesn't show many other things; you should feel free to read over it even if you haven't done <a class="el" href="step_6.html">step-6</a> to <a class="el" href="step_18.html">step-18</a> yet).</p>
<p>Finally, we need the filename to which the results are to be written. We would like to have it of the form <code>solution-N.eps</code>, where N is the number of the refinement cycle. Thus, we have to convert an integer to a part of a string; this can be done using the <code>sprintf</code> function, but in C++ there is a more elegant way: write everything into a special stream (just like writing into a file or to the screen) and retrieve what you wrote as a string. This applies the usual conversions from integer to strings, and one could as well use stream modifiers such as <code>setw</code>, <code>setprecision</code>, and so on. In C++, you can do this by using the so-called stringstream classes:</p>
<div class="fragment"><div class="line">std::ostringstream filename;</div></div><!-- fragment --><p>In order to now actually generate a filename, we fill the stringstream variable with the base of the filename, then the number part, and finally the suffix indicating the file type:</p>
<div class="fragment"><div class="line">filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">         &lt;&lt; cycle</div><div class="line">         &lt;&lt; <span class="stringliteral">&quot;.eps&quot;</span>;</div></div><!-- fragment --><p>We can get whatever we wrote to the stream using the <code>str()</code> function. The result is a string which we have to convert to a char* using the <code>c_str()</code> function. Use that as filename for the output stream and then write the data to the file :</p>
<div class="fragment"><div class="line">  std::ofstream output (filename.str().c_str());</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step5run"></a> </p><h4>Step5::run</h4>
<p>The second to last thing in this program is the definition of the <code>run()</code> function. In contrast to the previous programs, we will compute on a sequence of meshes that after each iteration is globally refined. The function therefore consists of a loop over 6 cycles. In each cycle, we first print the cycle number, and then have to decide what to do with the mesh. If this is not the first cycle, we simply refine the existing mesh once globally. Before running through these cycles, however, we have to generate a mesh:</p>
<p>In previous examples, we have already used some of the functions from the <code><a class="el" href="namespaceGridGenerator.html">GridGenerator</a></code> class. Here we would like to read a grid from a file where the cells are stored and which may originate from someone else, or may be the product of a mesh generator tool.</p>
<p>In order to read a grid from a file, we generate an object of data type <a class="el" href="classGridIn.html">GridIn</a> and associate the triangulation to it (i.e. we tell it to fill our triangulation object when we ask it to read the file). Then we open the respective file and initialize the triangulation with the data in the file :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim&gt;</a> grid_in;</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a> (triangulation);</div><div class="line">  std::ifstream input_file(<span class="stringliteral">&quot;circle-grid.inp&quot;</span>);</div></div><!-- fragment --><p>We would now like to read the file. However, the input file is only for a two-dimensional triangulation, while this function is a template for arbitrary dimension. Since this is only a demonstration program, we will not use different input files for the different dimensions, but rather quickly kill the whole program if we are not in 2D. Of course, since the main function below assumes that we are working in two dimensions we could skip this check, in this version of the program, without any ill effects.</p>
<p>It turns out that more than 90 per cent of programming errors are invalid function parameters such as invalid array sizes, etc, so we use assertions heavily throughout deal.II to catch such mistakes. For this, the <code>Assert</code> macro is a good choice, since it makes sure that the condition which is given as first argument is valid, and if not throws an exception (its second argument) which will usually terminate the program giving information where the error occurred and what the reason was. This generally reduces the time to find programming errors dramatically and we have found assertions an invaluable means to program fast.</p>
<p>On the other hand, all these checks (there are over 9000 of them in the library at present) should not slow down the program too much if you want to do large computations. To this end, the <code>Assert</code> macro is only used in debug mode and expands to nothing if in optimized mode. Therefore, while you test your program on small problems and debug it, the assertions will tell you where the problems are. Once your program is stable, you can switch off debugging and the program will run your real computations without the assertions and at maximum speed. More precisely: turning off all the checks in the library (which prevent you from calling functions with wrong arguments, walking off of arrays, etc.) by compiling your program in optimized mode usually makes things run about four times faster. Even though optimized programs are more performant, we still recommend developing in debug mode since it allows the library to find lots of common programming errors automatically. For those who want to try: The way to switch from debug mode to optimized mode is to recompile your program with the command <code>make release</code>. The output of the <code>make</code> program should now indicate to you that the program is now compiled in optimized mode, and it will later also be linked to libraries that have been compiled for optimized mode. In order to switch back to debug mode, simply recompile with the command <code>make debug</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dim==2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>ExcInternalError is a globally defined exception, which may be thrown whenever something is terribly wrong. Usually, one would like to use more specific exceptions, and particular in this case one would of course try to do something else if <code>dim</code> is not equal to two, e.g. create a grid using library functions. Aborting a program is usually not a good idea and assertions should really only be used for exceptional cases which should not occur, but might due to stupidity of the programmer, user, or someone else. The situation above is not a very clever use of Assert, but again: this is a tutorial and it might be worth to show what not to do, after all.</p>
<p>So if we got past the assertion, we know that dim==2, and we can now actually read the grid. It is in UCD (unstructured cell data) format (though the convention is to use the suffix <code>inp</code> for UCD files):</p>
<div class="fragment"><div class="line">grid_in.<a class="code" href="classGridIn.html#abbb16aa0aa53bfa9231b69278d397616">read_ucd</a> (input_file);</div></div><!-- fragment --><p>If you like to use another input format, you have to use one of the other <code>grid_in.read_xxx</code> function. (See the documentation of the <code><a class="el" href="classGridIn.html">GridIn</a></code> class to find out what input formats are presently supported.)</p>
<p>The grid in the file describes a circle. Therefore we have to use a manifold object which tells the triangulation where to put new points on the boundary when the grid is refined. This works in the same way as in the first example, but in this case we only set the manifold ids of the boundary.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary;</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cycle != 0)</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div></div><!-- fragment --><p>Now that we have a mesh for sure, we write some output and do all the things that we have already seen in the previous examples.</p>
<div class="fragment"><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system ();</div><div class="line">      assemble_system ();</div><div class="line">      solve ();</div><div class="line">      output_results (cycle);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function looks mostly like the one in the previous example, so we won't comment on it further:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Step5&lt;2&gt; laplace_problem_2d;</div><div class="line">  laplace_problem_2d.run ();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Here is the console output: </p><div class="fragment"><div class="line">Cycle 0:</div><div class="line">   Number of active cells: 20</div><div class="line">   Total number of cells: 20</div><div class="line">   Number of degrees of freedom: 25</div><div class="line">   13 CG iterations needed to obtain convergence.</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells: 80</div><div class="line">   Total number of cells: 100</div><div class="line">   Number of degrees of freedom: 89</div><div class="line">   18 CG iterations needed to obtain convergence.</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells: 320</div><div class="line">   Total number of cells: 420</div><div class="line">   Number of degrees of freedom: 337</div><div class="line">   29 CG iterations needed to obtain convergence.</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells: 1280</div><div class="line">   Total number of cells: 1700</div><div class="line">   Number of degrees of freedom: 1313</div><div class="line">   52 CG iterations needed to obtain convergence.</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells: 5120</div><div class="line">   Total number of cells: 6820</div><div class="line">   Number of degrees of freedom: 5185</div><div class="line">   95 CG iterations needed to obtain convergence.</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells: 20480</div><div class="line">   Total number of cells: 27300</div><div class="line">   Number of degrees of freedom: 20609</div><div class="line">   182 CG iterations needed to obtain convergence.</div></div><!-- fragment --><p>In each cycle, the number of cells quadruples and the number of CG iterations roughly doubles. Also, in each cycle, the program writes one output graphic file in EPS format. They are depicted in the following:</p>
<table width="100%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-0.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-1.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-2.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-3.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-4.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-5.solution-5.png"/>
</div>
   </td></tr>
</table>
<p>Due to the variable coefficient (the curvature there is reduced by the same factor by which the coefficient is increased), the top region of the solution is flattened. The gradient of the solution is discontinuous there, although this is not very clearly visible in the pictures above. We will look at this in more detail in the next example. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Step5</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step5 ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> coefficient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>() &lt; 0.5*0.5)</div><div class="line">    <span class="keywordflow">return</span> 20;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Step5&lt;dim&gt;::Step5 () :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index=0; q_index&lt;n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> current_coefficient = coefficient&lt;dim&gt;</div><div class="line">                                             (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (q_index));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += (current_coefficient *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_index) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_index) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line"></div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_index) *</div><div class="line">                              1.0 *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add (local_dof_indices[i],</div><div class="line">                               local_dof_indices[j],</div><div class="line">                               cell_matrix(i,j));</div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                            boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations needed to obtain convergence.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1EpsFlags.html">DataOutBase::EpsFlags</a> eps_flags;</div><div class="line">  eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#aae56c32425575726b67b106edef3787b">z_scaling</a> = 4;</div><div class="line">  eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#afb565808367b204a1abbc5ecdf68278b">azimut_angle</a> = 40;</div><div class="line">  eps_flags.<a class="code" href="structDataOutBase_1_1EpsFlags.html#a3afae76795cf33c76a3f65af902abf41">turn_angle</a>   = 10;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (eps_flags);</div><div class="line"></div><div class="line">  std::ostringstream filename;</div><div class="line"></div><div class="line">  filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">           &lt;&lt; cycle</div><div class="line">           &lt;&lt; <span class="stringliteral">&quot;.eps&quot;</span>;</div><div class="line"></div><div class="line">  std::ofstream output (filename.str().c_str());</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Step5&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim&gt;</a> grid_in;</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a> (triangulation);</div><div class="line">  std::ifstream input_file(<span class="stringliteral">&quot;circle-grid.inp&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dim==2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  grid_in.<a class="code" href="classGridIn.html#abbb16aa0aa53bfa9231b69278d397616">read_ucd</a> (input_file);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary;</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle != 0)</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system ();</div><div class="line">      assemble_system ();</div><div class="line">      solve ();</div><div class="line">      output_results (cycle);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  Step5&lt;2&gt; laplace_problem_2d;</div><div class="line">  laplace_problem_2d.run ();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
